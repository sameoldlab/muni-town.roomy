import "./NZTpNUN0.js";
import { O as Eh, ac as Gm, a7 as Km, q as Jm, z as Ym, h as Pe, a0 as Br, g as S, d as Me, b as te, u as at, e as X, p as Re, f as J, a as _e, s as je, A as cn, c as Se, m as pt, r as we, t as qe, _ as Eu, n as kn, au as sc, aN as Co, i as sn, j as il, aB as ze, a2 as nt, aC as fn, aD as $n, a$ as Xm, b0 as na, b1 as oc } from "./BMAj9zKA.js";
import { c as se, a as F, t as ae, e as Qn } from "./pDBoOQRd.js";
import { i as be } from "./BA1UOs1h.js";
import { C as Vn, a as Xt, w as ac, E as Ch, S as Oh, e as Ah, X as Qm, g as Zm, i as hn, j as Ne, m as vt, q as Mh, s as eg, Y as tg, n as Bs, Z as ng, _ as sl, $ as rg, v as Oo, d as ig, f as sg, h as og, B as yn, a0 as ag, a1 as ug, a2 as Gr, a3 as vi, a4 as ra, a5 as ol, p as lg, a6 as cg, __tla as __tla_0 } from "./BOaKtN8S.js";
import { c as Le, b as ct } from "./BUHZJKy3.js";
import { p as Be } from "./Baj-A2iI.js";
import { o as dg } from "./Be9Ooa0M.js";
import { s as ir, u as fg, m as hg } from "./DzGbYseb.js";
import { e as ji, i as Cu } from "./BuDgEN05.js";
import { I as mn, h as cs } from "./7tHZr1X2.js";
import { b as Ge, s as wi, a as pg } from "./DjDC-EQm.js";
import { o as uc, e as Oe } from "./BSdt-dIf.js";
import { t as Sn, g as ia, o as mg, __tla as __tla_1 } from "./C8D1QxlH.js";
import { g as gg, u as sa } from "./D7Oepc1u.js";
import { s as rt } from "./k4NpJaFV.js";
import { s as it, p as $, r as wt, a as An, b as dt, l as gt, c as Nh, m as Ph } from "./D_-9kNr4.js";
import "./69_IOA4Y.js";
import { d as an, g as Q, w as bt, r as Nr, a as lc } from "./Dxu-ImQV.js";
import { a as Xi, c as bg, o as Ao } from "./BqahWDdA.js";
import { i as $t } from "./CrW2qrX9.js";
import { H as yg, P as vg, a as wg, k as cc, b as xg, F as kg, A as Sg, h as Tg, i as Eg, j as Cg, l as Og, __tla as __tla_2 } from "./DfzdJtdG.js";
import { p as dc } from "./DMwpQjbe.js";
import { e as ln, i as xi, __tla as __tla_3 } from "./BUkYaDtB.js";
let N4, aa, oa, ua, P4, Uf, cu, b3;
let __tla = Promise.all([
  (() => {
    try {
      return __tla_0;
    } catch {
    }
  })(),
  (() => {
    try {
      return __tla_1;
    } catch {
    }
  })(),
  (() => {
    try {
      return __tla_2;
    } catch {
    }
  })(),
  (() => {
    try {
      return __tla_3;
    } catch {
    }
  })()
]).then(async () => {
  const Ag = [];
  function Mg(n, e = false) {
    return Fs(n, /* @__PURE__ */ new Map(), "", Ag);
  }
  function Fs(n, e, t, r, i = null) {
    if (typeof n == "object" && n !== null) {
      var s = e.get(n);
      if (s !== void 0) return s;
      if (n instanceof Map) return new Map(n);
      if (n instanceof Set) return new Set(n);
      if (Eh(n)) {
        var o = Array(n.length);
        e.set(n, o), i !== null && e.set(i, o);
        for (var a = 0; a < n.length; a += 1) {
          var u = n[a];
          a in n && (o[a] = Fs(u, e, t, r));
        }
        return o;
      }
      if (Gm(n) === Km) {
        o = {}, e.set(n, o), i !== null && e.set(i, o);
        for (var l in n) o[l] = Fs(n[l], e, t, r);
        return o;
      }
      if (n instanceof Date) return structuredClone(n);
      if (typeof n.toJSON == "function") return Fs(n.toJSON(), e, t, r, n);
    }
    if (n instanceof EventTarget) return n;
    try {
      return structuredClone(n);
    } catch {
      return n;
    }
  }
  function lt(n, e, t, r, i) {
    Jm && Ym();
    var s = e.$$slots?.[t], o = false;
    s === true && (s = e.children, o = true), s === void 0 || s(n, o ? () => r : r);
  }
  function zt(n, e, t) {
    Pe(() => {
      var r = Br(() => e(n, t?.()) || {});
      if (r?.destroy) return () => r.destroy();
    });
  }
  function Ae(n, e) {
    var t = n.$$events?.[e.type], r = Eh(t) ? t.slice() : t == null ? [] : [
      t
    ];
    for (var i of r) i.call(this, e);
  }
  function Mo(n, e = 250) {
    let t = Me(null);
    function r(...i) {
      if (S(t)) S(t).timeout && clearTimeout(S(t).timeout);
      else {
        let s, o;
        const a = new Promise((u, l) => {
          s = u, o = l;
        });
        te(t, Be({
          timeout: null,
          runner: null,
          promise: a,
          resolve: s,
          reject: o
        }));
      }
      return S(t).runner = async () => {
        if (!S(t)) return;
        const s = S(t);
        te(t, null);
        try {
          s.resolve(await n.apply(this, i));
        } catch (o) {
          s.reject(o);
        }
      }, S(t).timeout = setTimeout(S(t).runner, typeof e == "function" ? e() : e), S(t).promise;
    }
    return r.cancel = async () => {
      (!S(t) || S(t).timeout === null) && (await new Promise((i) => setTimeout(i, 0)), !S(t) || S(t).timeout === null) || (clearTimeout(S(t).timeout), S(t).reject("Cancelled"), te(t, null));
    }, r.runScheduledNow = async () => {
      (!S(t) || !S(t).timeout) && (await new Promise((i) => setTimeout(i, 0)), !S(t) || !S(t).timeout) || (clearTimeout(S(t).timeout), S(t).timeout = null, await S(t).runner?.());
    }, Object.defineProperty(r, "pending", {
      enumerable: true,
      get() {
        return !!S(t)?.timeout;
      }
    }), r;
  }
  class al {
    #e = Me(false);
    constructor() {
      at(() => (Br(() => te(this.#e, true)), () => {
        te(this.#e, false);
      }));
    }
    get current() {
      return S(this.#e);
    }
  }
  const Ng = "data-checkbox-root";
  class Pg {
    opts;
    group;
    #e = X(() => this.group && this.group.opts.name.current ? this.group.opts.name.current : this.opts.name.current);
    get trueName() {
      return S(this.#e);
    }
    #t = X(() => this.group && this.group.opts.required.current ? true : this.opts.required.current);
    get trueRequired() {
      return S(this.#t);
    }
    #n = X(() => this.group && this.group.opts.disabled.current ? true : this.opts.disabled.current);
    get trueDisabled() {
      return S(this.#n);
    }
    constructor(e, t = null) {
      this.opts = e, this.group = t, this.onkeydown = this.onkeydown.bind(this), this.onclick = this.onclick.bind(this), Xt(e), ac.pre([
        () => Mg(this.group?.opts.value.current),
        () => this.opts.value.current
      ], ([r, i]) => {
        !r || !i || (this.opts.checked.current = r.includes(i));
      }), ac.pre(() => this.opts.checked.current, (r) => {
        this.group && (r ? this.group?.addValue(this.opts.value.current) : this.group?.removeValue(this.opts.value.current));
      });
    }
    onkeydown(e) {
      this.opts.disabled.current || (e.key === Ch && e.preventDefault(), e.key === Oh && (e.preventDefault(), this.#r()));
    }
    #r() {
      this.opts.indeterminate.current ? (this.opts.indeterminate.current = false, this.opts.checked.current = true) : this.opts.checked.current = !this.opts.checked.current;
    }
    onclick(e) {
      this.opts.disabled.current || this.#r();
    }
    #i = X(() => ({
      checked: this.opts.checked.current,
      indeterminate: this.opts.indeterminate.current
    }));
    get snippetProps() {
      return S(this.#i);
    }
    #s = X(() => ({
      id: this.opts.id.current,
      role: "checkbox",
      type: this.opts.type.current,
      disabled: this.trueDisabled,
      "aria-checked": Zm(this.opts.checked.current, this.opts.indeterminate.current),
      "aria-required": Qm(this.trueRequired),
      "data-disabled": Ah(this.trueDisabled),
      "data-state": Ig(this.opts.checked.current, this.opts.indeterminate.current),
      [Ng]: "",
      onclick: this.onclick,
      onkeydown: this.onkeydown
    }));
    get props() {
      return S(this.#s);
    }
  }
  class Dg {
    root;
    #e = X(() => this.root.group ? !!(this.root.opts.value.current !== void 0 && this.root.group.opts.value.current.includes(this.root.opts.value.current)) : this.root.opts.checked.current);
    get trueChecked() {
      return S(this.#e);
    }
    #t = X(() => !!this.root.trueName);
    get shouldRender() {
      return S(this.#t);
    }
    constructor(e) {
      this.root = e;
    }
    #n = X(() => ({
      type: "checkbox",
      checked: this.root.opts.checked.current === true,
      disabled: this.root.trueDisabled,
      required: this.root.trueRequired,
      name: this.root.trueName,
      value: this.root.opts.value.current
    }));
    get props() {
      return S(this.#n);
    }
  }
  function Ig(n, e) {
    return e ? "indeterminate" : n ? "checked" : "unchecked";
  }
  const Rg = new Vn("Checkbox.Group"), Dh = new Vn("Checkbox.Root");
  function _g(n, e) {
    return Dh.set(new Pg(n, e));
  }
  function Lg() {
    return new Dg(Dh.get());
  }
  function Bg(n, e) {
    Re(e, false);
    const t = Lg();
    $t();
    var r = se(), i = J(r);
    {
      var s = (o) => {
        yg(o, it(() => t.props));
      };
      be(i, (o) => {
        t.shouldRender && o(s);
      });
    }
    F(n, r), _e();
  }
  var Fg = ae("<button><!></button>"), zg = ae("<!> <!>", 1);
  function jg(n, e) {
    Re(e, true);
    let t = $(e, "checked", 15, false), r = $(e, "ref", 15, null), i = $(e, "disabled", 3, false), s = $(e, "required", 3, false), o = $(e, "name", 3, void 0), a = $(e, "value", 3, "on"), u = $(e, "id", 19, hn), l = $(e, "indeterminate", 15, false), c = $(e, "type", 3, "button"), h = wt(e, [
      "$$slots",
      "$$events",
      "$$legacy",
      "checked",
      "ref",
      "onCheckedChange",
      "children",
      "disabled",
      "required",
      "name",
      "value",
      "id",
      "indeterminate",
      "onIndeterminateChange",
      "child",
      "type"
    ]);
    const d = Rg.getOr(null);
    d && a() && (d.opts.value.current.includes(a()) ? t(true) : t(false));
    const f = _g({
      checked: Ne.with(() => t(), (y) => {
        t(y), e.onCheckedChange?.(y);
      }),
      disabled: Ne.with(() => i() ?? false),
      required: Ne.with(() => s()),
      name: Ne.with(() => o()),
      value: Ne.with(() => a()),
      id: Ne.with(() => u()),
      ref: Ne.with(() => r(), (y) => r(y)),
      indeterminate: Ne.with(() => l(), (y) => {
        l(y), e.onIndeterminateChange?.(y);
      }),
      type: Ne.with(() => c())
    }, d), p = X(() => vt({
      ...h
    }, f.props));
    var m = zg(), b = J(m);
    {
      var g = (y) => {
        var x = se(), k = J(x), T = cn(() => ({
          props: S(p),
          ...f.snippetProps
        }));
        rt(k, () => e.child, () => S(T)), F(y, x);
      }, w = (y) => {
        var x = Fg();
        let k;
        var T = Se(x);
        rt(T, () => e.children ?? pt, () => f.snippetProps), we(x), qe(() => k = Ge(x, k, {
          ...S(p)
        })), F(y, x);
      };
      be(b, (y) => {
        e.child ? y(g) : y(w, false);
      });
    }
    var v = je(b, 2);
    Bg(v, {}), F(n, m), _e();
  }
  class qg {
    opts;
    #e = Me(null);
    get contentNode() {
      return S(this.#e);
    }
    set contentNode(e) {
      te(this.#e, Be(e));
    }
    #t = Me(null);
    get triggerNode() {
      return S(this.#t);
    }
    set triggerNode(e) {
      te(this.#t, Be(e));
    }
    constructor(e) {
      this.opts = e;
    }
    toggleOpen() {
      this.opts.open.current = !this.opts.open.current;
    }
    handleClose() {
      this.opts.open.current && (this.opts.open.current = false);
    }
  }
  class $g {
    opts;
    root;
    constructor(e, t) {
      this.opts = e, this.root = t, Xt({
        ...e,
        onRefChange: (r) => {
          this.root.triggerNode = r;
        }
      }), this.onclick = this.onclick.bind(this), this.onkeydown = this.onkeydown.bind(this);
    }
    onclick(e) {
      this.opts.disabled.current || e.button === 0 && this.root.toggleOpen();
    }
    onkeydown(e) {
      this.opts.disabled.current || (e.key === Ch || e.key === Oh) && (e.preventDefault(), this.root.toggleOpen());
    }
    #e() {
      if (this.root.opts.open.current && this.root.contentNode?.id) return this.root.contentNode?.id;
    }
    #t = X(() => ({
      id: this.opts.id.current,
      "aria-haspopup": "dialog",
      "aria-expanded": eg(this.root.opts.open.current),
      "data-state": Mh(this.root.opts.open.current),
      "aria-controls": this.#e(),
      "data-popover-trigger": "",
      disabled: this.opts.disabled.current,
      onkeydown: this.onkeydown,
      onclick: this.onclick
    }));
    get props() {
      return S(this.#t);
    }
  }
  class Vg {
    opts;
    root;
    constructor(e, t) {
      this.opts = e, this.root = t, Xt({
        ...e,
        deps: () => this.root.opts.open.current,
        onRefChange: (r) => {
          this.root.contentNode = r;
        }
      });
    }
    onInteractOutside = (e) => {
      this.opts.onInteractOutside.current(e), !(e.defaultPrevented || !tg(e.target) || e.target.closest("[data-popover-trigger]") === this.root.triggerNode) && this.root.handleClose();
    };
    onEscapeKeydown = (e) => {
      this.opts.onEscapeKeydown.current(e), !e.defaultPrevented && this.root.handleClose();
    };
    onCloseAutoFocus = (e) => {
      this.opts.onCloseAutoFocus.current(e), !e.defaultPrevented && (e.preventDefault(), this.root.triggerNode?.focus());
    };
    #e = X(() => ({
      open: this.root.opts.open.current
    }));
    get snippetProps() {
      return S(this.#e);
    }
    #t = X(() => ({
      id: this.opts.id.current,
      tabindex: -1,
      "data-state": Mh(this.root.opts.open.current),
      "data-popover-content": "",
      style: {
        pointerEvents: "auto"
      }
    }));
    get props() {
      return S(this.#t);
    }
    popperProps = {
      onInteractOutside: this.onInteractOutside,
      onEscapeKeydown: this.onEscapeKeydown,
      onCloseAutoFocus: this.onCloseAutoFocus
    };
  }
  const ul = new Vn("Popover.Root");
  function Hg(n) {
    return ul.set(new qg(n));
  }
  function Wg(n) {
    return new $g(n, ul.get());
  }
  function Ug(n) {
    return new Vg(n, ul.get());
  }
  var Gg = ae("<div><div><!></div></div>"), Kg = ae("<div><div><!></div></div>");
  oa = function(n, e) {
    Re(e, true);
    let t = $(e, "ref", 15, null), r = $(e, "id", 19, hn), i = $(e, "forceMount", 3, false), s = $(e, "onCloseAutoFocus", 3, Bs), o = $(e, "onEscapeKeydown", 3, Bs), a = $(e, "onInteractOutside", 3, Bs), u = $(e, "trapFocus", 3, true), l = $(e, "preventScroll", 3, false), c = wt(e, [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "ref",
      "id",
      "forceMount",
      "onCloseAutoFocus",
      "onEscapeKeydown",
      "onInteractOutside",
      "trapFocus",
      "preventScroll"
    ]);
    const h = Ug({
      id: Ne.with(() => r()),
      ref: Ne.with(() => t(), (g) => t(g)),
      onInteractOutside: Ne.with(() => a()),
      onEscapeKeydown: Ne.with(() => o()),
      onCloseAutoFocus: Ne.with(() => s())
    }), d = X(() => vt(c, h.props));
    var f = se(), p = J(f);
    {
      var m = (g) => {
        vg(g, it(() => S(d), () => h.popperProps, {
          get enabled() {
            return h.root.opts.open.current;
          },
          get id() {
            return r();
          },
          get trapFocus() {
            return u();
          },
          get preventScroll() {
            return l();
          },
          loop: true,
          forceMount: true,
          popper: (v, y) => {
            let x = () => y?.().props, k = () => y?.().wrapperProps;
            var T = se();
            const M = X(() => vt(x(), {
              style: cc("popover")
            }));
            var D = J(T);
            {
              var I = (O) => {
                var E = se(), N = J(E), A = cn(() => ({
                  props: S(M),
                  wrapperProps: k(),
                  ...h.snippetProps
                }));
                rt(N, () => e.child, () => S(A)), F(O, E);
              }, C = (O) => {
                var E = Gg();
                let N;
                var A = Se(E);
                let R;
                var B = Se(A);
                rt(B, () => e.children ?? pt), we(A), we(E), qe(() => {
                  N = Ge(E, N, {
                    ...k()
                  }), R = Ge(A, R, {
                    ...S(M)
                  });
                }), F(O, E);
              };
              be(D, (O) => {
                e.child ? O(I) : O(C, false);
              });
            }
            F(v, T);
          },
          $$slots: {
            popper: true
          }
        }));
      }, b = (g, w) => {
        {
          var v = (y) => {
            wg(y, it(() => S(d), () => h.popperProps, {
              get present() {
                return h.root.opts.open.current;
              },
              get id() {
                return r();
              },
              get trapFocus() {
                return u();
              },
              get preventScroll() {
                return l();
              },
              loop: true,
              forceMount: false,
              popper: (k, T) => {
                let M = () => T?.().props, D = () => T?.().wrapperProps;
                var I = se();
                const C = X(() => vt(M(), {
                  style: cc("popover")
                }));
                var O = J(I);
                {
                  var E = (A) => {
                    var R = se(), B = J(R), z = cn(() => ({
                      props: S(C),
                      wrapperProps: D(),
                      ...h.snippetProps
                    }));
                    rt(B, () => e.child, () => S(z)), F(A, R);
                  }, N = (A) => {
                    var R = Kg();
                    let B;
                    var z = Se(R);
                    let L;
                    var V = Se(z);
                    rt(V, () => e.children ?? pt), we(z), we(R), qe(() => {
                      B = Ge(R, B, {
                        ...D()
                      }), L = Ge(z, L, {
                        ...S(C)
                      });
                    }), F(A, R);
                  };
                  be(O, (A) => {
                    e.child ? A(E) : A(N, false);
                  });
                }
                F(k, I);
              },
              $$slots: {
                popper: true
              }
            }));
          };
          be(g, (y) => {
            i() || y(v);
          }, w);
        }
      };
      be(p, (g) => {
        i() ? g(m) : g(b, false);
      });
    }
    F(n, f), _e();
  };
  var Jg = ae("<button><!></button>");
  aa = function(n, e) {
    Re(e, true);
    let t = $(e, "id", 19, hn), r = $(e, "ref", 15, null), i = $(e, "type", 3, "button"), s = $(e, "disabled", 3, false), o = wt(e, [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "type",
      "disabled"
    ]);
    const a = Wg({
      id: Ne.with(() => t()),
      ref: Ne.with(() => r(), (l) => r(l)),
      disabled: Ne.with(() => !!s())
    }), u = X(() => vt(o, a.props, {
      type: i()
    }));
    xg(n, {
      get id() {
        return t();
      },
      children: (l, c) => {
        var h = se(), d = J(h);
        {
          var f = (m) => {
            var b = se(), g = J(b);
            rt(g, () => e.child, () => ({
              props: S(u)
            })), F(m, b);
          }, p = (m) => {
            var b = Jg();
            let g;
            var w = Se(b);
            rt(w, () => e.children ?? pt), we(b), qe(() => g = Ge(b, g, {
              ...S(u)
            })), F(m, b);
          };
          be(d, (m) => {
            e.child ? m(f) : m(p, false);
          });
        }
        F(l, h);
      },
      $$slots: {
        default: true
      }
    }), _e();
  };
  function oi(n, e) {
    at(() => {
      let t = 0;
      const r = n();
      if (!r) return;
      const i = new ResizeObserver(() => {
        cancelAnimationFrame(t), t = window.requestAnimationFrame(e);
      });
      return i.observe(r), () => {
        window.cancelAnimationFrame(t), i.unobserve(r);
      };
    });
  }
  ua = function(n, e) {
    Re(e, true);
    let t = $(e, "open", 15, false), r = $(e, "onOpenChange", 3, Bs);
    Hg({
      open: Ne.with(() => t(), (i) => {
        t(i), r()(i);
      })
    }), kg(n, {
      children: (i, s) => {
        var o = se(), a = J(o);
        rt(a, () => e.children ?? pt), F(i, o);
      },
      $$slots: {
        default: true
      }
    }), _e();
  };
  function Yg(n, e, t) {
    return Math.min(t, Math.max(e, n));
  }
  const Xg = "data-scroll-area-root", Qg = "data-scroll-area-viewport", Zg = "data-scroll-area-corner", eb = "data-scroll-area-thumb", tb = "data-scroll-area-scrollbar";
  class nb {
    opts;
    #e = Me(null);
    get scrollAreaNode() {
      return S(this.#e);
    }
    set scrollAreaNode(e) {
      te(this.#e, Be(e));
    }
    #t = Me(null);
    get viewportNode() {
      return S(this.#t);
    }
    set viewportNode(e) {
      te(this.#t, Be(e));
    }
    #n = Me(null);
    get contentNode() {
      return S(this.#n);
    }
    set contentNode(e) {
      te(this.#n, Be(e));
    }
    #r = Me(null);
    get scrollbarXNode() {
      return S(this.#r);
    }
    set scrollbarXNode(e) {
      te(this.#r, Be(e));
    }
    #i = Me(null);
    get scrollbarYNode() {
      return S(this.#i);
    }
    set scrollbarYNode(e) {
      te(this.#i, Be(e));
    }
    #s = Me(0);
    get cornerWidth() {
      return S(this.#s);
    }
    set cornerWidth(e) {
      te(this.#s, Be(e));
    }
    #o = Me(0);
    get cornerHeight() {
      return S(this.#o);
    }
    set cornerHeight(e) {
      te(this.#o, Be(e));
    }
    #a = Me(false);
    get scrollbarXEnabled() {
      return S(this.#a);
    }
    set scrollbarXEnabled(e) {
      te(this.#a, Be(e));
    }
    #u = Me(false);
    get scrollbarYEnabled() {
      return S(this.#u);
    }
    set scrollbarYEnabled(e) {
      te(this.#u, Be(e));
    }
    constructor(e) {
      this.opts = e, Xt({
        ...e,
        onRefChange: (t) => {
          this.scrollAreaNode = t;
        }
      });
    }
    #l = X(() => ({
      id: this.opts.id.current,
      dir: this.opts.dir.current,
      style: {
        position: "relative",
        "--bits-scroll-area-corner-height": `${this.cornerHeight}px`,
        "--bits-scroll-area-corner-width": `${this.cornerWidth}px`
      },
      [Xg]: ""
    }));
    get props() {
      return S(this.#l);
    }
  }
  class rb {
    opts;
    root;
    #e = Ne(hn());
    #t = Ne(null);
    constructor(e, t) {
      this.opts = e, this.root = t, Xt({
        ...e,
        onRefChange: (r) => {
          this.root.viewportNode = r;
        }
      }), Xt({
        id: this.#e,
        ref: this.#t,
        onRefChange: (r) => {
          this.root.contentNode = r;
        }
      });
    }
    #n = X(() => ({
      id: this.opts.id.current,
      style: {
        overflowX: this.root.scrollbarXEnabled ? "scroll" : "hidden",
        overflowY: this.root.scrollbarYEnabled ? "scroll" : "hidden"
      },
      [Qg]: ""
    }));
    get props() {
      return S(this.#n);
    }
    #r = X(() => ({
      id: this.#e.current,
      "data-scroll-area-content": "",
      style: {
        minWidth: this.root.scrollbarXEnabled ? "fit-content" : void 0
      }
    }));
    get contentProps() {
      return S(this.#r);
    }
  }
  class ib {
    opts;
    root;
    #e = X(() => this.opts.orientation.current === "horizontal");
    get isHorizontal() {
      return S(this.#e);
    }
    #t = Me(false);
    get hasThumb() {
      return S(this.#t);
    }
    set hasThumb(e) {
      te(this.#t, Be(e));
    }
    constructor(e, t) {
      this.opts = e, this.root = t, at(() => (this.isHorizontal ? this.root.scrollbarXEnabled = true : this.root.scrollbarYEnabled = true, () => {
        this.isHorizontal ? this.root.scrollbarXEnabled = false : this.root.scrollbarYEnabled = false;
      }));
    }
  }
  class sb {
    scrollbar;
    root;
    #e = Me(false);
    get isVisible() {
      return S(this.#e);
    }
    set isVisible(e) {
      te(this.#e, Be(e));
    }
    constructor(e) {
      this.scrollbar = e, this.root = e.root, at(() => {
        const t = this.root.scrollAreaNode, r = this.root.opts.scrollHideDelay.current;
        let i = 0;
        if (!t) return;
        const s = () => {
          window.clearTimeout(i), Br(() => this.isVisible = true);
        }, o = () => {
          i && window.clearTimeout(i), i = window.setTimeout(() => {
            Br(() => {
              this.scrollbar.hasThumb = false, this.isVisible = false;
            });
          }, r);
        }, a = ng(uc(t, "pointerenter", s), uc(t, "pointerleave", o));
        return () => {
          window.clearTimeout(i), a();
        };
      });
    }
    #t = X(() => ({
      "data-state": this.isVisible ? "visible" : "hidden"
    }));
    get props() {
      return S(this.#t);
    }
  }
  class ob {
    scrollbar;
    root;
    machine = rg("hidden", {
      hidden: {
        SCROLL: "scrolling"
      },
      scrolling: {
        SCROLL_END: "idle",
        POINTER_ENTER: "interacting"
      },
      interacting: {
        SCROLL: "interacting",
        POINTER_LEAVE: "idle"
      },
      idle: {
        HIDE: "hidden",
        SCROLL: "scrolling",
        POINTER_ENTER: "interacting"
      }
    });
    #e = X(() => this.machine.state.current === "hidden");
    get isHidden() {
      return S(this.#e);
    }
    constructor(e) {
      this.scrollbar = e, this.root = e.root;
      const t = Mo(() => this.machine.dispatch("SCROLL_END"), 100);
      at(() => {
        const r = this.machine.state.current, i = this.root.opts.scrollHideDelay.current;
        if (r === "idle") {
          const s = window.setTimeout(() => this.machine.dispatch("HIDE"), i);
          return () => window.clearTimeout(s);
        }
      }), at(() => {
        const r = this.root.viewportNode;
        if (!r) return;
        const i = this.scrollbar.isHorizontal ? "scrollLeft" : "scrollTop";
        let s = r[i];
        return sl(r, "scroll", () => {
          const u = r[i];
          s !== u && (this.machine.dispatch("SCROLL"), t()), s = u;
        });
      }), this.onpointerenter = this.onpointerenter.bind(this), this.onpointerleave = this.onpointerleave.bind(this);
    }
    onpointerenter(e) {
      this.machine.dispatch("POINTER_ENTER");
    }
    onpointerleave(e) {
      this.machine.dispatch("POINTER_LEAVE");
    }
    #t = X(() => ({
      "data-state": this.machine.state.current === "hidden" ? "hidden" : "visible",
      onpointerenter: this.onpointerenter,
      onpointerleave: this.onpointerleave
    }));
    get props() {
      return S(this.#t);
    }
  }
  class ab {
    scrollbar;
    root;
    #e = Me(false);
    get isVisible() {
      return S(this.#e);
    }
    set isVisible(e) {
      te(this.#e, Be(e));
    }
    constructor(e) {
      this.scrollbar = e, this.root = e.root;
      const t = Mo(() => {
        const r = this.root.viewportNode;
        if (!r) return;
        const i = r.offsetWidth < r.scrollWidth, s = r.offsetHeight < r.scrollHeight;
        this.isVisible = this.scrollbar.isHorizontal ? i : s;
      }, 10);
      oi(() => this.root.viewportNode, t), oi(() => this.root.contentNode, t);
    }
    #t = X(() => ({
      "data-state": this.isVisible ? "visible" : "hidden"
    }));
    get props() {
      return S(this.#t);
    }
  }
  class ub {
    scrollbar;
    root;
    #e = Me(null);
    get thumbNode() {
      return S(this.#e);
    }
    set thumbNode(e) {
      te(this.#e, Be(e));
    }
    #t = Me(0);
    get pointerOffset() {
      return S(this.#t);
    }
    set pointerOffset(e) {
      te(this.#t, Be(e));
    }
    #n = Me({
      content: 0,
      viewport: 0,
      scrollbar: {
        size: 0,
        paddingStart: 0,
        paddingEnd: 0
      }
    });
    get sizes() {
      return S(this.#n);
    }
    set sizes(e) {
      te(this.#n, e);
    }
    #r = X(() => _h(this.sizes.viewport, this.sizes.content));
    get thumbRatio() {
      return S(this.#r);
    }
    #i = X(() => this.thumbRatio > 0 && this.thumbRatio < 1);
    get hasThumb() {
      return S(this.#i);
    }
    prevTransformStyle = "";
    constructor(e) {
      this.scrollbar = e, this.root = e.root, at(() => {
        this.scrollbar.hasThumb = this.hasThumb;
      }), Eu(() => {
        !this.scrollbar.hasThumb && this.thumbNode && (this.prevTransformStyle = this.thumbNode.style.transform);
      });
    }
    setSizes(e) {
      this.sizes = e;
    }
    getScrollPosition(e, t) {
      return Eb({
        pointerPos: e,
        pointerOffset: this.pointerOffset,
        sizes: this.sizes,
        dir: t
      });
    }
    onThumbPointerUp() {
      this.pointerOffset = 0;
    }
    onThumbPointerDown(e) {
      this.pointerOffset = e;
    }
    xOnThumbPositionChange() {
      if (!(this.root.viewportNode && this.thumbNode)) return;
      const e = this.root.viewportNode.scrollLeft, r = `translate3d(${fc({
        scrollPos: e,
        sizes: this.sizes,
        dir: this.root.opts.dir.current
      })}px, 0, 0)`;
      this.thumbNode.style.transform = r;
    }
    xOnWheelScroll(e) {
      this.root.viewportNode && (this.root.viewportNode.scrollLeft = e);
    }
    xOnDragScroll(e) {
      this.root.viewportNode && (this.root.viewportNode.scrollLeft = this.getScrollPosition(e, this.root.opts.dir.current));
    }
    yOnThumbPositionChange() {
      if (!(this.root.viewportNode && this.thumbNode)) return;
      const e = this.root.viewportNode.scrollTop, r = `translate3d(0, ${fc({
        scrollPos: e,
        sizes: this.sizes
      })}px, 0)`;
      this.thumbNode.style.transform = r;
    }
    yOnWheelScroll(e) {
      this.root.viewportNode && (this.root.viewportNode.scrollTop = e);
    }
    yOnDragScroll(e) {
      this.root.viewportNode && (this.root.viewportNode.scrollTop = this.getScrollPosition(e, this.root.opts.dir.current));
    }
  }
  class lb {
    opts;
    scrollbarVis;
    root;
    #e = Me();
    get computedStyle() {
      return S(this.#e);
    }
    set computedStyle(e) {
      te(this.#e, Be(e));
    }
    scrollbar;
    constructor(e, t) {
      this.opts = e, this.scrollbarVis = t, this.scrollbarVis = t, this.root = t.root, this.scrollbar = t.scrollbar, Xt({
        ...this.scrollbar.opts,
        onRefChange: (r) => {
          this.root.scrollbarXNode = r;
        },
        deps: () => this.opts.mounted.current
      }), at(() => {
        this.scrollbar.opts.ref.current && this.opts.mounted.current && (this.computedStyle = getComputedStyle(this.scrollbar.opts.ref.current));
      }), at(() => {
        this.onResize();
      });
    }
    onThumbPointerDown = (e) => {
      this.scrollbarVis.onThumbPointerDown(e.x);
    };
    onDragScroll = (e) => {
      this.scrollbarVis.xOnDragScroll(e.x);
    };
    onThumbPointerUp = () => {
      this.scrollbarVis.onThumbPointerUp();
    };
    onThumbPositionChange = () => {
      this.scrollbarVis.xOnThumbPositionChange();
    };
    onWheelScroll = (e, t) => {
      if (!this.root.viewportNode) return;
      const r = this.root.viewportNode.scrollLeft + e.deltaX;
      this.scrollbarVis.xOnWheelScroll(r), Bh(r, t) && e.preventDefault();
    };
    onResize = () => {
      this.scrollbar.opts.ref.current && this.root.viewportNode && this.computedStyle && this.scrollbarVis.setSizes({
        content: this.root.viewportNode.scrollWidth,
        viewport: this.root.viewportNode.offsetWidth,
        scrollbar: {
          size: this.scrollbar.opts.ref.current.clientWidth,
          paddingStart: Ys(this.computedStyle.paddingLeft),
          paddingEnd: Ys(this.computedStyle.paddingRight)
        }
      });
    };
    #t = X(() => Po(this.scrollbarVis.sizes));
    get thumbSize() {
      return S(this.#t);
    }
    #n = X(() => ({
      id: this.scrollbar.opts.id.current,
      "data-orientation": "horizontal",
      style: {
        bottom: 0,
        left: this.root.opts.dir.current === "rtl" ? "var(--bits-scroll-area-corner-width)" : 0,
        right: this.root.opts.dir.current === "ltr" ? "var(--bits-scroll-area-corner-width)" : 0,
        "--bits-scroll-area-thumb-width": `${this.thumbSize}px`
      }
    }));
    get props() {
      return S(this.#n);
    }
  }
  class cb {
    opts;
    scrollbarVis;
    root;
    scrollbar;
    #e = Me();
    get computedStyle() {
      return S(this.#e);
    }
    set computedStyle(e) {
      te(this.#e, Be(e));
    }
    constructor(e, t) {
      this.opts = e, this.scrollbarVis = t, this.root = t.root, this.scrollbar = t.scrollbar, Xt({
        ...this.scrollbar.opts,
        onRefChange: (r) => {
          this.root.scrollbarYNode = r;
        },
        deps: () => this.opts.mounted.current
      }), at(() => {
        this.scrollbar.opts.ref.current && this.opts.mounted.current && (this.computedStyle = getComputedStyle(this.scrollbar.opts.ref.current));
      }), at(() => {
        this.onResize();
      }), this.onThumbPointerDown = this.onThumbPointerDown.bind(this), this.onDragScroll = this.onDragScroll.bind(this), this.onThumbPointerUp = this.onThumbPointerUp.bind(this), this.onThumbPositionChange = this.onThumbPositionChange.bind(this), this.onWheelScroll = this.onWheelScroll.bind(this), this.onResize = this.onResize.bind(this);
    }
    onThumbPointerDown(e) {
      this.scrollbarVis.onThumbPointerDown(e.y);
    }
    onDragScroll(e) {
      this.scrollbarVis.yOnDragScroll(e.y);
    }
    onThumbPointerUp() {
      this.scrollbarVis.onThumbPointerUp();
    }
    onThumbPositionChange() {
      this.scrollbarVis.yOnThumbPositionChange();
    }
    onWheelScroll(e, t) {
      if (!this.root.viewportNode) return;
      const r = this.root.viewportNode.scrollTop + e.deltaY;
      this.scrollbarVis.yOnWheelScroll(r), Bh(r, t) && e.preventDefault();
    }
    onResize() {
      this.scrollbar.opts.ref.current && this.root.viewportNode && this.computedStyle && this.scrollbarVis.setSizes({
        content: this.root.viewportNode.scrollHeight,
        viewport: this.root.viewportNode.offsetHeight,
        scrollbar: {
          size: this.scrollbar.opts.ref.current.clientHeight,
          paddingStart: Ys(this.computedStyle.paddingTop),
          paddingEnd: Ys(this.computedStyle.paddingBottom)
        }
      });
    }
    #t = X(() => Po(this.scrollbarVis.sizes));
    get thumbSize() {
      return S(this.#t);
    }
    #n = X(() => ({
      id: this.scrollbar.opts.id.current,
      "data-orientation": "vertical",
      style: {
        top: 0,
        right: this.root.opts.dir.current === "ltr" ? 0 : void 0,
        left: this.root.opts.dir.current === "rtl" ? 0 : void 0,
        bottom: "var(--bits-scroll-area-corner-height)",
        "--bits-scroll-area-thumb-height": `${this.thumbSize}px`
      }
    }));
    get props() {
      return S(this.#n);
    }
  }
  class db {
    scrollbarState;
    root;
    scrollbarVis;
    scrollbar;
    #e = Me(null);
    get rect() {
      return S(this.#e);
    }
    set rect(e) {
      te(this.#e, e);
    }
    #t = Me("");
    get prevWebkitUserSelect() {
      return S(this.#t);
    }
    set prevWebkitUserSelect(e) {
      te(this.#t, Be(e));
    }
    handleResize;
    handleThumbPositionChange;
    handleWheelScroll;
    handleThumbPointerDown;
    handleThumbPointerUp;
    #n = X(() => this.scrollbarVis.sizes.content - this.scrollbarVis.sizes.viewport);
    get maxScrollPos() {
      return S(this.#n);
    }
    constructor(e) {
      this.scrollbarState = e, this.root = e.root, this.scrollbarVis = e.scrollbarVis, this.scrollbar = e.scrollbarVis.scrollbar, this.handleResize = Mo(() => this.scrollbarState.onResize(), 10), this.handleThumbPositionChange = this.scrollbarState.onThumbPositionChange, this.handleWheelScroll = this.scrollbarState.onWheelScroll, this.handleThumbPointerDown = this.scrollbarState.onThumbPointerDown, this.handleThumbPointerUp = this.scrollbarState.onThumbPointerUp, at(() => {
        const t = this.maxScrollPos, r = this.scrollbar.opts.ref.current;
        return this.root.viewportNode, sl(document, "wheel", (o) => {
          const a = o.target;
          r?.contains(a) && this.handleWheelScroll(o, t);
        }, {
          passive: false
        });
      }), at(() => {
        this.scrollbarVis.sizes, Br(() => this.handleThumbPositionChange());
      }), at(() => {
        this.handleThumbPositionChange();
      }), oi(() => this.scrollbar.opts.ref.current, this.handleResize), oi(() => this.root.contentNode, this.handleResize), this.onpointerdown = this.onpointerdown.bind(this), this.onpointermove = this.onpointermove.bind(this), this.onpointerup = this.onpointerup.bind(this);
    }
    handleDragScroll(e) {
      if (!this.rect) return;
      const t = e.clientX - this.rect.left, r = e.clientY - this.rect.top;
      this.scrollbarState.onDragScroll({
        x: t,
        y: r
      });
    }
    onpointerdown(e) {
      if (e.button !== 0) return;
      e.target.setPointerCapture(e.pointerId), this.rect = this.scrollbar.opts.ref.current?.getBoundingClientRect() ?? null, this.prevWebkitUserSelect = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", this.root.viewportNode && (this.root.viewportNode.style.scrollBehavior = "auto"), this.handleDragScroll(e);
    }
    onpointermove(e) {
      this.handleDragScroll(e);
    }
    onpointerup(e) {
      const t = e.target;
      t.hasPointerCapture(e.pointerId) && t.releasePointerCapture(e.pointerId), document.body.style.webkitUserSelect = this.prevWebkitUserSelect, this.root.viewportNode && (this.root.viewportNode.style.scrollBehavior = ""), this.rect = null;
    }
    #r = X(() => vt({
      ...this.scrollbarState.props,
      style: {
        position: "absolute",
        ...this.scrollbarState.props.style
      },
      [tb]: "",
      onpointerdown: this.onpointerdown,
      onpointermove: this.onpointermove,
      onpointerup: this.onpointerup
    }));
    get props() {
      return S(this.#r);
    }
  }
  class fb {
    opts;
    scrollbarState;
    #e;
    #t = Me();
    #n = Mo(() => {
      S(this.#t) && (S(this.#t)(), te(this.#t, void 0));
    }, 100);
    constructor(e, t) {
      this.opts = e, this.scrollbarState = t, this.#e = t.root, Xt({
        ...e,
        onRefChange: (r) => {
          this.scrollbarState.scrollbarVis.thumbNode = r;
        },
        deps: () => this.opts.mounted.current
      }), at(() => {
        const r = this.#e.viewportNode;
        if (!r) return;
        const i = () => {
          if (this.#n(), !S(this.#t)) {
            const o = Cb(r, this.scrollbarState.handleThumbPositionChange);
            te(this.#t, Be(o)), this.scrollbarState.handleThumbPositionChange();
          }
        };
        return this.scrollbarState.handleThumbPositionChange(), sl(r, "scroll", i);
      }), this.onpointerdowncapture = this.onpointerdowncapture.bind(this), this.onpointerup = this.onpointerup.bind(this);
    }
    onpointerdowncapture(e) {
      const t = e.target;
      if (!t) return;
      const r = t.getBoundingClientRect(), i = e.clientX - r.left, s = e.clientY - r.top;
      this.scrollbarState.handleThumbPointerDown({
        x: i,
        y: s
      });
    }
    onpointerup(e) {
      this.scrollbarState.handleThumbPointerUp();
    }
    #r = X(() => ({
      id: this.opts.id.current,
      "data-state": this.scrollbarState.scrollbarVis.hasThumb ? "visible" : "hidden",
      style: {
        width: "var(--bits-scroll-area-thumb-width)",
        height: "var(--bits-scroll-area-thumb-height)",
        transform: this.scrollbarState.scrollbarVis.prevTransformStyle
      },
      onpointerdowncapture: this.onpointerdowncapture,
      onpointerup: this.onpointerup,
      [eb]: ""
    }));
    get props() {
      return S(this.#r);
    }
  }
  class hb {
    opts;
    root;
    #e = Me(0);
    #t = Me(0);
    #n = X(() => !!(S(this.#e) && S(this.#t)));
    get hasSize() {
      return S(this.#n);
    }
    constructor(e, t) {
      this.opts = e, this.root = t, oi(() => this.root.scrollbarXNode, () => {
        const r = this.root.scrollbarXNode?.offsetHeight || 0;
        this.root.cornerHeight = r, te(this.#t, Be(r));
      }), oi(() => this.root.scrollbarYNode, () => {
        const r = this.root.scrollbarYNode?.offsetWidth || 0;
        this.root.cornerWidth = r, te(this.#e, Be(r));
      }), Xt(e);
    }
    #r = X(() => ({
      id: this.opts.id.current,
      style: {
        width: S(this.#e),
        height: S(this.#t),
        position: "absolute",
        right: this.root.opts.dir.current === "ltr" ? 0 : void 0,
        left: this.root.opts.dir.current === "rtl" ? 0 : void 0,
        bottom: 0
      },
      [Zg]: ""
    }));
    get props() {
      return S(this.#r);
    }
  }
  const Qi = new Vn("ScrollArea.Root"), Zi = new Vn("ScrollArea.Scrollbar"), No = new Vn("ScrollArea.ScrollbarVisible"), ll = new Vn("ScrollArea.ScrollbarAxis"), Ih = new Vn("ScrollArea.ScrollbarShared");
  function pb(n) {
    return Qi.set(new nb(n));
  }
  function mb(n) {
    return new rb(n, Qi.get());
  }
  function gb(n) {
    return Zi.set(new ib(n, Qi.get()));
  }
  function bb() {
    return No.set(new ub(Zi.get()));
  }
  function Rh() {
    return new ab(Zi.get());
  }
  function yb() {
    return new ob(Zi.get());
  }
  function vb() {
    return new sb(Zi.get());
  }
  function wb(n) {
    return ll.set(new lb(n, No.get()));
  }
  function xb(n) {
    return ll.set(new cb(n, No.get()));
  }
  function kb() {
    return Ih.set(new db(ll.get()));
  }
  function Sb(n) {
    return new fb(n, Ih.get());
  }
  function Tb(n) {
    return new hb(n, Qi.get());
  }
  function Ys(n) {
    return n ? Number.parseInt(n, 10) : 0;
  }
  function _h(n, e) {
    const t = n / e;
    return Number.isNaN(t) ? 0 : t;
  }
  function Po(n) {
    const e = _h(n.viewport, n.content), t = n.scrollbar.paddingStart + n.scrollbar.paddingEnd, r = (n.scrollbar.size - t) * e;
    return Math.max(r, 18);
  }
  function Eb({ pointerPos: n, pointerOffset: e, sizes: t, dir: r = "ltr" }) {
    const i = Po(t), s = i / 2, o = e || s, a = i - o, u = t.scrollbar.paddingStart + o, l = t.scrollbar.size - t.scrollbar.paddingEnd - a, c = t.content - t.viewport, h = r === "ltr" ? [
      0,
      c
    ] : [
      c * -1,
      0
    ];
    return Lh([
      u,
      l
    ], h)(n);
  }
  function fc({ scrollPos: n, sizes: e, dir: t = "ltr" }) {
    const r = Po(e), i = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, s = e.scrollbar.size - i, o = e.content - e.viewport, a = s - r, u = t === "ltr" ? [
      0,
      o
    ] : [
      o * -1,
      0
    ], l = Yg(n, u[0], u[1]);
    return Lh([
      0,
      o
    ], [
      0,
      a
    ])(l);
  }
  function Lh(n, e) {
    return (t) => {
      if (n[0] === n[1] || e[0] === e[1]) return e[0];
      const r = (e[1] - e[0]) / (n[1] - n[0]);
      return e[0] + r * (t - n[0]);
    };
  }
  function Bh(n, e) {
    return n > 0 && n < e;
  }
  function Cb(n, e) {
    let t = {
      left: n.scrollLeft,
      top: n.scrollTop
    }, r = 0;
    return function i() {
      const s = {
        left: n.scrollLeft,
        top: n.scrollTop
      }, o = t.left !== s.left, a = t.top !== s.top;
      (o || a) && e(), t = s, r = window.requestAnimationFrame(i);
    }(), () => window.cancelAnimationFrame(r);
  }
  var Ob = ae("<div><!></div>");
  function Ab(n, e) {
    Re(e, true);
    let t = $(e, "ref", 15, null), r = $(e, "id", 19, hn), i = $(e, "type", 3, "hover"), s = $(e, "dir", 3, "ltr"), o = $(e, "scrollHideDelay", 3, 600), a = wt(e, [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "type",
      "dir",
      "scrollHideDelay",
      "children",
      "child"
    ]);
    const u = pb({
      type: Ne.with(() => i()),
      dir: Ne.with(() => s()),
      scrollHideDelay: Ne.with(() => o()),
      id: Ne.with(() => r()),
      ref: Ne.with(() => t(), (p) => t(p))
    }), l = X(() => vt(a, u.props));
    var c = se(), h = J(c);
    {
      var d = (p) => {
        var m = se(), b = J(m);
        rt(b, () => e.child, () => ({
          props: S(l)
        })), F(p, m);
      }, f = (p) => {
        var m = Ob();
        let b;
        var g = Se(m);
        rt(g, () => e.children ?? pt), we(m), qe(() => b = Ge(m, b, {
          ...S(l)
        })), F(p, m);
      };
      be(h, (p) => {
        e.child ? p(d) : p(f, false);
      });
    }
    F(n, c), _e();
  }
  var Mb = ae("<div><div><!></div></div>");
  function Nb(n, e) {
    Re(e, true);
    let t = $(e, "ref", 15, null), r = $(e, "id", 19, hn), i = wt(e, [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "children"
    ]);
    const s = mb({
      id: Ne.with(() => r()),
      ref: Ne.with(() => t(), (f) => t(f))
    }), o = X(() => vt(i, s.props)), a = X(() => vt({}, s.contentProps));
    var u = Mb();
    let l;
    var c = Se(u);
    let h;
    var d = Se(c);
    rt(d, () => e.children ?? pt), we(c), we(u), qe(() => {
      l = Ge(u, l, {
        ...S(o)
      }), h = Ge(c, h, {
        ...S(a)
      });
    }), F(n, u), _e();
  }
  var Pb = ae("<div><!></div>");
  function Fh(n, e) {
    Re(e, true);
    let t = wt(e, [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children"
    ]);
    const r = kb(), i = X(() => vt(t, r.props));
    var s = se(), o = J(s);
    {
      var a = (l) => {
        var c = se(), h = J(c);
        rt(h, () => e.child, () => ({
          props: S(i)
        })), F(l, c);
      }, u = (l) => {
        var c = Pb();
        let h;
        var d = Se(c);
        rt(d, () => e.children ?? pt), we(c), qe(() => h = Ge(c, h, {
          ...S(i)
        })), F(l, c);
      };
      be(o, (l) => {
        e.child ? l(a) : l(u, false);
      });
    }
    F(n, s), _e();
  }
  function Db(n, e) {
    Re(e, true);
    let t = wt(e, [
      "$$slots",
      "$$events",
      "$$legacy"
    ]);
    const r = new al(), i = wb({
      mounted: Ne.with(() => r.current)
    }), s = X(() => vt(t, i.props));
    Fh(n, it(() => S(s))), _e();
  }
  function Ib(n, e) {
    Re(e, true);
    let t = wt(e, [
      "$$slots",
      "$$events",
      "$$legacy"
    ]);
    const r = new al(), i = xb({
      mounted: Ne.with(() => r.current)
    }), s = X(() => vt(t, i.props));
    Fh(n, it(() => S(s))), _e();
  }
  function Do(n, e) {
    Re(e, true);
    let t = wt(e, [
      "$$slots",
      "$$events",
      "$$legacy"
    ]);
    const r = bb();
    var i = se(), s = J(i);
    {
      var o = (u) => {
        Db(u, it(() => t));
      }, a = (u) => {
        Ib(u, it(() => t));
      };
      be(s, (u) => {
        r.scrollbar.opts.orientation.current === "horizontal" ? u(o) : u(a, false);
      });
    }
    F(n, i), _e();
  }
  function Rb(n, e) {
    Re(e, true);
    let t = $(e, "forceMount", 3, false), r = wt(e, [
      "$$slots",
      "$$events",
      "$$legacy",
      "forceMount"
    ]);
    const i = Rh(), s = X(() => vt(r, i.props)), o = X(() => t() || i.isVisible);
    Oo(n, it({
      get present() {
        return S(o);
      }
    }, () => S(s), {
      presence: (u) => {
        Do(u, it(() => S(s)));
      },
      $$slots: {
        presence: true
      }
    })), _e();
  }
  function _b(n, e) {
    Re(e, true);
    let t = $(e, "forceMount", 3, false), r = wt(e, [
      "$$slots",
      "$$events",
      "$$legacy",
      "forceMount"
    ]);
    const i = yb(), s = X(() => vt(r, i.props)), o = X(() => t() || !i.isHidden);
    Oo(n, it(() => S(s), {
      get present() {
        return S(o);
      },
      presence: (u) => {
        Do(u, it(() => S(s)));
      },
      $$slots: {
        presence: true
      }
    })), _e();
  }
  function Lb(n, e) {
    Re(e, true);
    let t = $(e, "forceMount", 3, false), r = wt(e, [
      "$$slots",
      "$$events",
      "$$legacy",
      "forceMount"
    ]);
    const i = vb(), s = Rh(), o = X(() => vt(r, i.props, s.props, {
      "data-state": i.isVisible ? "visible" : "hidden"
    })), a = X(() => t() || i.isVisible && s.isVisible);
    Oo(n, it(() => S(o), {
      get present() {
        return S(a);
      },
      presence: (l) => {
        Do(l, it(() => S(o)));
      },
      $$slots: {
        presence: true
      }
    })), _e();
  }
  function Bb(n, e) {
    Re(e, true);
    let t = $(e, "ref", 15, null), r = $(e, "id", 19, hn), i = wt(e, [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "orientation"
    ]);
    const s = gb({
      orientation: Ne.with(() => e.orientation),
      id: Ne.with(() => r()),
      ref: Ne.with(() => t(), (h) => t(h))
    }), o = X(() => s.root.opts.type.current);
    var a = se(), u = J(a);
    {
      var l = (h) => {
        Lb(h, it(() => i, {
          get id() {
            return r();
          }
        }));
      }, c = (h, d) => {
        {
          var f = (m) => {
            _b(m, it(() => i, {
              get id() {
                return r();
              }
            }));
          }, p = (m, b) => {
            {
              var g = (v) => {
                Rb(v, it(() => i, {
                  get id() {
                    return r();
                  }
                }));
              }, w = (v, y) => {
                {
                  var x = (k) => {
                    Do(k, it(() => i, {
                      get id() {
                        return r();
                      }
                    }));
                  };
                  be(v, (k) => {
                    S(o) === "always" && k(x);
                  }, y);
                }
              };
              be(m, (v) => {
                S(o) === "auto" ? v(g) : v(w, false);
              }, b);
            }
          };
          be(h, (m) => {
            S(o) === "scroll" ? m(f) : m(p, false);
          }, d);
        }
      };
      be(u, (h) => {
        S(o) === "hover" ? h(l) : h(c, false);
      });
    }
    F(n, a), _e();
  }
  var Fb = ae("<div><!></div>");
  function zb(n, e) {
    Re(e, true);
    let t = $(e, "ref", 15, null), r = wt(e, [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "child",
      "children",
      "present"
    ]);
    const i = new al(), s = Sb({
      id: Ne.with(() => e.id),
      ref: Ne.with(() => t(), (h) => t(h)),
      mounted: Ne.with(() => i.current)
    }), o = X(() => vt(r, s.props, {
      style: {
        hidden: !e.present
      }
    }));
    var a = se(), u = J(a);
    {
      var l = (h) => {
        var d = se(), f = J(d);
        rt(f, () => e.child, () => ({
          props: S(o)
        })), F(h, d);
      }, c = (h) => {
        var d = Fb();
        let f;
        var p = Se(d);
        rt(p, () => e.children ?? pt), we(d), qe(() => f = Ge(d, f, {
          ...S(o)
        })), F(h, d);
      };
      be(u, (h) => {
        e.child ? h(l) : h(c, false);
      });
    }
    F(n, a), _e();
  }
  function jb(n, e) {
    Re(e, true);
    let t = $(e, "id", 19, hn), r = $(e, "ref", 15, null), i = $(e, "forceMount", 3, false), s = wt(e, [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "forceMount"
    ]);
    const o = No.get(), a = X(() => i() || o.hasThumb);
    Oo(n, it({
      get present() {
        return S(a);
      }
    }, () => s, {
      get id() {
        return t();
      },
      presence: (l, c) => {
        let h = () => c?.().present;
        zb(l, it(() => s, {
          get id() {
            return t();
          },
          get present() {
            return h().current;
          },
          get ref() {
            return r();
          },
          set ref(d) {
            r(d);
          }
        }));
      },
      $$slots: {
        presence: true
      }
    })), _e();
  }
  var qb = ae("<div><!></div>");
  function $b(n, e) {
    Re(e, true);
    let t = $(e, "ref", 15, null), r = wt(e, [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "children",
      "child"
    ]);
    const i = Tb({
      id: Ne.with(() => e.id),
      ref: Ne.with(() => t(), (c) => t(c))
    }), s = X(() => vt(r, i.props));
    var o = se(), a = J(o);
    {
      var u = (c) => {
        var h = se(), d = J(h);
        rt(d, () => e.child, () => ({
          props: S(s)
        })), F(c, h);
      }, l = (c) => {
        var h = qb();
        let d;
        var f = Se(h);
        rt(f, () => e.children ?? pt), we(h), qe(() => d = Ge(h, d, {
          ...S(s)
        })), F(c, h);
      };
      be(a, (c) => {
        e.child ? c(u) : c(l, false);
      });
    }
    F(n, o), _e();
  }
  function Vb(n, e) {
    Re(e, true);
    let t = $(e, "ref", 15, null), r = $(e, "id", 19, hn), i = wt(e, [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id"
    ]);
    const s = Qi.get(), o = X(() => !!(s.scrollbarXNode && s.scrollbarYNode)), a = X(() => s.opts.type.current !== "scroll" && S(o));
    var u = se(), l = J(u);
    {
      var c = (h) => {
        $b(h, it(() => i, {
          get id() {
            return r();
          },
          get ref() {
            return t();
          },
          set ref(d) {
            t(d);
          }
        }));
      };
      be(l, (h) => {
        S(a) && h(c);
      });
    }
    F(n, u), _e();
  }
  const Hb = "data-toolbar-root", zh = "data-toolbar-item", Wb = "data-toolbar-button";
  class Ub {
    opts;
    rovingFocusGroup;
    constructor(e) {
      this.opts = e, Xt(e), this.rovingFocusGroup = og({
        orientation: this.opts.orientation,
        loop: this.opts.loop,
        rootNodeId: this.opts.id,
        candidateAttr: zh
      });
    }
    #e = X(() => ({
      id: this.opts.id.current,
      role: "toolbar",
      "data-orientation": this.opts.orientation.current,
      [Hb]: ""
    }));
    get props() {
      return S(this.#e);
    }
  }
  class Gb {
    opts;
    root;
    constructor(e, t) {
      this.opts = e, this.root = t, Xt(e), at(() => {
        te(this.#e, Be(this.root.rovingFocusGroup.getTabIndex(this.opts.ref.current)));
      }), this.onkeydown = this.onkeydown.bind(this);
    }
    onkeydown(e) {
      this.root.rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
    }
    #e = Me(0);
    #t = X(() => {
      if (!this.opts.ref.current) return;
      if (this.opts.ref.current.tagName !== "BUTTON") return "button";
    });
    #n = X(() => ({
      id: this.opts.id.current,
      [zh]: "",
      [Wb]: "",
      role: S(this.#t),
      tabindex: S(this.#e),
      "data-disabled": Ah(this.opts.disabled.current),
      "data-orientation": sg(this.root.opts.orientation.current),
      disabled: ig(this.opts.disabled.current),
      onkeydown: this.onkeydown
    }));
    get props() {
      return S(this.#n);
    }
  }
  const jh = new Vn("Toolbar.Root");
  function Kb(n) {
    return jh.set(new Ub(n));
  }
  function Jb(n) {
    return new Gb(n, jh.get());
  }
  var Yb = ae("<div><!></div>");
  function Xb(n, e) {
    Re(e, true);
    let t = $(e, "ref", 15, null), r = $(e, "id", 19, hn), i = $(e, "orientation", 3, "horizontal"), s = $(e, "loop", 3, true), o = wt(e, [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "orientation",
      "loop",
      "child",
      "children"
    ]);
    const a = Kb({
      id: Ne.with(() => r()),
      orientation: Ne.with(() => i()),
      loop: Ne.with(() => s()),
      ref: Ne.with(() => t(), (f) => t(f))
    }), u = X(() => vt(o, a.props));
    var l = se(), c = J(l);
    {
      var h = (f) => {
        var p = se(), m = J(p);
        rt(m, () => e.child, () => ({
          props: S(u)
        })), F(f, p);
      }, d = (f) => {
        var p = Yb();
        let m;
        var b = Se(p);
        rt(b, () => e.children ?? pt), we(p), qe(() => m = Ge(p, m, {
          ...S(u)
        })), F(f, p);
      };
      be(c, (f) => {
        e.child ? f(h) : f(d, false);
      });
    }
    F(n, l), _e();
  }
  var Qb = ae("<button><!></button>");
  function ds(n, e) {
    Re(e, true);
    let t = $(e, "disabled", 3, false), r = $(e, "type", 3, "button"), i = $(e, "id", 19, hn), s = $(e, "ref", 15, null), o = wt(e, [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "disabled",
      "type",
      "id",
      "ref"
    ]);
    const a = Jb({
      id: Ne.with(() => i()),
      disabled: Ne.with(() => t() ?? false),
      ref: Ne.with(() => s(), (f) => s(f))
    }), u = X(() => vt(o, a.props, {
      type: r()
    }));
    var l = se(), c = J(l);
    {
      var h = (f) => {
        var p = se(), m = J(p);
        rt(m, () => e.child, () => ({
          props: S(u)
        })), F(f, p);
      }, d = (f) => {
        var p = Qb();
        let m;
        var b = Se(p);
        rt(b, () => e.children ?? pt), we(p), qe(() => m = Ge(p, m, {
          ...S(u)
        })), F(f, p);
      };
      be(c, (f) => {
        e.child ? f(h) : f(d, false);
      });
    }
    F(n, l), _e();
  }
  var lr = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  }, Xs = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
  }, Zb = typeof navigator < "u" && /Mac/.test(navigator.platform), e1 = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  for (var Ct = 0; Ct < 10; Ct++) lr[48 + Ct] = lr[96 + Ct] = String(Ct);
  for (var Ct = 1; Ct <= 24; Ct++) lr[Ct + 111] = "F" + Ct;
  for (var Ct = 65; Ct <= 90; Ct++) lr[Ct] = String.fromCharCode(Ct + 32), Xs[Ct] = String.fromCharCode(Ct);
  for (var la in lr) Xs.hasOwnProperty(la) || (Xs[la] = lr[la]);
  function t1(n) {
    var e = Zb && n.metaKey && n.shiftKey && !n.ctrlKey && !n.altKey || e1 && n.shiftKey && n.key && n.key.length == 1 || n.key == "Unidentified", t = !e && n.key || (n.shiftKey ? Xs : lr)[n.keyCode] || n.key || "Unidentified";
    return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
  }
  function Et(n) {
    this.content = n;
  }
  Et.prototype = {
    constructor: Et,
    find: function(n) {
      for (var e = 0; e < this.content.length; e += 2) if (this.content[e] === n) return e;
      return -1;
    },
    get: function(n) {
      var e = this.find(n);
      return e == -1 ? void 0 : this.content[e + 1];
    },
    update: function(n, e, t) {
      var r = t && t != n ? this.remove(t) : this, i = r.find(n), s = r.content.slice();
      return i == -1 ? s.push(t || n, e) : (s[i + 1] = e, t && (s[i] = t)), new Et(s);
    },
    remove: function(n) {
      var e = this.find(n);
      if (e == -1) return this;
      var t = this.content.slice();
      return t.splice(e, 2), new Et(t);
    },
    addToStart: function(n, e) {
      return new Et([
        n,
        e
      ].concat(this.remove(n).content));
    },
    addToEnd: function(n, e) {
      var t = this.remove(n).content.slice();
      return t.push(n, e), new Et(t);
    },
    addBefore: function(n, e, t) {
      var r = this.remove(e), i = r.content.slice(), s = r.find(n);
      return i.splice(s == -1 ? i.length : s, 0, e, t), new Et(i);
    },
    forEach: function(n) {
      for (var e = 0; e < this.content.length; e += 2) n(this.content[e], this.content[e + 1]);
    },
    prepend: function(n) {
      return n = Et.from(n), n.size ? new Et(n.content.concat(this.subtract(n).content)) : this;
    },
    append: function(n) {
      return n = Et.from(n), n.size ? new Et(this.subtract(n).content.concat(n.content)) : this;
    },
    subtract: function(n) {
      var e = this;
      n = Et.from(n);
      for (var t = 0; t < n.content.length; t += 2) e = e.remove(n.content[t]);
      return e;
    },
    toObject: function() {
      var n = {};
      return this.forEach(function(e, t) {
        n[e] = t;
      }), n;
    },
    get size() {
      return this.content.length >> 1;
    }
  };
  Et.from = function(n) {
    if (n instanceof Et) return n;
    var e = [];
    if (n) for (var t in n) e.push(t, n[t]);
    return new Et(e);
  };
  function qh(n, e, t) {
    for (let r = 0; ; r++) {
      if (r == n.childCount || r == e.childCount) return n.childCount == e.childCount ? null : t;
      let i = n.child(r), s = e.child(r);
      if (i == s) {
        t += i.nodeSize;
        continue;
      }
      if (!i.sameMarkup(s)) return t;
      if (i.isText && i.text != s.text) {
        for (let o = 0; i.text[o] == s.text[o]; o++) t++;
        return t;
      }
      if (i.content.size || s.content.size) {
        let o = qh(i.content, s.content, t + 1);
        if (o != null) return o;
      }
      t += i.nodeSize;
    }
  }
  function $h(n, e, t, r) {
    for (let i = n.childCount, s = e.childCount; ; ) {
      if (i == 0 || s == 0) return i == s ? null : {
        a: t,
        b: r
      };
      let o = n.child(--i), a = e.child(--s), u = o.nodeSize;
      if (o == a) {
        t -= u, r -= u;
        continue;
      }
      if (!o.sameMarkup(a)) return {
        a: t,
        b: r
      };
      if (o.isText && o.text != a.text) {
        let l = 0, c = Math.min(o.text.length, a.text.length);
        for (; l < c && o.text[o.text.length - l - 1] == a.text[a.text.length - l - 1]; ) l++, t--, r--;
        return {
          a: t,
          b: r
        };
      }
      if (o.content.size || a.content.size) {
        let l = $h(o.content, a.content, t - 1, r - 1);
        if (l) return l;
      }
      t -= u, r -= u;
    }
  }
  class G {
    constructor(e, t) {
      if (this.content = e, this.size = t || 0, t == null) for (let r = 0; r < e.length; r++) this.size += e[r].nodeSize;
    }
    nodesBetween(e, t, r, i = 0, s) {
      for (let o = 0, a = 0; a < t; o++) {
        let u = this.content[o], l = a + u.nodeSize;
        if (l > e && r(u, i + a, s || null, o) !== false && u.content.size) {
          let c = a + 1;
          u.nodesBetween(Math.max(0, e - c), Math.min(u.content.size, t - c), r, i + c);
        }
        a = l;
      }
    }
    descendants(e) {
      this.nodesBetween(0, this.size, e);
    }
    textBetween(e, t, r, i) {
      let s = "", o = true;
      return this.nodesBetween(e, t, (a, u) => {
        let l = a.isText ? a.text.slice(Math.max(e, u) - u, t - u) : a.isLeaf ? i ? typeof i == "function" ? i(a) : i : a.type.spec.leafText ? a.type.spec.leafText(a) : "" : "";
        a.isBlock && (a.isLeaf && l || a.isTextblock) && r && (o ? o = false : s += r), s += l;
      }, 0), s;
    }
    append(e) {
      if (!e.size) return this;
      if (!this.size) return e;
      let t = this.lastChild, r = e.firstChild, i = this.content.slice(), s = 0;
      for (t.isText && t.sameMarkup(r) && (i[i.length - 1] = t.withText(t.text + r.text), s = 1); s < e.content.length; s++) i.push(e.content[s]);
      return new G(i, this.size + e.size);
    }
    cut(e, t = this.size) {
      if (e == 0 && t == this.size) return this;
      let r = [], i = 0;
      if (t > e) for (let s = 0, o = 0; o < t; s++) {
        let a = this.content[s], u = o + a.nodeSize;
        u > e && ((o < e || u > t) && (a.isText ? a = a.cut(Math.max(0, e - o), Math.min(a.text.length, t - o)) : a = a.cut(Math.max(0, e - o - 1), Math.min(a.content.size, t - o - 1))), r.push(a), i += a.nodeSize), o = u;
      }
      return new G(r, i);
    }
    cutByIndex(e, t) {
      return e == t ? G.empty : e == 0 && t == this.content.length ? this : new G(this.content.slice(e, t));
    }
    replaceChild(e, t) {
      let r = this.content[e];
      if (r == t) return this;
      let i = this.content.slice(), s = this.size + t.nodeSize - r.nodeSize;
      return i[e] = t, new G(i, s);
    }
    addToStart(e) {
      return new G([
        e
      ].concat(this.content), this.size + e.nodeSize);
    }
    addToEnd(e) {
      return new G(this.content.concat(e), this.size + e.nodeSize);
    }
    eq(e) {
      if (this.content.length != e.content.length) return false;
      for (let t = 0; t < this.content.length; t++) if (!this.content[t].eq(e.content[t])) return false;
      return true;
    }
    get firstChild() {
      return this.content.length ? this.content[0] : null;
    }
    get lastChild() {
      return this.content.length ? this.content[this.content.length - 1] : null;
    }
    get childCount() {
      return this.content.length;
    }
    child(e) {
      let t = this.content[e];
      if (!t) throw new RangeError("Index " + e + " out of range for " + this);
      return t;
    }
    maybeChild(e) {
      return this.content[e] || null;
    }
    forEach(e) {
      for (let t = 0, r = 0; t < this.content.length; t++) {
        let i = this.content[t];
        e(i, r, t), r += i.nodeSize;
      }
    }
    findDiffStart(e, t = 0) {
      return qh(this, e, t);
    }
    findDiffEnd(e, t = this.size, r = e.size) {
      return $h(this, e, t, r);
    }
    findIndex(e, t = -1) {
      if (e == 0) return fs(0, e);
      if (e == this.size) return fs(this.content.length, e);
      if (e > this.size || e < 0) throw new RangeError(`Position ${e} outside of fragment (${this})`);
      for (let r = 0, i = 0; ; r++) {
        let s = this.child(r), o = i + s.nodeSize;
        if (o >= e) return o == e || t > 0 ? fs(r + 1, o) : fs(r, i);
        i = o;
      }
    }
    toString() {
      return "<" + this.toStringInner() + ">";
    }
    toStringInner() {
      return this.content.join(", ");
    }
    toJSON() {
      return this.content.length ? this.content.map((e) => e.toJSON()) : null;
    }
    static fromJSON(e, t) {
      if (!t) return G.empty;
      if (!Array.isArray(t)) throw new RangeError("Invalid input for Fragment.fromJSON");
      return new G(t.map(e.nodeFromJSON));
    }
    static fromArray(e) {
      if (!e.length) return G.empty;
      let t, r = 0;
      for (let i = 0; i < e.length; i++) {
        let s = e[i];
        r += s.nodeSize, i && s.isText && e[i - 1].sameMarkup(s) ? (t || (t = e.slice(0, i)), t[t.length - 1] = s.withText(t[t.length - 1].text + s.text)) : t && t.push(s);
      }
      return new G(t || e, r);
    }
    static from(e) {
      if (!e) return G.empty;
      if (e instanceof G) return e;
      if (Array.isArray(e)) return this.fromArray(e);
      if (e.attrs) return new G([
        e
      ], e.nodeSize);
      throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
    }
  }
  G.empty = new G([], 0);
  const ca = {
    index: 0,
    offset: 0
  };
  function fs(n, e) {
    return ca.index = n, ca.offset = e, ca;
  }
  function Qs(n, e) {
    if (n === e) return true;
    if (!(n && typeof n == "object") || !(e && typeof e == "object")) return false;
    let t = Array.isArray(n);
    if (Array.isArray(e) != t) return false;
    if (t) {
      if (n.length != e.length) return false;
      for (let r = 0; r < n.length; r++) if (!Qs(n[r], e[r])) return false;
    } else {
      for (let r in n) if (!(r in e) || !Qs(n[r], e[r])) return false;
      for (let r in e) if (!(r in n)) return false;
    }
    return true;
  }
  let Ze = class Ou {
    constructor(e, t) {
      this.type = e, this.attrs = t;
    }
    addToSet(e) {
      let t, r = false;
      for (let i = 0; i < e.length; i++) {
        let s = e[i];
        if (this.eq(s)) return e;
        if (this.type.excludes(s.type)) t || (t = e.slice(0, i));
        else {
          if (s.type.excludes(this.type)) return e;
          !r && s.type.rank > this.type.rank && (t || (t = e.slice(0, i)), t.push(this), r = true), t && t.push(s);
        }
      }
      return t || (t = e.slice()), r || t.push(this), t;
    }
    removeFromSet(e) {
      for (let t = 0; t < e.length; t++) if (this.eq(e[t])) return e.slice(0, t).concat(e.slice(t + 1));
      return e;
    }
    isInSet(e) {
      for (let t = 0; t < e.length; t++) if (this.eq(e[t])) return true;
      return false;
    }
    eq(e) {
      return this == e || this.type == e.type && Qs(this.attrs, e.attrs);
    }
    toJSON() {
      let e = {
        type: this.type.name
      };
      for (let t in this.attrs) {
        e.attrs = this.attrs;
        break;
      }
      return e;
    }
    static fromJSON(e, t) {
      if (!t) throw new RangeError("Invalid input for Mark.fromJSON");
      let r = e.marks[t.type];
      if (!r) throw new RangeError(`There is no mark type ${t.type} in this schema`);
      let i = r.create(t.attrs);
      return r.checkAttrs(i.attrs), i;
    }
    static sameSet(e, t) {
      if (e == t) return true;
      if (e.length != t.length) return false;
      for (let r = 0; r < e.length; r++) if (!e[r].eq(t[r])) return false;
      return true;
    }
    static setFrom(e) {
      if (!e || Array.isArray(e) && e.length == 0) return Ou.none;
      if (e instanceof Ou) return [
        e
      ];
      let t = e.slice();
      return t.sort((r, i) => r.type.rank - i.type.rank), t;
    }
  };
  Ze.none = [];
  class Zs extends Error {
  }
  class re {
    constructor(e, t, r) {
      this.content = e, this.openStart = t, this.openEnd = r;
    }
    get size() {
      return this.content.size - this.openStart - this.openEnd;
    }
    insertAt(e, t) {
      let r = Hh(this.content, e + this.openStart, t);
      return r && new re(r, this.openStart, this.openEnd);
    }
    removeBetween(e, t) {
      return new re(Vh(this.content, e + this.openStart, t + this.openStart), this.openStart, this.openEnd);
    }
    eq(e) {
      return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
    }
    toString() {
      return this.content + "(" + this.openStart + "," + this.openEnd + ")";
    }
    toJSON() {
      if (!this.content.size) return null;
      let e = {
        content: this.content.toJSON()
      };
      return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
    }
    static fromJSON(e, t) {
      if (!t) return re.empty;
      let r = t.openStart || 0, i = t.openEnd || 0;
      if (typeof r != "number" || typeof i != "number") throw new RangeError("Invalid input for Slice.fromJSON");
      return new re(G.fromJSON(e, t.content), r, i);
    }
    static maxOpen(e, t = true) {
      let r = 0, i = 0;
      for (let s = e.firstChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.firstChild) r++;
      for (let s = e.lastChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.lastChild) i++;
      return new re(e, r, i);
    }
  }
  re.empty = new re(G.empty, 0, 0);
  function Vh(n, e, t) {
    let { index: r, offset: i } = n.findIndex(e), s = n.maybeChild(r), { index: o, offset: a } = n.findIndex(t);
    if (i == e || s.isText) {
      if (a != t && !n.child(o).isText) throw new RangeError("Removing non-flat range");
      return n.cut(0, e).append(n.cut(t));
    }
    if (r != o) throw new RangeError("Removing non-flat range");
    return n.replaceChild(r, s.copy(Vh(s.content, e - i - 1, t - i - 1)));
  }
  function Hh(n, e, t, r) {
    let { index: i, offset: s } = n.findIndex(e), o = n.maybeChild(i);
    if (s == e || o.isText) return n.cut(0, e).append(t).append(n.cut(e));
    let a = Hh(o.content, e - s - 1, t);
    return a && n.replaceChild(i, o.copy(a));
  }
  function n1(n, e, t) {
    if (t.openStart > n.depth) throw new Zs("Inserted content deeper than insertion position");
    if (n.depth - t.openStart != e.depth - t.openEnd) throw new Zs("Inconsistent open depths");
    return Wh(n, e, t, 0);
  }
  function Wh(n, e, t, r) {
    let i = n.index(r), s = n.node(r);
    if (i == e.index(r) && r < n.depth - t.openStart) {
      let o = Wh(n, e, t, r + 1);
      return s.copy(s.content.replaceChild(i, o));
    } else if (t.content.size) if (!t.openStart && !t.openEnd && n.depth == r && e.depth == r) {
      let o = n.parent, a = o.content;
      return Dr(o, a.cut(0, n.parentOffset).append(t.content).append(a.cut(e.parentOffset)));
    } else {
      let { start: o, end: a } = r1(t, n);
      return Dr(s, Gh(n, o, a, e, r));
    }
    else return Dr(s, eo(n, e, r));
  }
  function Uh(n, e) {
    if (!e.type.compatibleContent(n.type)) throw new Zs("Cannot join " + e.type.name + " onto " + n.type.name);
  }
  function Au(n, e, t) {
    let r = n.node(t);
    return Uh(r, e.node(t)), r;
  }
  function Pr(n, e) {
    let t = e.length - 1;
    t >= 0 && n.isText && n.sameMarkup(e[t]) ? e[t] = n.withText(e[t].text + n.text) : e.push(n);
  }
  function Ri(n, e, t, r) {
    let i = (e || n).node(t), s = 0, o = e ? e.index(t) : i.childCount;
    n && (s = n.index(t), n.depth > t ? s++ : n.textOffset && (Pr(n.nodeAfter, r), s++));
    for (let a = s; a < o; a++) Pr(i.child(a), r);
    e && e.depth == t && e.textOffset && Pr(e.nodeBefore, r);
  }
  function Dr(n, e) {
    return n.type.checkContent(e), n.copy(e);
  }
  function Gh(n, e, t, r, i) {
    let s = n.depth > i && Au(n, e, i + 1), o = r.depth > i && Au(t, r, i + 1), a = [];
    return Ri(null, n, i, a), s && o && e.index(i) == t.index(i) ? (Uh(s, o), Pr(Dr(s, Gh(n, e, t, r, i + 1)), a)) : (s && Pr(Dr(s, eo(n, e, i + 1)), a), Ri(e, t, i, a), o && Pr(Dr(o, eo(t, r, i + 1)), a)), Ri(r, null, i, a), new G(a);
  }
  function eo(n, e, t) {
    let r = [];
    if (Ri(null, n, t, r), n.depth > t) {
      let i = Au(n, e, t + 1);
      Pr(Dr(i, eo(n, e, t + 1)), r);
    }
    return Ri(e, null, t, r), new G(r);
  }
  function r1(n, e) {
    let t = e.depth - n.openStart, i = e.node(t).copy(n.content);
    for (let s = t - 1; s >= 0; s--) i = e.node(s).copy(G.from(i));
    return {
      start: i.resolveNoCache(n.openStart + t),
      end: i.resolveNoCache(i.content.size - n.openEnd - t)
    };
  }
  class qi {
    constructor(e, t, r) {
      this.pos = e, this.path = t, this.parentOffset = r, this.depth = t.length / 3 - 1;
    }
    resolveDepth(e) {
      return e == null ? this.depth : e < 0 ? this.depth + e : e;
    }
    get parent() {
      return this.node(this.depth);
    }
    get doc() {
      return this.node(0);
    }
    node(e) {
      return this.path[this.resolveDepth(e) * 3];
    }
    index(e) {
      return this.path[this.resolveDepth(e) * 3 + 1];
    }
    indexAfter(e) {
      return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
    }
    start(e) {
      return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
    }
    end(e) {
      return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
    }
    before(e) {
      if (e = this.resolveDepth(e), !e) throw new RangeError("There is no position before the top-level node");
      return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
    }
    after(e) {
      if (e = this.resolveDepth(e), !e) throw new RangeError("There is no position after the top-level node");
      return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
    }
    get textOffset() {
      return this.pos - this.path[this.path.length - 1];
    }
    get nodeAfter() {
      let e = this.parent, t = this.index(this.depth);
      if (t == e.childCount) return null;
      let r = this.pos - this.path[this.path.length - 1], i = e.child(t);
      return r ? e.child(t).cut(r) : i;
    }
    get nodeBefore() {
      let e = this.index(this.depth), t = this.pos - this.path[this.path.length - 1];
      return t ? this.parent.child(e).cut(0, t) : e == 0 ? null : this.parent.child(e - 1);
    }
    posAtIndex(e, t) {
      t = this.resolveDepth(t);
      let r = this.path[t * 3], i = t == 0 ? 0 : this.path[t * 3 - 1] + 1;
      for (let s = 0; s < e; s++) i += r.child(s).nodeSize;
      return i;
    }
    marks() {
      let e = this.parent, t = this.index();
      if (e.content.size == 0) return Ze.none;
      if (this.textOffset) return e.child(t).marks;
      let r = e.maybeChild(t - 1), i = e.maybeChild(t);
      if (!r) {
        let a = r;
        r = i, i = a;
      }
      let s = r.marks;
      for (var o = 0; o < s.length; o++) s[o].type.spec.inclusive === false && (!i || !s[o].isInSet(i.marks)) && (s = s[o--].removeFromSet(s));
      return s;
    }
    marksAcross(e) {
      let t = this.parent.maybeChild(this.index());
      if (!t || !t.isInline) return null;
      let r = t.marks, i = e.parent.maybeChild(e.index());
      for (var s = 0; s < r.length; s++) r[s].type.spec.inclusive === false && (!i || !r[s].isInSet(i.marks)) && (r = r[s--].removeFromSet(r));
      return r;
    }
    sharedDepth(e) {
      for (let t = this.depth; t > 0; t--) if (this.start(t) <= e && this.end(t) >= e) return t;
      return 0;
    }
    blockRange(e = this, t) {
      if (e.pos < this.pos) return e.blockRange(this);
      for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--) if (e.pos <= this.end(r) && (!t || t(this.node(r)))) return new to(this, e, r);
      return null;
    }
    sameParent(e) {
      return this.pos - this.parentOffset == e.pos - e.parentOffset;
    }
    max(e) {
      return e.pos > this.pos ? e : this;
    }
    min(e) {
      return e.pos < this.pos ? e : this;
    }
    toString() {
      let e = "";
      for (let t = 1; t <= this.depth; t++) e += (e ? "/" : "") + this.node(t).type.name + "_" + this.index(t - 1);
      return e + ":" + this.parentOffset;
    }
    static resolve(e, t) {
      if (!(t >= 0 && t <= e.content.size)) throw new RangeError("Position " + t + " out of range");
      let r = [], i = 0, s = t;
      for (let o = e; ; ) {
        let { index: a, offset: u } = o.content.findIndex(s), l = s - u;
        if (r.push(o, a, i + u), !l || (o = o.child(a), o.isText)) break;
        s = l - 1, i += u + 1;
      }
      return new qi(t, r, s);
    }
    static resolveCached(e, t) {
      let r = hc.get(e);
      if (r) for (let s = 0; s < r.elts.length; s++) {
        let o = r.elts[s];
        if (o.pos == t) return o;
      }
      else hc.set(e, r = new i1());
      let i = r.elts[r.i] = qi.resolve(e, t);
      return r.i = (r.i + 1) % s1, i;
    }
  }
  class i1 {
    constructor() {
      this.elts = [], this.i = 0;
    }
  }
  const s1 = 12, hc = /* @__PURE__ */ new WeakMap();
  class to {
    constructor(e, t, r) {
      this.$from = e, this.$to = t, this.depth = r;
    }
    get start() {
      return this.$from.before(this.depth + 1);
    }
    get end() {
      return this.$to.after(this.depth + 1);
    }
    get parent() {
      return this.$from.node(this.depth);
    }
    get startIndex() {
      return this.$from.index(this.depth);
    }
    get endIndex() {
      return this.$to.indexAfter(this.depth);
    }
  }
  const o1 = /* @__PURE__ */ Object.create(null);
  let zn = class Mu {
    constructor(e, t, r, i = Ze.none) {
      this.type = e, this.attrs = t, this.marks = i, this.content = r || G.empty;
    }
    get children() {
      return this.content.content;
    }
    get nodeSize() {
      return this.isLeaf ? 1 : 2 + this.content.size;
    }
    get childCount() {
      return this.content.childCount;
    }
    child(e) {
      return this.content.child(e);
    }
    maybeChild(e) {
      return this.content.maybeChild(e);
    }
    forEach(e) {
      this.content.forEach(e);
    }
    nodesBetween(e, t, r, i = 0) {
      this.content.nodesBetween(e, t, r, i, this);
    }
    descendants(e) {
      this.nodesBetween(0, this.content.size, e);
    }
    get textContent() {
      return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
    }
    textBetween(e, t, r, i) {
      return this.content.textBetween(e, t, r, i);
    }
    get firstChild() {
      return this.content.firstChild;
    }
    get lastChild() {
      return this.content.lastChild;
    }
    eq(e) {
      return this == e || this.sameMarkup(e) && this.content.eq(e.content);
    }
    sameMarkup(e) {
      return this.hasMarkup(e.type, e.attrs, e.marks);
    }
    hasMarkup(e, t, r) {
      return this.type == e && Qs(this.attrs, t || e.defaultAttrs || o1) && Ze.sameSet(this.marks, r || Ze.none);
    }
    copy(e = null) {
      return e == this.content ? this : new Mu(this.type, this.attrs, e, this.marks);
    }
    mark(e) {
      return e == this.marks ? this : new Mu(this.type, this.attrs, this.content, e);
    }
    cut(e, t = this.content.size) {
      return e == 0 && t == this.content.size ? this : this.copy(this.content.cut(e, t));
    }
    slice(e, t = this.content.size, r = false) {
      if (e == t) return re.empty;
      let i = this.resolve(e), s = this.resolve(t), o = r ? 0 : i.sharedDepth(t), a = i.start(o), l = i.node(o).content.cut(i.pos - a, s.pos - a);
      return new re(l, i.depth - o, s.depth - o);
    }
    replace(e, t, r) {
      return n1(this.resolve(e), this.resolve(t), r);
    }
    nodeAt(e) {
      for (let t = this; ; ) {
        let { index: r, offset: i } = t.content.findIndex(e);
        if (t = t.maybeChild(r), !t) return null;
        if (i == e || t.isText) return t;
        e -= i + 1;
      }
    }
    childAfter(e) {
      let { index: t, offset: r } = this.content.findIndex(e);
      return {
        node: this.content.maybeChild(t),
        index: t,
        offset: r
      };
    }
    childBefore(e) {
      if (e == 0) return {
        node: null,
        index: 0,
        offset: 0
      };
      let { index: t, offset: r } = this.content.findIndex(e);
      if (r < e) return {
        node: this.content.child(t),
        index: t,
        offset: r
      };
      let i = this.content.child(t - 1);
      return {
        node: i,
        index: t - 1,
        offset: r - i.nodeSize
      };
    }
    resolve(e) {
      return qi.resolveCached(this, e);
    }
    resolveNoCache(e) {
      return qi.resolve(this, e);
    }
    rangeHasMark(e, t, r) {
      let i = false;
      return t > e && this.nodesBetween(e, t, (s) => (r.isInSet(s.marks) && (i = true), !i)), i;
    }
    get isBlock() {
      return this.type.isBlock;
    }
    get isTextblock() {
      return this.type.isTextblock;
    }
    get inlineContent() {
      return this.type.inlineContent;
    }
    get isInline() {
      return this.type.isInline;
    }
    get isText() {
      return this.type.isText;
    }
    get isLeaf() {
      return this.type.isLeaf;
    }
    get isAtom() {
      return this.type.isAtom;
    }
    toString() {
      if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);
      let e = this.type.name;
      return this.content.size && (e += "(" + this.content.toStringInner() + ")"), Kh(this.marks, e);
    }
    contentMatchAt(e) {
      let t = this.type.contentMatch.matchFragment(this.content, 0, e);
      if (!t) throw new Error("Called contentMatchAt on a node with invalid content");
      return t;
    }
    canReplace(e, t, r = G.empty, i = 0, s = r.childCount) {
      let o = this.contentMatchAt(e).matchFragment(r, i, s), a = o && o.matchFragment(this.content, t);
      if (!a || !a.validEnd) return false;
      for (let u = i; u < s; u++) if (!this.type.allowsMarks(r.child(u).marks)) return false;
      return true;
    }
    canReplaceWith(e, t, r, i) {
      if (i && !this.type.allowsMarks(i)) return false;
      let s = this.contentMatchAt(e).matchType(r), o = s && s.matchFragment(this.content, t);
      return o ? o.validEnd : false;
    }
    canAppend(e) {
      return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
    }
    check() {
      this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
      let e = Ze.none;
      for (let t = 0; t < this.marks.length; t++) {
        let r = this.marks[t];
        r.type.checkAttrs(r.attrs), e = r.addToSet(e);
      }
      if (!Ze.sameSet(e, this.marks)) throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((t) => t.type.name)}`);
      this.content.forEach((t) => t.check());
    }
    toJSON() {
      let e = {
        type: this.type.name
      };
      for (let t in this.attrs) {
        e.attrs = this.attrs;
        break;
      }
      return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((t) => t.toJSON())), e;
    }
    static fromJSON(e, t) {
      if (!t) throw new RangeError("Invalid input for Node.fromJSON");
      let r;
      if (t.marks) {
        if (!Array.isArray(t.marks)) throw new RangeError("Invalid mark data for Node.fromJSON");
        r = t.marks.map(e.markFromJSON);
      }
      if (t.type == "text") {
        if (typeof t.text != "string") throw new RangeError("Invalid text node in JSON");
        return e.text(t.text, r);
      }
      let i = G.fromJSON(e, t.content), s = e.nodeType(t.type).create(t.attrs, i, r);
      return s.type.checkAttrs(s.attrs), s;
    }
  };
  zn.prototype.text = void 0;
  class no extends zn {
    constructor(e, t, r, i) {
      if (super(e, t, null, i), !r) throw new RangeError("Empty text nodes are not allowed");
      this.text = r;
    }
    toString() {
      return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : Kh(this.marks, JSON.stringify(this.text));
    }
    get textContent() {
      return this.text;
    }
    textBetween(e, t) {
      return this.text.slice(e, t);
    }
    get nodeSize() {
      return this.text.length;
    }
    mark(e) {
      return e == this.marks ? this : new no(this.type, this.attrs, this.text, e);
    }
    withText(e) {
      return e == this.text ? this : new no(this.type, this.attrs, e, this.marks);
    }
    cut(e = 0, t = this.text.length) {
      return e == 0 && t == this.text.length ? this : this.withText(this.text.slice(e, t));
    }
    eq(e) {
      return this.sameMarkup(e) && this.text == e.text;
    }
    toJSON() {
      let e = super.toJSON();
      return e.text = this.text, e;
    }
  }
  function Kh(n, e) {
    for (let t = n.length - 1; t >= 0; t--) e = n[t].type.name + "(" + e + ")";
    return e;
  }
  class Fr {
    constructor(e) {
      this.validEnd = e, this.next = [], this.wrapCache = [];
    }
    static parse(e, t) {
      let r = new a1(e, t);
      if (r.next == null) return Fr.empty;
      let i = Jh(r);
      r.next && r.err("Unexpected trailing text");
      let s = p1(h1(i));
      return m1(s, r), s;
    }
    matchType(e) {
      for (let t = 0; t < this.next.length; t++) if (this.next[t].type == e) return this.next[t].next;
      return null;
    }
    matchFragment(e, t = 0, r = e.childCount) {
      let i = this;
      for (let s = t; i && s < r; s++) i = i.matchType(e.child(s).type);
      return i;
    }
    get inlineContent() {
      return this.next.length != 0 && this.next[0].type.isInline;
    }
    get defaultType() {
      for (let e = 0; e < this.next.length; e++) {
        let { type: t } = this.next[e];
        if (!(t.isText || t.hasRequiredAttrs())) return t;
      }
      return null;
    }
    compatible(e) {
      for (let t = 0; t < this.next.length; t++) for (let r = 0; r < e.next.length; r++) if (this.next[t].type == e.next[r].type) return true;
      return false;
    }
    fillBefore(e, t = false, r = 0) {
      let i = [
        this
      ];
      function s(o, a) {
        let u = o.matchFragment(e, r);
        if (u && (!t || u.validEnd)) return G.from(a.map((l) => l.createAndFill()));
        for (let l = 0; l < o.next.length; l++) {
          let { type: c, next: h } = o.next[l];
          if (!(c.isText || c.hasRequiredAttrs()) && i.indexOf(h) == -1) {
            i.push(h);
            let d = s(h, a.concat(c));
            if (d) return d;
          }
        }
        return null;
      }
      return s(this, []);
    }
    findWrapping(e) {
      for (let r = 0; r < this.wrapCache.length; r += 2) if (this.wrapCache[r] == e) return this.wrapCache[r + 1];
      let t = this.computeWrapping(e);
      return this.wrapCache.push(e, t), t;
    }
    computeWrapping(e) {
      let t = /* @__PURE__ */ Object.create(null), r = [
        {
          match: this,
          type: null,
          via: null
        }
      ];
      for (; r.length; ) {
        let i = r.shift(), s = i.match;
        if (s.matchType(e)) {
          let o = [];
          for (let a = i; a.type; a = a.via) o.push(a.type);
          return o.reverse();
        }
        for (let o = 0; o < s.next.length; o++) {
          let { type: a, next: u } = s.next[o];
          !a.isLeaf && !a.hasRequiredAttrs() && !(a.name in t) && (!i.type || u.validEnd) && (r.push({
            match: a.contentMatch,
            type: a,
            via: i
          }), t[a.name] = true);
        }
      }
      return null;
    }
    get edgeCount() {
      return this.next.length;
    }
    edge(e) {
      if (e >= this.next.length) throw new RangeError(`There's no ${e}th edge in this content match`);
      return this.next[e];
    }
    toString() {
      let e = [];
      function t(r) {
        e.push(r);
        for (let i = 0; i < r.next.length; i++) e.indexOf(r.next[i].next) == -1 && t(r.next[i].next);
      }
      return t(this), e.map((r, i) => {
        let s = i + (r.validEnd ? "*" : " ") + " ";
        for (let o = 0; o < r.next.length; o++) s += (o ? ", " : "") + r.next[o].type.name + "->" + e.indexOf(r.next[o].next);
        return s;
      }).join(`
`);
    }
  }
  Fr.empty = new Fr(true);
  class a1 {
    constructor(e, t) {
      this.string = e, this.nodeTypes = t, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
    }
    get next() {
      return this.tokens[this.pos];
    }
    eat(e) {
      return this.next == e && (this.pos++ || true);
    }
    err(e) {
      throw new SyntaxError(e + " (in content expression '" + this.string + "')");
    }
  }
  function Jh(n) {
    let e = [];
    do
      e.push(u1(n));
    while (n.eat("|"));
    return e.length == 1 ? e[0] : {
      type: "choice",
      exprs: e
    };
  }
  function u1(n) {
    let e = [];
    do
      e.push(l1(n));
    while (n.next && n.next != ")" && n.next != "|");
    return e.length == 1 ? e[0] : {
      type: "seq",
      exprs: e
    };
  }
  function l1(n) {
    let e = f1(n);
    for (; ; ) if (n.eat("+")) e = {
      type: "plus",
      expr: e
    };
    else if (n.eat("*")) e = {
      type: "star",
      expr: e
    };
    else if (n.eat("?")) e = {
      type: "opt",
      expr: e
    };
    else if (n.eat("{")) e = c1(n, e);
    else break;
    return e;
  }
  function pc(n) {
    /\D/.test(n.next) && n.err("Expected number, got '" + n.next + "'");
    let e = Number(n.next);
    return n.pos++, e;
  }
  function c1(n, e) {
    let t = pc(n), r = t;
    return n.eat(",") && (n.next != "}" ? r = pc(n) : r = -1), n.eat("}") || n.err("Unclosed braced range"), {
      type: "range",
      min: t,
      max: r,
      expr: e
    };
  }
  function d1(n, e) {
    let t = n.nodeTypes, r = t[e];
    if (r) return [
      r
    ];
    let i = [];
    for (let s in t) {
      let o = t[s];
      o.isInGroup(e) && i.push(o);
    }
    return i.length == 0 && n.err("No node type or group '" + e + "' found"), i;
  }
  function f1(n) {
    if (n.eat("(")) {
      let e = Jh(n);
      return n.eat(")") || n.err("Missing closing paren"), e;
    } else if (/\W/.test(n.next)) n.err("Unexpected token '" + n.next + "'");
    else {
      let e = d1(n, n.next).map((t) => (n.inline == null ? n.inline = t.isInline : n.inline != t.isInline && n.err("Mixing inline and block content"), {
        type: "name",
        value: t
      }));
      return n.pos++, e.length == 1 ? e[0] : {
        type: "choice",
        exprs: e
      };
    }
  }
  function h1(n) {
    let e = [
      []
    ];
    return i(s(n, 0), t()), e;
    function t() {
      return e.push([]) - 1;
    }
    function r(o, a, u) {
      let l = {
        term: u,
        to: a
      };
      return e[o].push(l), l;
    }
    function i(o, a) {
      o.forEach((u) => u.to = a);
    }
    function s(o, a) {
      if (o.type == "choice") return o.exprs.reduce((u, l) => u.concat(s(l, a)), []);
      if (o.type == "seq") for (let u = 0; ; u++) {
        let l = s(o.exprs[u], a);
        if (u == o.exprs.length - 1) return l;
        i(l, a = t());
      }
      else if (o.type == "star") {
        let u = t();
        return r(a, u), i(s(o.expr, u), u), [
          r(u)
        ];
      } else if (o.type == "plus") {
        let u = t();
        return i(s(o.expr, a), u), i(s(o.expr, u), u), [
          r(u)
        ];
      } else {
        if (o.type == "opt") return [
          r(a)
        ].concat(s(o.expr, a));
        if (o.type == "range") {
          let u = a;
          for (let l = 0; l < o.min; l++) {
            let c = t();
            i(s(o.expr, u), c), u = c;
          }
          if (o.max == -1) i(s(o.expr, u), u);
          else for (let l = o.min; l < o.max; l++) {
            let c = t();
            r(u, c), i(s(o.expr, u), c), u = c;
          }
          return [
            r(u)
          ];
        } else {
          if (o.type == "name") return [
            r(a, void 0, o.value)
          ];
          throw new Error("Unknown expr type");
        }
      }
    }
  }
  function Yh(n, e) {
    return e - n;
  }
  function mc(n, e) {
    let t = [];
    return r(e), t.sort(Yh);
    function r(i) {
      let s = n[i];
      if (s.length == 1 && !s[0].term) return r(s[0].to);
      t.push(i);
      for (let o = 0; o < s.length; o++) {
        let { term: a, to: u } = s[o];
        !a && t.indexOf(u) == -1 && r(u);
      }
    }
  }
  function p1(n) {
    let e = /* @__PURE__ */ Object.create(null);
    return t(mc(n, 0));
    function t(r) {
      let i = [];
      r.forEach((o) => {
        n[o].forEach(({ term: a, to: u }) => {
          if (!a) return;
          let l;
          for (let c = 0; c < i.length; c++) i[c][0] == a && (l = i[c][1]);
          mc(n, u).forEach((c) => {
            l || i.push([
              a,
              l = []
            ]), l.indexOf(c) == -1 && l.push(c);
          });
        });
      });
      let s = e[r.join(",")] = new Fr(r.indexOf(n.length - 1) > -1);
      for (let o = 0; o < i.length; o++) {
        let a = i[o][1].sort(Yh);
        s.next.push({
          type: i[o][0],
          next: e[a.join(",")] || t(a)
        });
      }
      return s;
    }
  }
  function m1(n, e) {
    for (let t = 0, r = [
      n
    ]; t < r.length; t++) {
      let i = r[t], s = !i.validEnd, o = [];
      for (let a = 0; a < i.next.length; a++) {
        let { type: u, next: l } = i.next[a];
        o.push(u.name), s && !(u.isText || u.hasRequiredAttrs()) && (s = false), r.indexOf(l) == -1 && r.push(l);
      }
      s && e.err("Only non-generatable nodes (" + o.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
    }
  }
  function Xh(n) {
    let e = /* @__PURE__ */ Object.create(null);
    for (let t in n) {
      let r = n[t];
      if (!r.hasDefault) return null;
      e[t] = r.default;
    }
    return e;
  }
  function Qh(n, e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let r in n) {
      let i = e && e[r];
      if (i === void 0) {
        let s = n[r];
        if (s.hasDefault) i = s.default;
        else throw new RangeError("No value supplied for attribute " + r);
      }
      t[r] = i;
    }
    return t;
  }
  function Zh(n, e, t, r) {
    for (let i in e) if (!(i in n)) throw new RangeError(`Unsupported attribute ${i} for ${t} of type ${i}`);
    for (let i in n) {
      let s = n[i];
      s.validate && s.validate(e[i]);
    }
  }
  function ep(n, e) {
    let t = /* @__PURE__ */ Object.create(null);
    if (e) for (let r in e) t[r] = new b1(n, r, e[r]);
    return t;
  }
  let gc = class tp {
    constructor(e, t, r) {
      this.name = e, this.schema = t, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = ep(e, r.attrs), this.defaultAttrs = Xh(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || e == "text"), this.isText = e == "text";
    }
    get isInline() {
      return !this.isBlock;
    }
    get isTextblock() {
      return this.isBlock && this.inlineContent;
    }
    get isLeaf() {
      return this.contentMatch == Fr.empty;
    }
    get isAtom() {
      return this.isLeaf || !!this.spec.atom;
    }
    isInGroup(e) {
      return this.groups.indexOf(e) > -1;
    }
    get whitespace() {
      return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
    }
    hasRequiredAttrs() {
      for (let e in this.attrs) if (this.attrs[e].isRequired) return true;
      return false;
    }
    compatibleContent(e) {
      return this == e || this.contentMatch.compatible(e.contentMatch);
    }
    computeAttrs(e) {
      return !e && this.defaultAttrs ? this.defaultAttrs : Qh(this.attrs, e);
    }
    create(e = null, t, r) {
      if (this.isText) throw new Error("NodeType.create can't construct text nodes");
      return new zn(this, this.computeAttrs(e), G.from(t), Ze.setFrom(r));
    }
    createChecked(e = null, t, r) {
      return t = G.from(t), this.checkContent(t), new zn(this, this.computeAttrs(e), t, Ze.setFrom(r));
    }
    createAndFill(e = null, t, r) {
      if (e = this.computeAttrs(e), t = G.from(t), t.size) {
        let o = this.contentMatch.fillBefore(t);
        if (!o) return null;
        t = o.append(t);
      }
      let i = this.contentMatch.matchFragment(t), s = i && i.fillBefore(G.empty, true);
      return s ? new zn(this, e, t.append(s), Ze.setFrom(r)) : null;
    }
    validContent(e) {
      let t = this.contentMatch.matchFragment(e);
      if (!t || !t.validEnd) return false;
      for (let r = 0; r < e.childCount; r++) if (!this.allowsMarks(e.child(r).marks)) return false;
      return true;
    }
    checkContent(e) {
      if (!this.validContent(e)) throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
    }
    checkAttrs(e) {
      Zh(this.attrs, e, "node", this.name);
    }
    allowsMarkType(e) {
      return this.markSet == null || this.markSet.indexOf(e) > -1;
    }
    allowsMarks(e) {
      if (this.markSet == null) return true;
      for (let t = 0; t < e.length; t++) if (!this.allowsMarkType(e[t].type)) return false;
      return true;
    }
    allowedMarks(e) {
      if (this.markSet == null) return e;
      let t;
      for (let r = 0; r < e.length; r++) this.allowsMarkType(e[r].type) ? t && t.push(e[r]) : t || (t = e.slice(0, r));
      return t ? t.length ? t : Ze.none : e;
    }
    static compile(e, t) {
      let r = /* @__PURE__ */ Object.create(null);
      e.forEach((s, o) => r[s] = new tp(s, t, o));
      let i = t.spec.topNode || "doc";
      if (!r[i]) throw new RangeError("Schema is missing its top node type ('" + i + "')");
      if (!r.text) throw new RangeError("Every schema needs a 'text' type");
      for (let s in r.text.attrs) throw new RangeError("The text node type should not have attributes");
      return r;
    }
  };
  function g1(n, e, t) {
    let r = t.split("|");
    return (i) => {
      let s = i === null ? "null" : typeof i;
      if (r.indexOf(s) < 0) throw new RangeError(`Expected value of type ${r} for attribute ${e} on type ${n}, got ${s}`);
    };
  }
  class b1 {
    constructor(e, t, r) {
      this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"), this.default = r.default, this.validate = typeof r.validate == "string" ? g1(e, t, r.validate) : r.validate;
    }
    get isRequired() {
      return !this.hasDefault;
    }
  }
  class Io {
    constructor(e, t, r, i) {
      this.name = e, this.rank = t, this.schema = r, this.spec = i, this.attrs = ep(e, i.attrs), this.excluded = null;
      let s = Xh(this.attrs);
      this.instance = s ? new Ze(this, s) : null;
    }
    create(e = null) {
      return !e && this.instance ? this.instance : new Ze(this, Qh(this.attrs, e));
    }
    static compile(e, t) {
      let r = /* @__PURE__ */ Object.create(null), i = 0;
      return e.forEach((s, o) => r[s] = new Io(s, i++, t, o)), r;
    }
    removeFromSet(e) {
      for (var t = 0; t < e.length; t++) e[t].type == this && (e = e.slice(0, t).concat(e.slice(t + 1)), t--);
      return e;
    }
    isInSet(e) {
      for (let t = 0; t < e.length; t++) if (e[t].type == this) return e[t];
    }
    checkAttrs(e) {
      Zh(this.attrs, e, "mark", this.name);
    }
    excludes(e) {
      return this.excluded.indexOf(e) > -1;
    }
  }
  class np {
    constructor(e) {
      this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
      let t = this.spec = {};
      for (let i in e) t[i] = e[i];
      t.nodes = Et.from(e.nodes), t.marks = Et.from(e.marks || {}), this.nodes = gc.compile(this.spec.nodes, this), this.marks = Io.compile(this.spec.marks, this);
      let r = /* @__PURE__ */ Object.create(null);
      for (let i in this.nodes) {
        if (i in this.marks) throw new RangeError(i + " can not be both a node and a mark");
        let s = this.nodes[i], o = s.spec.content || "", a = s.spec.marks;
        if (s.contentMatch = r[o] || (r[o] = Fr.parse(o, this.nodes)), s.inlineContent = s.contentMatch.inlineContent, s.spec.linebreakReplacement) {
          if (this.linebreakReplacement) throw new RangeError("Multiple linebreak nodes defined");
          if (!s.isInline || !s.isLeaf) throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
          this.linebreakReplacement = s;
        }
        s.markSet = a == "_" ? null : a ? bc(this, a.split(" ")) : a == "" || !s.inlineContent ? [] : null;
      }
      for (let i in this.marks) {
        let s = this.marks[i], o = s.spec.excludes;
        s.excluded = o == null ? [
          s
        ] : o == "" ? [] : bc(this, o.split(" "));
      }
      this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
    }
    node(e, t = null, r, i) {
      if (typeof e == "string") e = this.nodeType(e);
      else if (e instanceof gc) {
        if (e.schema != this) throw new RangeError("Node type from different schema used (" + e.name + ")");
      } else throw new RangeError("Invalid node type: " + e);
      return e.createChecked(t, r, i);
    }
    text(e, t) {
      let r = this.nodes.text;
      return new no(r, r.defaultAttrs, e, Ze.setFrom(t));
    }
    mark(e, t) {
      return typeof e == "string" && (e = this.marks[e]), e.create(t);
    }
    nodeFromJSON(e) {
      return zn.fromJSON(this, e);
    }
    markFromJSON(e) {
      return Ze.fromJSON(this, e);
    }
    nodeType(e) {
      let t = this.nodes[e];
      if (!t) throw new RangeError("Unknown node type: " + e);
      return t;
    }
  }
  function bc(n, e) {
    let t = [];
    for (let r = 0; r < e.length; r++) {
      let i = e[r], s = n.marks[i], o = s;
      if (s) t.push(s);
      else for (let a in n.marks) {
        let u = n.marks[a];
        (i == "_" || u.spec.group && u.spec.group.split(" ").indexOf(i) > -1) && t.push(o = u);
      }
      if (!o) throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
    }
    return t;
  }
  function y1(n) {
    return n.tag != null;
  }
  function v1(n) {
    return n.style != null;
  }
  class sr {
    constructor(e, t) {
      this.schema = e, this.rules = t, this.tags = [], this.styles = [];
      let r = this.matchedStyles = [];
      t.forEach((i) => {
        if (y1(i)) this.tags.push(i);
        else if (v1(i)) {
          let s = /[^=]*/.exec(i.style)[0];
          r.indexOf(s) < 0 && r.push(s), this.styles.push(i);
        }
      }), this.normalizeLists = !this.tags.some((i) => {
        if (!/^(ul|ol)\b/.test(i.tag) || !i.node) return false;
        let s = e.nodes[i.node];
        return s.contentMatch.matchType(s);
      });
    }
    parse(e, t = {}) {
      let r = new vc(this, t, false);
      return r.addAll(e, Ze.none, t.from, t.to), r.finish();
    }
    parseSlice(e, t = {}) {
      let r = new vc(this, t, true);
      return r.addAll(e, Ze.none, t.from, t.to), re.maxOpen(r.finish());
    }
    matchTag(e, t, r) {
      for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) {
        let s = this.tags[i];
        if (k1(e, s.tag) && (s.namespace === void 0 || e.namespaceURI == s.namespace) && (!s.context || t.matchesContext(s.context))) {
          if (s.getAttrs) {
            let o = s.getAttrs(e);
            if (o === false) continue;
            s.attrs = o || void 0;
          }
          return s;
        }
      }
    }
    matchStyle(e, t, r, i) {
      for (let s = i ? this.styles.indexOf(i) + 1 : 0; s < this.styles.length; s++) {
        let o = this.styles[s], a = o.style;
        if (!(a.indexOf(e) != 0 || o.context && !r.matchesContext(o.context) || a.length > e.length && (a.charCodeAt(e.length) != 61 || a.slice(e.length + 1) != t))) {
          if (o.getAttrs) {
            let u = o.getAttrs(t);
            if (u === false) continue;
            o.attrs = u || void 0;
          }
          return o;
        }
      }
    }
    static schemaRules(e) {
      let t = [];
      function r(i) {
        let s = i.priority == null ? 50 : i.priority, o = 0;
        for (; o < t.length; o++) {
          let a = t[o];
          if ((a.priority == null ? 50 : a.priority) < s) break;
        }
        t.splice(o, 0, i);
      }
      for (let i in e.marks) {
        let s = e.marks[i].spec.parseDOM;
        s && s.forEach((o) => {
          r(o = wc(o)), o.mark || o.ignore || o.clearMark || (o.mark = i);
        });
      }
      for (let i in e.nodes) {
        let s = e.nodes[i].spec.parseDOM;
        s && s.forEach((o) => {
          r(o = wc(o)), o.node || o.ignore || o.mark || (o.node = i);
        });
      }
      return t;
    }
    static fromSchema(e) {
      return e.cached.domParser || (e.cached.domParser = new sr(e, sr.schemaRules(e)));
    }
  }
  const rp = {
    address: true,
    article: true,
    aside: true,
    blockquote: true,
    canvas: true,
    dd: true,
    div: true,
    dl: true,
    fieldset: true,
    figcaption: true,
    figure: true,
    footer: true,
    form: true,
    h1: true,
    h2: true,
    h3: true,
    h4: true,
    h5: true,
    h6: true,
    header: true,
    hgroup: true,
    hr: true,
    li: true,
    noscript: true,
    ol: true,
    output: true,
    p: true,
    pre: true,
    section: true,
    table: true,
    tfoot: true,
    ul: true
  }, w1 = {
    head: true,
    noscript: true,
    object: true,
    script: true,
    style: true,
    title: true
  }, ip = {
    ol: true,
    ul: true
  }, $i = 1, Nu = 2, zs = 4;
  function yc(n, e, t) {
    return e != null ? (e ? $i : 0) | (e === "full" ? Nu : 0) : n && n.whitespace == "pre" ? $i | Nu : t & -5;
  }
  class hs {
    constructor(e, t, r, i, s, o) {
      this.type = e, this.attrs = t, this.marks = r, this.solid = i, this.options = o, this.content = [], this.activeMarks = Ze.none, this.match = s || (o & zs ? null : e.contentMatch);
    }
    findWrapping(e) {
      if (!this.match) {
        if (!this.type) return [];
        let t = this.type.contentMatch.fillBefore(G.from(e));
        if (t) this.match = this.type.contentMatch.matchFragment(t);
        else {
          let r = this.type.contentMatch, i;
          return (i = r.findWrapping(e.type)) ? (this.match = r, i) : null;
        }
      }
      return this.match.findWrapping(e.type);
    }
    finish(e) {
      if (!(this.options & $i)) {
        let r = this.content[this.content.length - 1], i;
        if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
          let s = r;
          r.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = s.withText(s.text.slice(0, s.text.length - i[0].length));
        }
      }
      let t = G.from(this.content);
      return !e && this.match && (t = t.append(this.match.fillBefore(G.empty, true))), this.type ? this.type.create(this.attrs, t, this.marks) : t;
    }
    inlineContext(e) {
      return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !rp.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
    }
  }
  class vc {
    constructor(e, t, r) {
      this.parser = e, this.options = t, this.isOpen = r, this.open = 0, this.localPreserveWS = false;
      let i = t.topNode, s, o = yc(null, t.preserveWhitespace, 0) | (r ? zs : 0);
      i ? s = new hs(i.type, i.attrs, Ze.none, true, t.topMatch || i.type.contentMatch, o) : r ? s = new hs(null, null, Ze.none, true, null, o) : s = new hs(e.schema.topNodeType, null, Ze.none, true, null, o), this.nodes = [
        s
      ], this.find = t.findPositions, this.needsBlock = false;
    }
    get top() {
      return this.nodes[this.open];
    }
    addDOM(e, t) {
      e.nodeType == 3 ? this.addTextNode(e, t) : e.nodeType == 1 && this.addElement(e, t);
    }
    addTextNode(e, t) {
      let r = e.nodeValue, i = this.top, s = i.options & Nu ? "full" : this.localPreserveWS || (i.options & $i) > 0;
      if (s === "full" || i.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
        if (s) s !== "full" ? r = r.replace(/\r?\n|\r/g, " ") : r = r.replace(/\r\n?/g, `
`);
        else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) {
          let o = i.content[i.content.length - 1], a = e.previousSibling;
          (!o || a && a.nodeName == "BR" || o.isText && /[ \t\r\n\u000c]$/.test(o.text)) && (r = r.slice(1));
        }
        r && this.insertNode(this.parser.schema.text(r), t), this.findInText(e);
      } else this.findInside(e);
    }
    addElement(e, t, r) {
      let i = this.localPreserveWS, s = this.top;
      (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = true);
      let o = e.nodeName.toLowerCase(), a;
      ip.hasOwnProperty(o) && this.parser.normalizeLists && x1(e);
      let u = this.options.ruleFromNode && this.options.ruleFromNode(e) || (a = this.parser.matchTag(e, this, r));
      e: if (u ? u.ignore : w1.hasOwnProperty(o)) this.findInside(e), this.ignoreFallback(e, t);
      else if (!u || u.skip || u.closeParent) {
        u && u.closeParent ? this.open = Math.max(0, this.open - 1) : u && u.skip.nodeType && (e = u.skip);
        let l, c = this.needsBlock;
        if (rp.hasOwnProperty(o)) s.content.length && s.content[0].isInline && this.open && (this.open--, s = this.top), l = true, s.type || (this.needsBlock = true);
        else if (!e.firstChild) {
          this.leafFallback(e, t);
          break e;
        }
        let h = u && u.skip ? t : this.readStyles(e, t);
        h && this.addAll(e, h), l && this.sync(s), this.needsBlock = c;
      } else {
        let l = this.readStyles(e, t);
        l && this.addElementByRule(e, u, l, u.consuming === false ? a : void 0);
      }
      this.localPreserveWS = i;
    }
    leafFallback(e, t) {
      e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), t);
    }
    ignoreFallback(e, t) {
      e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), t);
    }
    readStyles(e, t) {
      let r = e.style;
      if (r && r.length) for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let s = this.parser.matchedStyles[i], o = r.getPropertyValue(s);
        if (o) for (let a = void 0; ; ) {
          let u = this.parser.matchStyle(s, o, this, a);
          if (!u) break;
          if (u.ignore) return null;
          if (u.clearMark ? t = t.filter((l) => !u.clearMark(l)) : t = t.concat(this.parser.schema.marks[u.mark].create(u.attrs)), u.consuming === false) a = u;
          else break;
        }
      }
      return t;
    }
    addElementByRule(e, t, r, i) {
      let s, o;
      if (t.node) if (o = this.parser.schema.nodes[t.node], o.isLeaf) this.insertNode(o.create(t.attrs), r) || this.leafFallback(e, r);
      else {
        let u = this.enter(o, t.attrs || null, r, t.preserveWhitespace);
        u && (s = true, r = u);
      }
      else {
        let u = this.parser.schema.marks[t.mark];
        r = r.concat(u.create(t.attrs));
      }
      let a = this.top;
      if (o && o.isLeaf) this.findInside(e);
      else if (i) this.addElement(e, r, i);
      else if (t.getContent) this.findInside(e), t.getContent(e, this.parser.schema).forEach((u) => this.insertNode(u, r));
      else {
        let u = e;
        typeof t.contentElement == "string" ? u = e.querySelector(t.contentElement) : typeof t.contentElement == "function" ? u = t.contentElement(e) : t.contentElement && (u = t.contentElement), this.findAround(e, u, true), this.addAll(u, r), this.findAround(e, u, false);
      }
      s && this.sync(a) && this.open--;
    }
    addAll(e, t, r, i) {
      let s = r || 0;
      for (let o = r ? e.childNodes[r] : e.firstChild, a = i == null ? null : e.childNodes[i]; o != a; o = o.nextSibling, ++s) this.findAtPoint(e, s), this.addDOM(o, t);
      this.findAtPoint(e, s);
    }
    findPlace(e, t) {
      let r, i;
      for (let s = this.open; s >= 0; s--) {
        let o = this.nodes[s], a = o.findWrapping(e);
        if (a && (!r || r.length > a.length) && (r = a, i = o, !a.length) || o.solid) break;
      }
      if (!r) return null;
      this.sync(i);
      for (let s = 0; s < r.length; s++) t = this.enterInner(r[s], null, t, false);
      return t;
    }
    insertNode(e, t) {
      if (e.isInline && this.needsBlock && !this.top.type) {
        let i = this.textblockFromContext();
        i && (t = this.enterInner(i, null, t));
      }
      let r = this.findPlace(e, t);
      if (r) {
        this.closeExtra();
        let i = this.top;
        i.match && (i.match = i.match.matchType(e.type));
        let s = Ze.none;
        for (let o of r.concat(e.marks)) (i.type ? i.type.allowsMarkType(o.type) : xc(o.type, e.type)) && (s = o.addToSet(s));
        return i.content.push(e.mark(s)), true;
      }
      return false;
    }
    enter(e, t, r, i) {
      let s = this.findPlace(e.create(t), r);
      return s && (s = this.enterInner(e, t, r, true, i)), s;
    }
    enterInner(e, t, r, i = false, s) {
      this.closeExtra();
      let o = this.top;
      o.match = o.match && o.match.matchType(e);
      let a = yc(e, s, o.options);
      o.options & zs && o.content.length == 0 && (a |= zs);
      let u = Ze.none;
      return r = r.filter((l) => (o.type ? o.type.allowsMarkType(l.type) : xc(l.type, e)) ? (u = l.addToSet(u), false) : true), this.nodes.push(new hs(e, t, u, i, null, a)), this.open++, r;
    }
    closeExtra(e = false) {
      let t = this.nodes.length - 1;
      if (t > this.open) {
        for (; t > this.open; t--) this.nodes[t - 1].content.push(this.nodes[t].finish(e));
        this.nodes.length = this.open + 1;
      }
    }
    finish() {
      return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
    }
    sync(e) {
      for (let t = this.open; t >= 0; t--) {
        if (this.nodes[t] == e) return this.open = t, true;
        this.localPreserveWS && (this.nodes[t].options |= $i);
      }
      return false;
    }
    get currentPos() {
      this.closeExtra();
      let e = 0;
      for (let t = this.open; t >= 0; t--) {
        let r = this.nodes[t].content;
        for (let i = r.length - 1; i >= 0; i--) e += r[i].nodeSize;
        t && e++;
      }
      return e;
    }
    findAtPoint(e, t) {
      if (this.find) for (let r = 0; r < this.find.length; r++) this.find[r].node == e && this.find[r].offset == t && (this.find[r].pos = this.currentPos);
    }
    findInside(e) {
      if (this.find) for (let t = 0; t < this.find.length; t++) this.find[t].pos == null && e.nodeType == 1 && e.contains(this.find[t].node) && (this.find[t].pos = this.currentPos);
    }
    findAround(e, t, r) {
      if (e != t && this.find) for (let i = 0; i < this.find.length; i++) this.find[i].pos == null && e.nodeType == 1 && e.contains(this.find[i].node) && t.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) && (this.find[i].pos = this.currentPos);
    }
    findInText(e) {
      if (this.find) for (let t = 0; t < this.find.length; t++) this.find[t].node == e && (this.find[t].pos = this.currentPos - (e.nodeValue.length - this.find[t].offset));
    }
    matchesContext(e) {
      if (e.indexOf("|") > -1) return e.split(/\s*\|\s*/).some(this.matchesContext, this);
      let t = e.split("/"), r = this.options.context, i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), s = -(r ? r.depth + 1 : 0) + (i ? 0 : 1), o = (a, u) => {
        for (; a >= 0; a--) {
          let l = t[a];
          if (l == "") {
            if (a == t.length - 1 || a == 0) continue;
            for (; u >= s; u--) if (o(a - 1, u)) return true;
            return false;
          } else {
            let c = u > 0 || u == 0 && i ? this.nodes[u].type : r && u >= s ? r.node(u - s).type : null;
            if (!c || c.name != l && !c.isInGroup(l)) return false;
            u--;
          }
        }
        return true;
      };
      return o(t.length - 1, this.open);
    }
    textblockFromContext() {
      let e = this.options.context;
      if (e) for (let t = e.depth; t >= 0; t--) {
        let r = e.node(t).contentMatchAt(e.indexAfter(t)).defaultType;
        if (r && r.isTextblock && r.defaultAttrs) return r;
      }
      for (let t in this.parser.schema.nodes) {
        let r = this.parser.schema.nodes[t];
        if (r.isTextblock && r.defaultAttrs) return r;
      }
    }
  }
  function x1(n) {
    for (let e = n.firstChild, t = null; e; e = e.nextSibling) {
      let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
      r && ip.hasOwnProperty(r) && t ? (t.appendChild(e), e = t) : r == "li" ? t = e : r && (t = null);
    }
  }
  function k1(n, e) {
    return (n.matches || n.msMatchesSelector || n.webkitMatchesSelector || n.mozMatchesSelector).call(n, e);
  }
  function wc(n) {
    let e = {};
    for (let t in n) e[t] = n[t];
    return e;
  }
  function xc(n, e) {
    let t = e.schema.nodes;
    for (let r in t) {
      let i = t[r];
      if (!i.allowsMarkType(n)) continue;
      let s = [], o = (a) => {
        s.push(a);
        for (let u = 0; u < a.edgeCount; u++) {
          let { type: l, next: c } = a.edge(u);
          if (l == e || s.indexOf(c) < 0 && o(c)) return true;
        }
      };
      if (o(i.contentMatch)) return true;
    }
  }
  class Vr {
    constructor(e, t) {
      this.nodes = e, this.marks = t;
    }
    serializeFragment(e, t = {}, r) {
      r || (r = da(t).createDocumentFragment());
      let i = r, s = [];
      return e.forEach((o) => {
        if (s.length || o.marks.length) {
          let a = 0, u = 0;
          for (; a < s.length && u < o.marks.length; ) {
            let l = o.marks[u];
            if (!this.marks[l.type.name]) {
              u++;
              continue;
            }
            if (!l.eq(s[a][0]) || l.type.spec.spanning === false) break;
            a++, u++;
          }
          for (; a < s.length; ) i = s.pop()[1];
          for (; u < o.marks.length; ) {
            let l = o.marks[u++], c = this.serializeMark(l, o.isInline, t);
            c && (s.push([
              l,
              i
            ]), i.appendChild(c.dom), i = c.contentDOM || c.dom);
          }
        }
        i.appendChild(this.serializeNodeInner(o, t));
      }), r;
    }
    serializeNodeInner(e, t) {
      let { dom: r, contentDOM: i } = js(da(t), this.nodes[e.type.name](e), null, e.attrs);
      if (i) {
        if (e.isLeaf) throw new RangeError("Content hole not allowed in a leaf node spec");
        this.serializeFragment(e.content, t, i);
      }
      return r;
    }
    serializeNode(e, t = {}) {
      let r = this.serializeNodeInner(e, t);
      for (let i = e.marks.length - 1; i >= 0; i--) {
        let s = this.serializeMark(e.marks[i], e.isInline, t);
        s && ((s.contentDOM || s.dom).appendChild(r), r = s.dom);
      }
      return r;
    }
    serializeMark(e, t, r = {}) {
      let i = this.marks[e.type.name];
      return i && js(da(r), i(e, t), null, e.attrs);
    }
    static renderSpec(e, t, r = null, i) {
      return js(e, t, r, i);
    }
    static fromSchema(e) {
      return e.cached.domSerializer || (e.cached.domSerializer = new Vr(this.nodesFromSchema(e), this.marksFromSchema(e)));
    }
    static nodesFromSchema(e) {
      let t = kc(e.nodes);
      return t.text || (t.text = (r) => r.text), t;
    }
    static marksFromSchema(e) {
      return kc(e.marks);
    }
  }
  function kc(n) {
    let e = {};
    for (let t in n) {
      let r = n[t].spec.toDOM;
      r && (e[t] = r);
    }
    return e;
  }
  function da(n) {
    return n.document || window.document;
  }
  const Sc = /* @__PURE__ */ new WeakMap();
  function S1(n) {
    let e = Sc.get(n);
    return e === void 0 && Sc.set(n, e = T1(n)), e;
  }
  function T1(n) {
    let e = null;
    function t(r) {
      if (r && typeof r == "object") if (Array.isArray(r)) if (typeof r[0] == "string") e || (e = []), e.push(r);
      else for (let i = 0; i < r.length; i++) t(r[i]);
      else for (let i in r) t(r[i]);
    }
    return t(n), e;
  }
  function js(n, e, t, r) {
    if (typeof e == "string") return {
      dom: n.createTextNode(e)
    };
    if (e.nodeType != null) return {
      dom: e
    };
    if (e.dom && e.dom.nodeType != null) return e;
    let i = e[0], s;
    if (typeof i != "string") throw new RangeError("Invalid array passed to renderSpec");
    if (r && (s = S1(r)) && s.indexOf(e) > -1) throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
    let o = i.indexOf(" ");
    o > 0 && (t = i.slice(0, o), i = i.slice(o + 1));
    let a, u = t ? n.createElementNS(t, i) : n.createElement(i), l = e[1], c = 1;
    if (l && typeof l == "object" && l.nodeType == null && !Array.isArray(l)) {
      c = 2;
      for (let h in l) if (l[h] != null) {
        let d = h.indexOf(" ");
        d > 0 ? u.setAttributeNS(h.slice(0, d), h.slice(d + 1), l[h]) : u.setAttribute(h, l[h]);
      }
    }
    for (let h = c; h < e.length; h++) {
      let d = e[h];
      if (d === 0) {
        if (h < e.length - 1 || h > c) throw new RangeError("Content hole must be the only child of its parent node");
        return {
          dom: u,
          contentDOM: u
        };
      } else {
        let { dom: f, contentDOM: p } = js(n, d, t, r);
        if (u.appendChild(f), p) {
          if (a) throw new RangeError("Multiple content holes");
          a = p;
        }
      }
    }
    return {
      dom: u,
      contentDOM: a
    };
  }
  const sp = 65535, op = Math.pow(2, 16);
  function E1(n, e) {
    return n + e * op;
  }
  function Tc(n) {
    return n & sp;
  }
  function C1(n) {
    return (n - (n & sp)) / op;
  }
  const ap = 1, up = 2, qs = 4, lp = 8;
  class Pu {
    constructor(e, t, r) {
      this.pos = e, this.delInfo = t, this.recover = r;
    }
    get deleted() {
      return (this.delInfo & lp) > 0;
    }
    get deletedBefore() {
      return (this.delInfo & (ap | qs)) > 0;
    }
    get deletedAfter() {
      return (this.delInfo & (up | qs)) > 0;
    }
    get deletedAcross() {
      return (this.delInfo & qs) > 0;
    }
  }
  class Ht {
    constructor(e, t = false) {
      if (this.ranges = e, this.inverted = t, !e.length && Ht.empty) return Ht.empty;
    }
    recover(e) {
      let t = 0, r = Tc(e);
      if (!this.inverted) for (let i = 0; i < r; i++) t += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
      return this.ranges[r * 3] + t + C1(e);
    }
    mapResult(e, t = 1) {
      return this._map(e, t, false);
    }
    map(e, t = 1) {
      return this._map(e, t, true);
    }
    _map(e, t, r) {
      let i = 0, s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
      for (let a = 0; a < this.ranges.length; a += 3) {
        let u = this.ranges[a] - (this.inverted ? i : 0);
        if (u > e) break;
        let l = this.ranges[a + s], c = this.ranges[a + o], h = u + l;
        if (e <= h) {
          let d = l ? e == u ? -1 : e == h ? 1 : t : t, f = u + i + (d < 0 ? 0 : c);
          if (r) return f;
          let p = e == (t < 0 ? u : h) ? null : E1(a / 3, e - u), m = e == u ? up : e == h ? ap : qs;
          return (t < 0 ? e != u : e != h) && (m |= lp), new Pu(f, m, p);
        }
        i += c - l;
      }
      return r ? e + i : new Pu(e + i, 0, null);
    }
    touches(e, t) {
      let r = 0, i = Tc(t), s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
      for (let a = 0; a < this.ranges.length; a += 3) {
        let u = this.ranges[a] - (this.inverted ? r : 0);
        if (u > e) break;
        let l = this.ranges[a + s], c = u + l;
        if (e <= c && a == i * 3) return true;
        r += this.ranges[a + o] - l;
      }
      return false;
    }
    forEach(e) {
      let t = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
      for (let i = 0, s = 0; i < this.ranges.length; i += 3) {
        let o = this.ranges[i], a = o - (this.inverted ? s : 0), u = o + (this.inverted ? 0 : s), l = this.ranges[i + t], c = this.ranges[i + r];
        e(a, a + l, u, u + c), s += c - l;
      }
    }
    invert() {
      return new Ht(this.ranges, !this.inverted);
    }
    toString() {
      return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
    }
    static offset(e) {
      return e == 0 ? Ht.empty : new Ht(e < 0 ? [
        0,
        -e,
        0
      ] : [
        0,
        0,
        e
      ]);
    }
  }
  Ht.empty = new Ht([]);
  class Vi {
    constructor(e, t, r = 0, i = e ? e.length : 0) {
      this.mirror = t, this.from = r, this.to = i, this._maps = e || [], this.ownData = !(e || t);
    }
    get maps() {
      return this._maps;
    }
    slice(e = 0, t = this.maps.length) {
      return new Vi(this._maps, this.mirror, e, t);
    }
    appendMap(e, t) {
      this.ownData || (this._maps = this._maps.slice(), this.mirror = this.mirror && this.mirror.slice(), this.ownData = true), this.to = this._maps.push(e), t != null && this.setMirror(this._maps.length - 1, t);
    }
    appendMapping(e) {
      for (let t = 0, r = this._maps.length; t < e._maps.length; t++) {
        let i = e.getMirror(t);
        this.appendMap(e._maps[t], i != null && i < t ? r + i : void 0);
      }
    }
    getMirror(e) {
      if (this.mirror) {
        for (let t = 0; t < this.mirror.length; t++) if (this.mirror[t] == e) return this.mirror[t + (t % 2 ? -1 : 1)];
      }
    }
    setMirror(e, t) {
      this.mirror || (this.mirror = []), this.mirror.push(e, t);
    }
    appendMappingInverted(e) {
      for (let t = e.maps.length - 1, r = this._maps.length + e._maps.length; t >= 0; t--) {
        let i = e.getMirror(t);
        this.appendMap(e._maps[t].invert(), i != null && i > t ? r - i - 1 : void 0);
      }
    }
    invert() {
      let e = new Vi();
      return e.appendMappingInverted(this), e;
    }
    map(e, t = 1) {
      if (this.mirror) return this._map(e, t, true);
      for (let r = this.from; r < this.to; r++) e = this._maps[r].map(e, t);
      return e;
    }
    mapResult(e, t = 1) {
      return this._map(e, t, false);
    }
    _map(e, t, r) {
      let i = 0;
      for (let s = this.from; s < this.to; s++) {
        let o = this._maps[s], a = o.mapResult(e, t);
        if (a.recover != null) {
          let u = this.getMirror(s);
          if (u != null && u > s && u < this.to) {
            s = u, e = this._maps[u].recover(a.recover);
            continue;
          }
        }
        i |= a.delInfo, e = a.pos;
      }
      return r ? e : new Pu(e, i, null);
    }
  }
  const fa = /* @__PURE__ */ Object.create(null);
  class Pt {
    getMap() {
      return Ht.empty;
    }
    merge(e) {
      return null;
    }
    static fromJSON(e, t) {
      if (!t || !t.stepType) throw new RangeError("Invalid input for Step.fromJSON");
      let r = fa[t.stepType];
      if (!r) throw new RangeError(`No step type ${t.stepType} defined`);
      return r.fromJSON(e, t);
    }
    static jsonID(e, t) {
      if (e in fa) throw new RangeError("Duplicate use of step JSON ID " + e);
      return fa[e] = t, t.prototype.jsonID = e, t;
    }
  }
  class mt {
    constructor(e, t) {
      this.doc = e, this.failed = t;
    }
    static ok(e) {
      return new mt(e, null);
    }
    static fail(e) {
      return new mt(null, e);
    }
    static fromReplace(e, t, r, i) {
      try {
        return mt.ok(e.replace(t, r, i));
      } catch (s) {
        if (s instanceof Zs) return mt.fail(s.message);
        throw s;
      }
    }
  }
  function cl(n, e, t) {
    let r = [];
    for (let i = 0; i < n.childCount; i++) {
      let s = n.child(i);
      s.content.size && (s = s.copy(cl(s.content, e, s))), s.isInline && (s = e(s, t, i)), r.push(s);
    }
    return G.fromArray(r);
  }
  class tr extends Pt {
    constructor(e, t, r) {
      super(), this.from = e, this.to = t, this.mark = r;
    }
    apply(e) {
      let t = e.slice(this.from, this.to), r = e.resolve(this.from), i = r.node(r.sharedDepth(this.to)), s = new re(cl(t.content, (o, a) => !o.isAtom || !a.type.allowsMarkType(this.mark.type) ? o : o.mark(this.mark.addToSet(o.marks)), i), t.openStart, t.openEnd);
      return mt.fromReplace(e, this.from, this.to, s);
    }
    invert() {
      return new Tn(this.from, this.to, this.mark);
    }
    map(e) {
      let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
      return t.deleted && r.deleted || t.pos >= r.pos ? null : new tr(t.pos, r.pos, this.mark);
    }
    merge(e) {
      return e instanceof tr && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new tr(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
    }
    toJSON() {
      return {
        stepType: "addMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    }
    static fromJSON(e, t) {
      if (typeof t.from != "number" || typeof t.to != "number") throw new RangeError("Invalid input for AddMarkStep.fromJSON");
      return new tr(t.from, t.to, e.markFromJSON(t.mark));
    }
  }
  Pt.jsonID("addMark", tr);
  class Tn extends Pt {
    constructor(e, t, r) {
      super(), this.from = e, this.to = t, this.mark = r;
    }
    apply(e) {
      let t = e.slice(this.from, this.to), r = new re(cl(t.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), e), t.openStart, t.openEnd);
      return mt.fromReplace(e, this.from, this.to, r);
    }
    invert() {
      return new tr(this.from, this.to, this.mark);
    }
    map(e) {
      let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
      return t.deleted && r.deleted || t.pos >= r.pos ? null : new Tn(t.pos, r.pos, this.mark);
    }
    merge(e) {
      return e instanceof Tn && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Tn(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
    }
    toJSON() {
      return {
        stepType: "removeMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    }
    static fromJSON(e, t) {
      if (typeof t.from != "number" || typeof t.to != "number") throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
      return new Tn(t.from, t.to, e.markFromJSON(t.mark));
    }
  }
  Pt.jsonID("removeMark", Tn);
  class nr extends Pt {
    constructor(e, t) {
      super(), this.pos = e, this.mark = t;
    }
    apply(e) {
      let t = e.nodeAt(this.pos);
      if (!t) return mt.fail("No node at mark step's position");
      let r = t.type.create(t.attrs, null, this.mark.addToSet(t.marks));
      return mt.fromReplace(e, this.pos, this.pos + 1, new re(G.from(r), 0, t.isLeaf ? 0 : 1));
    }
    invert(e) {
      let t = e.nodeAt(this.pos);
      if (t) {
        let r = this.mark.addToSet(t.marks);
        if (r.length == t.marks.length) {
          for (let i = 0; i < t.marks.length; i++) if (!t.marks[i].isInSet(r)) return new nr(this.pos, t.marks[i]);
          return new nr(this.pos, this.mark);
        }
      }
      return new ai(this.pos, this.mark);
    }
    map(e) {
      let t = e.mapResult(this.pos, 1);
      return t.deletedAfter ? null : new nr(t.pos, this.mark);
    }
    toJSON() {
      return {
        stepType: "addNodeMark",
        pos: this.pos,
        mark: this.mark.toJSON()
      };
    }
    static fromJSON(e, t) {
      if (typeof t.pos != "number") throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
      return new nr(t.pos, e.markFromJSON(t.mark));
    }
  }
  Pt.jsonID("addNodeMark", nr);
  class ai extends Pt {
    constructor(e, t) {
      super(), this.pos = e, this.mark = t;
    }
    apply(e) {
      let t = e.nodeAt(this.pos);
      if (!t) return mt.fail("No node at mark step's position");
      let r = t.type.create(t.attrs, null, this.mark.removeFromSet(t.marks));
      return mt.fromReplace(e, this.pos, this.pos + 1, new re(G.from(r), 0, t.isLeaf ? 0 : 1));
    }
    invert(e) {
      let t = e.nodeAt(this.pos);
      return !t || !this.mark.isInSet(t.marks) ? this : new nr(this.pos, this.mark);
    }
    map(e) {
      let t = e.mapResult(this.pos, 1);
      return t.deletedAfter ? null : new ai(t.pos, this.mark);
    }
    toJSON() {
      return {
        stepType: "removeNodeMark",
        pos: this.pos,
        mark: this.mark.toJSON()
      };
    }
    static fromJSON(e, t) {
      if (typeof t.pos != "number") throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
      return new ai(t.pos, e.markFromJSON(t.mark));
    }
  }
  Pt.jsonID("removeNodeMark", ai);
  class xt extends Pt {
    constructor(e, t, r, i = false) {
      super(), this.from = e, this.to = t, this.slice = r, this.structure = i;
    }
    apply(e) {
      return this.structure && Du(e, this.from, this.to) ? mt.fail("Structure replace would overwrite content") : mt.fromReplace(e, this.from, this.to, this.slice);
    }
    getMap() {
      return new Ht([
        this.from,
        this.to - this.from,
        this.slice.size
      ]);
    }
    invert(e) {
      return new xt(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
    }
    map(e) {
      let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
      return t.deletedAcross && r.deletedAcross ? null : new xt(t.pos, Math.max(t.pos, r.pos), this.slice);
    }
    merge(e) {
      if (!(e instanceof xt) || e.structure || this.structure) return null;
      if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
        let t = this.slice.size + e.slice.size == 0 ? re.empty : new re(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
        return new xt(this.from, this.to + (e.to - e.from), t, this.structure);
      } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
        let t = this.slice.size + e.slice.size == 0 ? re.empty : new re(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
        return new xt(e.from, this.to, t, this.structure);
      } else return null;
    }
    toJSON() {
      let e = {
        stepType: "replace",
        from: this.from,
        to: this.to
      };
      return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = true), e;
    }
    static fromJSON(e, t) {
      if (typeof t.from != "number" || typeof t.to != "number") throw new RangeError("Invalid input for ReplaceStep.fromJSON");
      return new xt(t.from, t.to, re.fromJSON(e, t.slice), !!t.structure);
    }
  }
  Pt.jsonID("replace", xt);
  class kt extends Pt {
    constructor(e, t, r, i, s, o, a = false) {
      super(), this.from = e, this.to = t, this.gapFrom = r, this.gapTo = i, this.slice = s, this.insert = o, this.structure = a;
    }
    apply(e) {
      if (this.structure && (Du(e, this.from, this.gapFrom) || Du(e, this.gapTo, this.to))) return mt.fail("Structure gap-replace would overwrite content");
      let t = e.slice(this.gapFrom, this.gapTo);
      if (t.openStart || t.openEnd) return mt.fail("Gap is not a flat range");
      let r = this.slice.insertAt(this.insert, t.content);
      return r ? mt.fromReplace(e, this.from, this.to, r) : mt.fail("Content does not fit in gap");
    }
    getMap() {
      return new Ht([
        this.from,
        this.gapFrom - this.from,
        this.insert,
        this.gapTo,
        this.to - this.gapTo,
        this.slice.size - this.insert
      ]);
    }
    invert(e) {
      let t = this.gapTo - this.gapFrom;
      return new kt(this.from, this.from + this.slice.size + t, this.from + this.insert, this.from + this.insert + t, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
    }
    map(e) {
      let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), i = this.from == this.gapFrom ? t.pos : e.map(this.gapFrom, -1), s = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1);
      return t.deletedAcross && r.deletedAcross || i < t.pos || s > r.pos ? null : new kt(t.pos, r.pos, i, s, this.slice, this.insert, this.structure);
    }
    toJSON() {
      let e = {
        stepType: "replaceAround",
        from: this.from,
        to: this.to,
        gapFrom: this.gapFrom,
        gapTo: this.gapTo,
        insert: this.insert
      };
      return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = true), e;
    }
    static fromJSON(e, t) {
      if (typeof t.from != "number" || typeof t.to != "number" || typeof t.gapFrom != "number" || typeof t.gapTo != "number" || typeof t.insert != "number") throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
      return new kt(t.from, t.to, t.gapFrom, t.gapTo, re.fromJSON(e, t.slice), t.insert, !!t.structure);
    }
  }
  Pt.jsonID("replaceAround", kt);
  function Du(n, e, t) {
    let r = n.resolve(e), i = t - e, s = r.depth;
    for (; i > 0 && s > 0 && r.indexAfter(s) == r.node(s).childCount; ) s--, i--;
    if (i > 0) {
      let o = r.node(s).maybeChild(r.indexAfter(s));
      for (; i > 0; ) {
        if (!o || o.isLeaf) return true;
        o = o.firstChild, i--;
      }
    }
    return false;
  }
  function O1(n, e, t, r) {
    let i = [], s = [], o, a;
    n.doc.nodesBetween(e, t, (u, l, c) => {
      if (!u.isInline) return;
      let h = u.marks;
      if (!r.isInSet(h) && c.type.allowsMarkType(r.type)) {
        let d = Math.max(l, e), f = Math.min(l + u.nodeSize, t), p = r.addToSet(h);
        for (let m = 0; m < h.length; m++) h[m].isInSet(p) || (o && o.to == d && o.mark.eq(h[m]) ? o.to = f : i.push(o = new Tn(d, f, h[m])));
        a && a.to == d ? a.to = f : s.push(a = new tr(d, f, r));
      }
    }), i.forEach((u) => n.step(u)), s.forEach((u) => n.step(u));
  }
  function A1(n, e, t, r) {
    let i = [], s = 0;
    n.doc.nodesBetween(e, t, (o, a) => {
      if (!o.isInline) return;
      s++;
      let u = null;
      if (r instanceof Io) {
        let l = o.marks, c;
        for (; c = r.isInSet(l); ) (u || (u = [])).push(c), l = c.removeFromSet(l);
      } else r ? r.isInSet(o.marks) && (u = [
        r
      ]) : u = o.marks;
      if (u && u.length) {
        let l = Math.min(a + o.nodeSize, t);
        for (let c = 0; c < u.length; c++) {
          let h = u[c], d;
          for (let f = 0; f < i.length; f++) {
            let p = i[f];
            p.step == s - 1 && h.eq(i[f].style) && (d = p);
          }
          d ? (d.to = l, d.step = s) : i.push({
            style: h,
            from: Math.max(a, e),
            to: l,
            step: s
          });
        }
      }
    }), i.forEach((o) => n.step(new Tn(o.from, o.to, o.style)));
  }
  function dl(n, e, t, r = t.contentMatch, i = true) {
    let s = n.doc.nodeAt(e), o = [], a = e + 1;
    for (let u = 0; u < s.childCount; u++) {
      let l = s.child(u), c = a + l.nodeSize, h = r.matchType(l.type);
      if (!h) o.push(new xt(a, c, re.empty));
      else {
        r = h;
        for (let d = 0; d < l.marks.length; d++) t.allowsMarkType(l.marks[d].type) || n.step(new Tn(a, c, l.marks[d]));
        if (i && l.isText && t.whitespace != "pre") {
          let d, f = /\r?\n|\r/g, p;
          for (; d = f.exec(l.text); ) p || (p = new re(G.from(t.schema.text(" ", t.allowedMarks(l.marks))), 0, 0)), o.push(new xt(a + d.index, a + d.index + d[0].length, p));
        }
      }
      a = c;
    }
    if (!r.validEnd) {
      let u = r.fillBefore(G.empty, true);
      n.replace(a, a, new re(u, 0, 0));
    }
    for (let u = o.length - 1; u >= 0; u--) n.step(o[u]);
  }
  function M1(n, e, t) {
    return (e == 0 || n.canReplace(e, n.childCount)) && (t == n.childCount || n.canReplace(0, t));
  }
  function mi(n) {
    let t = n.parent.content.cutByIndex(n.startIndex, n.endIndex);
    for (let r = n.depth; ; --r) {
      let i = n.$from.node(r), s = n.$from.index(r), o = n.$to.indexAfter(r);
      if (r < n.depth && i.canReplace(s, o, t)) return r;
      if (r == 0 || i.type.spec.isolating || !M1(i, s, o)) break;
    }
    return null;
  }
  function N1(n, e, t) {
    let { $from: r, $to: i, depth: s } = e, o = r.before(s + 1), a = i.after(s + 1), u = o, l = a, c = G.empty, h = 0;
    for (let p = s, m = false; p > t; p--) m || r.index(p) > 0 ? (m = true, c = G.from(r.node(p).copy(c)), h++) : u--;
    let d = G.empty, f = 0;
    for (let p = s, m = false; p > t; p--) m || i.after(p + 1) < i.end(p) ? (m = true, d = G.from(i.node(p).copy(d)), f++) : l++;
    n.step(new kt(u, l, o, a, new re(c.append(d), h, f), c.size - h, true));
  }
  function fl(n, e, t = null, r = n) {
    let i = P1(n, e), s = i && D1(r, e);
    return s ? i.map(Ec).concat({
      type: e,
      attrs: t
    }).concat(s.map(Ec)) : null;
  }
  function Ec(n) {
    return {
      type: n,
      attrs: null
    };
  }
  function P1(n, e) {
    let { parent: t, startIndex: r, endIndex: i } = n, s = t.contentMatchAt(r).findWrapping(e);
    if (!s) return null;
    let o = s.length ? s[0] : e;
    return t.canReplaceWith(r, i, o) ? s : null;
  }
  function D1(n, e) {
    let { parent: t, startIndex: r, endIndex: i } = n, s = t.child(r), o = e.contentMatch.findWrapping(s.type);
    if (!o) return null;
    let u = (o.length ? o[o.length - 1] : e).contentMatch;
    for (let l = r; u && l < i; l++) u = u.matchType(t.child(l).type);
    return !u || !u.validEnd ? null : o;
  }
  function I1(n, e, t) {
    let r = G.empty;
    for (let o = t.length - 1; o >= 0; o--) {
      if (r.size) {
        let a = t[o].type.contentMatch.matchFragment(r);
        if (!a || !a.validEnd) throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
      }
      r = G.from(t[o].type.create(t[o].attrs, r));
    }
    let i = e.start, s = e.end;
    n.step(new kt(i, s, i, s, new re(r, 0, 0), t.length, true));
  }
  function R1(n, e, t, r, i) {
    if (!r.isTextblock) throw new RangeError("Type given to setBlockType should be a textblock");
    let s = n.steps.length;
    n.doc.nodesBetween(e, t, (o, a) => {
      let u = typeof i == "function" ? i(o) : i;
      if (o.isTextblock && !o.hasMarkup(r, u) && _1(n.doc, n.mapping.slice(s).map(a), r)) {
        let l = null;
        if (r.schema.linebreakReplacement) {
          let f = r.whitespace == "pre", p = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
          f && !p ? l = false : !f && p && (l = true);
        }
        l === false && dp(n, o, a, s), dl(n, n.mapping.slice(s).map(a, 1), r, void 0, l === null);
        let c = n.mapping.slice(s), h = c.map(a, 1), d = c.map(a + o.nodeSize, 1);
        return n.step(new kt(h, d, h + 1, d - 1, new re(G.from(r.create(u, null, o.marks)), 0, 0), 1, true)), l === true && cp(n, o, a, s), false;
      }
    });
  }
  function cp(n, e, t, r) {
    e.forEach((i, s) => {
      if (i.isText) {
        let o, a = /\r?\n|\r/g;
        for (; o = a.exec(i.text); ) {
          let u = n.mapping.slice(r).map(t + 1 + s + o.index);
          n.replaceWith(u, u + 1, e.type.schema.linebreakReplacement.create());
        }
      }
    });
  }
  function dp(n, e, t, r) {
    e.forEach((i, s) => {
      if (i.type == i.type.schema.linebreakReplacement) {
        let o = n.mapping.slice(r).map(t + 1 + s);
        n.replaceWith(o, o + 1, e.type.schema.text(`
`));
      }
    });
  }
  function _1(n, e, t) {
    let r = n.resolve(e), i = r.index();
    return r.parent.canReplaceWith(i, i + 1, t);
  }
  function L1(n, e, t, r, i) {
    let s = n.doc.nodeAt(e);
    if (!s) throw new RangeError("No node at given position");
    t || (t = s.type);
    let o = t.create(r, null, i || s.marks);
    if (s.isLeaf) return n.replaceWith(e, e + s.nodeSize, o);
    if (!t.validContent(s.content)) throw new RangeError("Invalid content for node type " + t.name);
    n.step(new kt(e, e + s.nodeSize, e + 1, e + s.nodeSize - 1, new re(G.from(o), 0, 0), 1, true));
  }
  function jn(n, e, t = 1, r) {
    let i = n.resolve(e), s = i.depth - t, o = r && r[r.length - 1] || i.parent;
    if (s < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !o.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount))) return false;
    for (let l = i.depth - 1, c = t - 2; l > s; l--, c--) {
      let h = i.node(l), d = i.index(l);
      if (h.type.spec.isolating) return false;
      let f = h.content.cutByIndex(d, h.childCount), p = r && r[c + 1];
      p && (f = f.replaceChild(0, p.type.create(p.attrs)));
      let m = r && r[c] || h;
      if (!h.canReplace(d + 1, h.childCount) || !m.type.validContent(f)) return false;
    }
    let a = i.indexAfter(s), u = r && r[0];
    return i.node(s).canReplaceWith(a, a, u ? u.type : i.node(s + 1).type);
  }
  function B1(n, e, t = 1, r) {
    let i = n.doc.resolve(e), s = G.empty, o = G.empty;
    for (let a = i.depth, u = i.depth - t, l = t - 1; a > u; a--, l--) {
      s = G.from(i.node(a).copy(s));
      let c = r && r[l];
      o = G.from(c ? c.type.create(c.attrs, o) : i.node(a).copy(o));
    }
    n.step(new xt(e, e, new re(s.append(o), t, t), true));
  }
  function hr(n, e) {
    let t = n.resolve(e), r = t.index();
    return fp(t.nodeBefore, t.nodeAfter) && t.parent.canReplace(r, r + 1);
  }
  function F1(n, e) {
    e.content.size || n.type.compatibleContent(e.type);
    let t = n.contentMatchAt(n.childCount), { linebreakReplacement: r } = n.type.schema;
    for (let i = 0; i < e.childCount; i++) {
      let s = e.child(i), o = s.type == r ? n.type.schema.nodes.text : s.type;
      if (t = t.matchType(o), !t || !n.type.allowsMarks(s.marks)) return false;
    }
    return t.validEnd;
  }
  function fp(n, e) {
    return !!(n && e && !n.isLeaf && F1(n, e));
  }
  function Ro(n, e, t = -1) {
    let r = n.resolve(e);
    for (let i = r.depth; ; i--) {
      let s, o, a = r.index(i);
      if (i == r.depth ? (s = r.nodeBefore, o = r.nodeAfter) : t > 0 ? (s = r.node(i + 1), a++, o = r.node(i).maybeChild(a)) : (s = r.node(i).maybeChild(a - 1), o = r.node(i + 1)), s && !s.isTextblock && fp(s, o) && r.node(i).canReplace(a, a + 1)) return e;
      if (i == 0) break;
      e = t < 0 ? r.before(i) : r.after(i);
    }
  }
  function z1(n, e, t) {
    let r = null, { linebreakReplacement: i } = n.doc.type.schema, s = n.doc.resolve(e - t), o = s.node().type;
    if (i && o.inlineContent) {
      let c = o.whitespace == "pre", h = !!o.contentMatch.matchType(i);
      c && !h ? r = false : !c && h && (r = true);
    }
    let a = n.steps.length;
    if (r === false) {
      let c = n.doc.resolve(e + t);
      dp(n, c.node(), c.before(), a);
    }
    o.inlineContent && dl(n, e + t - 1, o, s.node().contentMatchAt(s.index()), r == null);
    let u = n.mapping.slice(a), l = u.map(e - t);
    if (n.step(new xt(l, u.map(e + t, -1), re.empty, true)), r === true) {
      let c = n.doc.resolve(l);
      cp(n, c.node(), c.before(), n.steps.length);
    }
    return n;
  }
  function j1(n, e, t) {
    let r = n.resolve(e);
    if (r.parent.canReplaceWith(r.index(), r.index(), t)) return e;
    if (r.parentOffset == 0) for (let i = r.depth - 1; i >= 0; i--) {
      let s = r.index(i);
      if (r.node(i).canReplaceWith(s, s, t)) return r.before(i + 1);
      if (s > 0) return null;
    }
    if (r.parentOffset == r.parent.content.size) for (let i = r.depth - 1; i >= 0; i--) {
      let s = r.indexAfter(i);
      if (r.node(i).canReplaceWith(s, s, t)) return r.after(i + 1);
      if (s < r.node(i).childCount) return null;
    }
    return null;
  }
  function hp(n, e, t) {
    let r = n.resolve(e);
    if (!t.content.size) return e;
    let i = t.content;
    for (let s = 0; s < t.openStart; s++) i = i.firstChild.content;
    for (let s = 1; s <= (t.openStart == 0 && t.size ? 2 : 1); s++) for (let o = r.depth; o >= 0; o--) {
      let a = o == r.depth ? 0 : r.pos <= (r.start(o + 1) + r.end(o + 1)) / 2 ? -1 : 1, u = r.index(o) + (a > 0 ? 1 : 0), l = r.node(o), c = false;
      if (s == 1) c = l.canReplace(u, u, i);
      else {
        let h = l.contentMatchAt(u).findWrapping(i.firstChild.type);
        c = h && l.canReplaceWith(u, u, h[0]);
      }
      if (c) return a == 0 ? r.pos : a < 0 ? r.before(o + 1) : r.after(o + 1);
    }
    return null;
  }
  function _o(n, e, t = e, r = re.empty) {
    if (e == t && !r.size) return null;
    let i = n.resolve(e), s = n.resolve(t);
    return pp(i, s, r) ? new xt(e, t, r) : new q1(i, s, r).fit();
  }
  function pp(n, e, t) {
    return !t.openStart && !t.openEnd && n.start() == e.start() && n.parent.canReplace(n.index(), e.index(), t.content);
  }
  class q1 {
    constructor(e, t, r) {
      this.$from = e, this.$to = t, this.unplaced = r, this.frontier = [], this.placed = G.empty;
      for (let i = 0; i <= e.depth; i++) {
        let s = e.node(i);
        this.frontier.push({
          type: s.type,
          match: s.contentMatchAt(e.indexAfter(i))
        });
      }
      for (let i = e.depth; i > 0; i--) this.placed = G.from(e.node(i).copy(this.placed));
    }
    get depth() {
      return this.frontier.length - 1;
    }
    fit() {
      for (; this.unplaced.size; ) {
        let l = this.findFittable();
        l ? this.placeNodes(l) : this.openMore() || this.dropNode();
      }
      let e = this.mustMoveInline(), t = this.placed.size - this.depth - this.$from.depth, r = this.$from, i = this.close(e < 0 ? this.$to : r.doc.resolve(e));
      if (!i) return null;
      let s = this.placed, o = r.depth, a = i.depth;
      for (; o && a && s.childCount == 1; ) s = s.firstChild.content, o--, a--;
      let u = new re(s, o, a);
      return e > -1 ? new kt(r.pos, e, this.$to.pos, this.$to.end(), u, t) : u.size || r.pos != this.$to.pos ? new xt(r.pos, i.pos, u) : null;
    }
    findFittable() {
      let e = this.unplaced.openStart;
      for (let t = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < e; r++) {
        let s = t.firstChild;
        if (t.childCount > 1 && (i = 0), s.type.spec.isolating && i <= r) {
          e = r;
          break;
        }
        t = s.content;
      }
      for (let t = 1; t <= 2; t++) for (let r = t == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
        let i, s = null;
        r ? (s = ha(this.unplaced.content, r - 1).firstChild, i = s.content) : i = this.unplaced.content;
        let o = i.firstChild;
        for (let a = this.depth; a >= 0; a--) {
          let { type: u, match: l } = this.frontier[a], c, h = null;
          if (t == 1 && (o ? l.matchType(o.type) || (h = l.fillBefore(G.from(o), false)) : s && u.compatibleContent(s.type))) return {
            sliceDepth: r,
            frontierDepth: a,
            parent: s,
            inject: h
          };
          if (t == 2 && o && (c = l.findWrapping(o.type))) return {
            sliceDepth: r,
            frontierDepth: a,
            parent: s,
            wrap: c
          };
          if (s && l.matchType(s.type)) break;
        }
      }
    }
    openMore() {
      let { content: e, openStart: t, openEnd: r } = this.unplaced, i = ha(e, t);
      return !i.childCount || i.firstChild.isLeaf ? false : (this.unplaced = new re(e, t + 1, Math.max(r, i.size + t >= e.size - r ? t + 1 : 0)), true);
    }
    dropNode() {
      let { content: e, openStart: t, openEnd: r } = this.unplaced, i = ha(e, t);
      if (i.childCount <= 1 && t > 0) {
        let s = e.size - t <= t + i.size;
        this.unplaced = new re(Ni(e, t - 1, 1), t - 1, s ? t - 1 : r);
      } else this.unplaced = new re(Ni(e, t, 1), t, r);
    }
    placeNodes({ sliceDepth: e, frontierDepth: t, parent: r, inject: i, wrap: s }) {
      for (; this.depth > t; ) this.closeFrontierNode();
      if (s) for (let m = 0; m < s.length; m++) this.openFrontierNode(s[m]);
      let o = this.unplaced, a = r ? r.content : o.content, u = o.openStart - e, l = 0, c = [], { match: h, type: d } = this.frontier[t];
      if (i) {
        for (let m = 0; m < i.childCount; m++) c.push(i.child(m));
        h = h.matchFragment(i);
      }
      let f = a.size + e - (o.content.size - o.openEnd);
      for (; l < a.childCount; ) {
        let m = a.child(l), b = h.matchType(m.type);
        if (!b) break;
        l++, (l > 1 || u == 0 || m.content.size) && (h = b, c.push(mp(m.mark(d.allowedMarks(m.marks)), l == 1 ? u : 0, l == a.childCount ? f : -1)));
      }
      let p = l == a.childCount;
      p || (f = -1), this.placed = Pi(this.placed, t, G.from(c)), this.frontier[t].match = h, p && f < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
      for (let m = 0, b = a; m < f; m++) {
        let g = b.lastChild;
        this.frontier.push({
          type: g.type,
          match: g.contentMatchAt(g.childCount)
        }), b = g.content;
      }
      this.unplaced = p ? e == 0 ? re.empty : new re(Ni(o.content, e - 1, 1), e - 1, f < 0 ? o.openEnd : e - 1) : new re(Ni(o.content, e, l), o.openStart, o.openEnd);
    }
    mustMoveInline() {
      if (!this.$to.parent.isTextblock) return -1;
      let e = this.frontier[this.depth], t;
      if (!e.type.isTextblock || !pa(this.$to, this.$to.depth, e.type, e.match, false) || this.$to.depth == this.depth && (t = this.findCloseLevel(this.$to)) && t.depth == this.depth) return -1;
      let { depth: r } = this.$to, i = this.$to.after(r);
      for (; r > 1 && i == this.$to.end(--r); ) ++i;
      return i;
    }
    findCloseLevel(e) {
      e: for (let t = Math.min(this.depth, e.depth); t >= 0; t--) {
        let { match: r, type: i } = this.frontier[t], s = t < e.depth && e.end(t + 1) == e.pos + (e.depth - (t + 1)), o = pa(e, t, i, r, s);
        if (o) {
          for (let a = t - 1; a >= 0; a--) {
            let { match: u, type: l } = this.frontier[a], c = pa(e, a, l, u, true);
            if (!c || c.childCount) continue e;
          }
          return {
            depth: t,
            fit: o,
            move: s ? e.doc.resolve(e.after(t + 1)) : e
          };
        }
      }
    }
    close(e) {
      let t = this.findCloseLevel(e);
      if (!t) return null;
      for (; this.depth > t.depth; ) this.closeFrontierNode();
      t.fit.childCount && (this.placed = Pi(this.placed, t.depth, t.fit)), e = t.move;
      for (let r = t.depth + 1; r <= e.depth; r++) {
        let i = e.node(r), s = i.type.contentMatch.fillBefore(i.content, true, e.index(r));
        this.openFrontierNode(i.type, i.attrs, s);
      }
      return e;
    }
    openFrontierNode(e, t = null, r) {
      let i = this.frontier[this.depth];
      i.match = i.match.matchType(e), this.placed = Pi(this.placed, this.depth, G.from(e.create(t, r))), this.frontier.push({
        type: e,
        match: e.contentMatch
      });
    }
    closeFrontierNode() {
      let t = this.frontier.pop().match.fillBefore(G.empty, true);
      t.childCount && (this.placed = Pi(this.placed, this.frontier.length, t));
    }
  }
  function Ni(n, e, t) {
    return e == 0 ? n.cutByIndex(t, n.childCount) : n.replaceChild(0, n.firstChild.copy(Ni(n.firstChild.content, e - 1, t)));
  }
  function Pi(n, e, t) {
    return e == 0 ? n.append(t) : n.replaceChild(n.childCount - 1, n.lastChild.copy(Pi(n.lastChild.content, e - 1, t)));
  }
  function ha(n, e) {
    for (let t = 0; t < e; t++) n = n.firstChild.content;
    return n;
  }
  function mp(n, e, t) {
    if (e <= 0) return n;
    let r = n.content;
    return e > 1 && (r = r.replaceChild(0, mp(r.firstChild, e - 1, r.childCount == 1 ? t - 1 : 0))), e > 0 && (r = n.type.contentMatch.fillBefore(r).append(r), t <= 0 && (r = r.append(n.type.contentMatch.matchFragment(r).fillBefore(G.empty, true)))), n.copy(r);
  }
  function pa(n, e, t, r, i) {
    let s = n.node(e), o = i ? n.indexAfter(e) : n.index(e);
    if (o == s.childCount && !t.compatibleContent(s.type)) return null;
    let a = r.fillBefore(s.content, true, o);
    return a && !$1(t, s.content, o) ? a : null;
  }
  function $1(n, e, t) {
    for (let r = t; r < e.childCount; r++) if (!n.allowsMarks(e.child(r).marks)) return true;
    return false;
  }
  function V1(n) {
    return n.spec.defining || n.spec.definingForContent;
  }
  function H1(n, e, t, r) {
    if (!r.size) return n.deleteRange(e, t);
    let i = n.doc.resolve(e), s = n.doc.resolve(t);
    if (pp(i, s, r)) return n.step(new xt(e, t, r));
    let o = bp(i, n.doc.resolve(t));
    o[o.length - 1] == 0 && o.pop();
    let a = -(i.depth + 1);
    o.unshift(a);
    for (let d = i.depth, f = i.pos - 1; d > 0; d--, f--) {
      let p = i.node(d).type.spec;
      if (p.defining || p.definingAsContext || p.isolating) break;
      o.indexOf(d) > -1 ? a = d : i.before(d) == f && o.splice(1, 0, -d);
    }
    let u = o.indexOf(a), l = [], c = r.openStart;
    for (let d = r.content, f = 0; ; f++) {
      let p = d.firstChild;
      if (l.push(p), f == r.openStart) break;
      d = p.content;
    }
    for (let d = c - 1; d >= 0; d--) {
      let f = l[d], p = V1(f.type);
      if (p && !f.sameMarkup(i.node(Math.abs(a) - 1))) c = d;
      else if (p || !f.type.isTextblock) break;
    }
    for (let d = r.openStart; d >= 0; d--) {
      let f = (d + c + 1) % (r.openStart + 1), p = l[f];
      if (p) for (let m = 0; m < o.length; m++) {
        let b = o[(m + u) % o.length], g = true;
        b < 0 && (g = false, b = -b);
        let w = i.node(b - 1), v = i.index(b - 1);
        if (w.canReplaceWith(v, v, p.type, p.marks)) return n.replace(i.before(b), g ? s.after(b) : t, new re(gp(r.content, 0, r.openStart, f), f, r.openEnd));
      }
    }
    let h = n.steps.length;
    for (let d = o.length - 1; d >= 0 && (n.replace(e, t, r), !(n.steps.length > h)); d--) {
      let f = o[d];
      f < 0 || (e = i.before(f), t = s.after(f));
    }
  }
  function gp(n, e, t, r, i) {
    if (e < t) {
      let s = n.firstChild;
      n = n.replaceChild(0, s.copy(gp(s.content, e + 1, t, r, s)));
    }
    if (e > r) {
      let s = i.contentMatchAt(0), o = s.fillBefore(n).append(n);
      n = o.append(s.matchFragment(o).fillBefore(G.empty, true));
    }
    return n;
  }
  function W1(n, e, t, r) {
    if (!r.isInline && e == t && n.doc.resolve(e).parent.content.size) {
      let i = j1(n.doc, e, r.type);
      i != null && (e = t = i);
    }
    n.replaceRange(e, t, new re(G.from(r), 0, 0));
  }
  function U1(n, e, t) {
    let r = n.doc.resolve(e), i = n.doc.resolve(t), s = bp(r, i);
    for (let o = 0; o < s.length; o++) {
      let a = s[o], u = o == s.length - 1;
      if (u && a == 0 || r.node(a).type.contentMatch.validEnd) return n.delete(r.start(a), i.end(a));
      if (a > 0 && (u || r.node(a - 1).canReplace(r.index(a - 1), i.indexAfter(a - 1)))) return n.delete(r.before(a), i.after(a));
    }
    for (let o = 1; o <= r.depth && o <= i.depth; o++) if (e - r.start(o) == r.depth - o && t > r.end(o) && i.end(o) - t != i.depth - o && r.start(o - 1) == i.start(o - 1) && r.node(o - 1).canReplace(r.index(o - 1), i.index(o - 1))) return n.delete(r.before(o), t);
    n.delete(e, t);
  }
  function bp(n, e) {
    let t = [], r = Math.min(n.depth, e.depth);
    for (let i = r; i >= 0; i--) {
      let s = n.start(i);
      if (s < n.pos - (n.depth - i) || e.end(i) > e.pos + (e.depth - i) || n.node(i).type.spec.isolating || e.node(i).type.spec.isolating) break;
      (s == e.start(i) || i == n.depth && i == e.depth && n.parent.inlineContent && e.parent.inlineContent && i && e.start(i - 1) == s - 1) && t.push(i);
    }
    return t;
  }
  class ti extends Pt {
    constructor(e, t, r) {
      super(), this.pos = e, this.attr = t, this.value = r;
    }
    apply(e) {
      let t = e.nodeAt(this.pos);
      if (!t) return mt.fail("No node at attribute step's position");
      let r = /* @__PURE__ */ Object.create(null);
      for (let s in t.attrs) r[s] = t.attrs[s];
      r[this.attr] = this.value;
      let i = t.type.create(r, null, t.marks);
      return mt.fromReplace(e, this.pos, this.pos + 1, new re(G.from(i), 0, t.isLeaf ? 0 : 1));
    }
    getMap() {
      return Ht.empty;
    }
    invert(e) {
      return new ti(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
    }
    map(e) {
      let t = e.mapResult(this.pos, 1);
      return t.deletedAfter ? null : new ti(t.pos, this.attr, this.value);
    }
    toJSON() {
      return {
        stepType: "attr",
        pos: this.pos,
        attr: this.attr,
        value: this.value
      };
    }
    static fromJSON(e, t) {
      if (typeof t.pos != "number" || typeof t.attr != "string") throw new RangeError("Invalid input for AttrStep.fromJSON");
      return new ti(t.pos, t.attr, t.value);
    }
  }
  Pt.jsonID("attr", ti);
  class Hi extends Pt {
    constructor(e, t) {
      super(), this.attr = e, this.value = t;
    }
    apply(e) {
      let t = /* @__PURE__ */ Object.create(null);
      for (let i in e.attrs) t[i] = e.attrs[i];
      t[this.attr] = this.value;
      let r = e.type.create(t, e.content, e.marks);
      return mt.ok(r);
    }
    getMap() {
      return Ht.empty;
    }
    invert(e) {
      return new Hi(this.attr, e.attrs[this.attr]);
    }
    map(e) {
      return this;
    }
    toJSON() {
      return {
        stepType: "docAttr",
        attr: this.attr,
        value: this.value
      };
    }
    static fromJSON(e, t) {
      if (typeof t.attr != "string") throw new RangeError("Invalid input for DocAttrStep.fromJSON");
      return new Hi(t.attr, t.value);
    }
  }
  Pt.jsonID("docAttr", Hi);
  let ui = class extends Error {
  };
  ui = function n(e) {
    let t = Error.call(this, e);
    return t.__proto__ = n.prototype, t;
  };
  ui.prototype = Object.create(Error.prototype);
  ui.prototype.constructor = ui;
  ui.prototype.name = "TransformError";
  class G1 {
    constructor(e) {
      this.doc = e, this.steps = [], this.docs = [], this.mapping = new Vi();
    }
    get before() {
      return this.docs.length ? this.docs[0] : this.doc;
    }
    step(e) {
      let t = this.maybeStep(e);
      if (t.failed) throw new ui(t.failed);
      return this;
    }
    maybeStep(e) {
      let t = e.apply(this.doc);
      return t.failed || this.addStep(e, t.doc), t;
    }
    get docChanged() {
      return this.steps.length > 0;
    }
    addStep(e, t) {
      this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = t;
    }
    replace(e, t = e, r = re.empty) {
      let i = _o(this.doc, e, t, r);
      return i && this.step(i), this;
    }
    replaceWith(e, t, r) {
      return this.replace(e, t, new re(G.from(r), 0, 0));
    }
    delete(e, t) {
      return this.replace(e, t, re.empty);
    }
    insert(e, t) {
      return this.replaceWith(e, e, t);
    }
    replaceRange(e, t, r) {
      return H1(this, e, t, r), this;
    }
    replaceRangeWith(e, t, r) {
      return W1(this, e, t, r), this;
    }
    deleteRange(e, t) {
      return U1(this, e, t), this;
    }
    lift(e, t) {
      return N1(this, e, t), this;
    }
    join(e, t = 1) {
      return z1(this, e, t), this;
    }
    wrap(e, t) {
      return I1(this, e, t), this;
    }
    setBlockType(e, t = e, r, i = null) {
      return R1(this, e, t, r, i), this;
    }
    setNodeMarkup(e, t, r = null, i) {
      return L1(this, e, t, r, i), this;
    }
    setNodeAttribute(e, t, r) {
      return this.step(new ti(e, t, r)), this;
    }
    setDocAttribute(e, t) {
      return this.step(new Hi(e, t)), this;
    }
    addNodeMark(e, t) {
      return this.step(new nr(e, t)), this;
    }
    removeNodeMark(e, t) {
      if (!(t instanceof Ze)) {
        let r = this.doc.nodeAt(e);
        if (!r) throw new RangeError("No node at position " + e);
        if (t = t.isInSet(r.marks), !t) return this;
      }
      return this.step(new ai(e, t)), this;
    }
    split(e, t = 1, r) {
      return B1(this, e, t, r), this;
    }
    addMark(e, t, r) {
      return O1(this, e, t, r), this;
    }
    removeMark(e, t, r) {
      return A1(this, e, t, r), this;
    }
    clearIncompatible(e, t, r) {
      return dl(this, e, t, r), this;
    }
  }
  const ma = /* @__PURE__ */ Object.create(null);
  class Ie {
    constructor(e, t, r) {
      this.$anchor = e, this.$head = t, this.ranges = r || [
        new K1(e.min(t), e.max(t))
      ];
    }
    get anchor() {
      return this.$anchor.pos;
    }
    get head() {
      return this.$head.pos;
    }
    get from() {
      return this.$from.pos;
    }
    get to() {
      return this.$to.pos;
    }
    get $from() {
      return this.ranges[0].$from;
    }
    get $to() {
      return this.ranges[0].$to;
    }
    get empty() {
      let e = this.ranges;
      for (let t = 0; t < e.length; t++) if (e[t].$from.pos != e[t].$to.pos) return false;
      return true;
    }
    content() {
      return this.$from.doc.slice(this.from, this.to, true);
    }
    replace(e, t = re.empty) {
      let r = t.content.lastChild, i = null;
      for (let a = 0; a < t.openEnd; a++) i = r, r = r.lastChild;
      let s = e.steps.length, o = this.ranges;
      for (let a = 0; a < o.length; a++) {
        let { $from: u, $to: l } = o[a], c = e.mapping.slice(s);
        e.replaceRange(c.map(u.pos), c.map(l.pos), a ? re.empty : t), a == 0 && Ac(e, s, (r ? r.isInline : i && i.isTextblock) ? -1 : 1);
      }
    }
    replaceWith(e, t) {
      let r = e.steps.length, i = this.ranges;
      for (let s = 0; s < i.length; s++) {
        let { $from: o, $to: a } = i[s], u = e.mapping.slice(r), l = u.map(o.pos), c = u.map(a.pos);
        s ? e.deleteRange(l, c) : (e.replaceRangeWith(l, c, t), Ac(e, r, t.isInline ? -1 : 1));
      }
    }
    static findFrom(e, t, r = false) {
      let i = e.parent.inlineContent ? new Te(e) : Qr(e.node(0), e.parent, e.pos, e.index(), t, r);
      if (i) return i;
      for (let s = e.depth - 1; s >= 0; s--) {
        let o = t < 0 ? Qr(e.node(0), e.node(s), e.before(s + 1), e.index(s), t, r) : Qr(e.node(0), e.node(s), e.after(s + 1), e.index(s) + 1, t, r);
        if (o) return o;
      }
      return null;
    }
    static near(e, t = 1) {
      return this.findFrom(e, t) || this.findFrom(e, -t) || new Wt(e.node(0));
    }
    static atStart(e) {
      return Qr(e, e, 0, 0, 1) || new Wt(e);
    }
    static atEnd(e) {
      return Qr(e, e, e.content.size, e.childCount, -1) || new Wt(e);
    }
    static fromJSON(e, t) {
      if (!t || !t.type) throw new RangeError("Invalid input for Selection.fromJSON");
      let r = ma[t.type];
      if (!r) throw new RangeError(`No selection type ${t.type} defined`);
      return r.fromJSON(e, t);
    }
    static jsonID(e, t) {
      if (e in ma) throw new RangeError("Duplicate use of selection JSON ID " + e);
      return ma[e] = t, t.prototype.jsonID = e, t;
    }
    getBookmark() {
      return Te.between(this.$anchor, this.$head).getBookmark();
    }
  }
  Ie.prototype.visible = true;
  class K1 {
    constructor(e, t) {
      this.$from = e, this.$to = t;
    }
  }
  let Cc = false;
  function Oc(n) {
    !Cc && !n.parent.inlineContent && (Cc = true, console.warn("TextSelection endpoint not pointing into a node with inline content (" + n.parent.type.name + ")"));
  }
  class Te extends Ie {
    constructor(e, t = e) {
      Oc(e), Oc(t), super(e, t);
    }
    get $cursor() {
      return this.$anchor.pos == this.$head.pos ? this.$head : null;
    }
    map(e, t) {
      let r = e.resolve(t.map(this.head));
      if (!r.parent.inlineContent) return Ie.near(r);
      let i = e.resolve(t.map(this.anchor));
      return new Te(i.parent.inlineContent ? i : r, r);
    }
    replace(e, t = re.empty) {
      if (super.replace(e, t), t == re.empty) {
        let r = this.$from.marksAcross(this.$to);
        r && e.ensureMarks(r);
      }
    }
    eq(e) {
      return e instanceof Te && e.anchor == this.anchor && e.head == this.head;
    }
    getBookmark() {
      return new Lo(this.anchor, this.head);
    }
    toJSON() {
      return {
        type: "text",
        anchor: this.anchor,
        head: this.head
      };
    }
    static fromJSON(e, t) {
      if (typeof t.anchor != "number" || typeof t.head != "number") throw new RangeError("Invalid input for TextSelection.fromJSON");
      return new Te(e.resolve(t.anchor), e.resolve(t.head));
    }
    static create(e, t, r = t) {
      let i = e.resolve(t);
      return new this(i, r == t ? i : e.resolve(r));
    }
    static between(e, t, r) {
      let i = e.pos - t.pos;
      if ((!r || i) && (r = i >= 0 ? 1 : -1), !t.parent.inlineContent) {
        let s = Ie.findFrom(t, r, true) || Ie.findFrom(t, -r, true);
        if (s) t = s.$head;
        else return Ie.near(t, r);
      }
      return e.parent.inlineContent || (i == 0 ? e = t : (e = (Ie.findFrom(e, -r, true) || Ie.findFrom(e, r, true)).$anchor, e.pos < t.pos != i < 0 && (e = t))), new Te(e, t);
    }
  }
  Ie.jsonID("text", Te);
  class Lo {
    constructor(e, t) {
      this.anchor = e, this.head = t;
    }
    map(e) {
      return new Lo(e.map(this.anchor), e.map(this.head));
    }
    resolve(e) {
      return Te.between(e.resolve(this.anchor), e.resolve(this.head));
    }
  }
  class ye extends Ie {
    constructor(e) {
      let t = e.nodeAfter, r = e.node(0).resolve(e.pos + t.nodeSize);
      super(e, r), this.node = t;
    }
    map(e, t) {
      let { deleted: r, pos: i } = t.mapResult(this.anchor), s = e.resolve(i);
      return r ? Ie.near(s) : new ye(s);
    }
    content() {
      return new re(G.from(this.node), 0, 0);
    }
    eq(e) {
      return e instanceof ye && e.anchor == this.anchor;
    }
    toJSON() {
      return {
        type: "node",
        anchor: this.anchor
      };
    }
    getBookmark() {
      return new hl(this.anchor);
    }
    static fromJSON(e, t) {
      if (typeof t.anchor != "number") throw new RangeError("Invalid input for NodeSelection.fromJSON");
      return new ye(e.resolve(t.anchor));
    }
    static create(e, t) {
      return new ye(e.resolve(t));
    }
    static isSelectable(e) {
      return !e.isText && e.type.spec.selectable !== false;
    }
  }
  ye.prototype.visible = false;
  Ie.jsonID("node", ye);
  class hl {
    constructor(e) {
      this.anchor = e;
    }
    map(e) {
      let { deleted: t, pos: r } = e.mapResult(this.anchor);
      return t ? new Lo(r, r) : new hl(r);
    }
    resolve(e) {
      let t = e.resolve(this.anchor), r = t.nodeAfter;
      return r && ye.isSelectable(r) ? new ye(t) : Ie.near(t);
    }
  }
  class Wt extends Ie {
    constructor(e) {
      super(e.resolve(0), e.resolve(e.content.size));
    }
    replace(e, t = re.empty) {
      if (t == re.empty) {
        e.delete(0, e.doc.content.size);
        let r = Ie.atStart(e.doc);
        r.eq(e.selection) || e.setSelection(r);
      } else super.replace(e, t);
    }
    toJSON() {
      return {
        type: "all"
      };
    }
    static fromJSON(e) {
      return new Wt(e);
    }
    map(e) {
      return new Wt(e);
    }
    eq(e) {
      return e instanceof Wt;
    }
    getBookmark() {
      return J1;
    }
  }
  Ie.jsonID("all", Wt);
  const J1 = {
    map() {
      return this;
    },
    resolve(n) {
      return new Wt(n);
    }
  };
  function Qr(n, e, t, r, i, s = false) {
    if (e.inlineContent) return Te.create(n, t);
    for (let o = r - (i > 0 ? 0 : 1); i > 0 ? o < e.childCount : o >= 0; o += i) {
      let a = e.child(o);
      if (a.isAtom) {
        if (!s && ye.isSelectable(a)) return ye.create(n, t - (i < 0 ? a.nodeSize : 0));
      } else {
        let u = Qr(n, a, t + i, i < 0 ? a.childCount : 0, i, s);
        if (u) return u;
      }
      t += a.nodeSize * i;
    }
    return null;
  }
  function Ac(n, e, t) {
    let r = n.steps.length - 1;
    if (r < e) return;
    let i = n.steps[r];
    if (!(i instanceof xt || i instanceof kt)) return;
    let s = n.mapping.maps[r], o;
    s.forEach((a, u, l, c) => {
      o == null && (o = c);
    }), n.setSelection(Ie.near(n.doc.resolve(o), t));
  }
  const Mc = 1, Nc = 2, Pc = 4;
  class Y1 extends G1 {
    constructor(e) {
      super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
    }
    get selection() {
      return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
    }
    setSelection(e) {
      if (e.$from.doc != this.doc) throw new RangeError("Selection passed to setSelection must point at the current document");
      return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | Mc) & -3, this.storedMarks = null, this;
    }
    get selectionSet() {
      return (this.updated & Mc) > 0;
    }
    setStoredMarks(e) {
      return this.storedMarks = e, this.updated |= Nc, this;
    }
    ensureMarks(e) {
      return Ze.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
    }
    addStoredMark(e) {
      return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
    }
    removeStoredMark(e) {
      return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
    }
    get storedMarksSet() {
      return (this.updated & Nc) > 0;
    }
    addStep(e, t) {
      super.addStep(e, t), this.updated = this.updated & -3, this.storedMarks = null;
    }
    setTime(e) {
      return this.time = e, this;
    }
    replaceSelection(e) {
      return this.selection.replace(this, e), this;
    }
    replaceSelectionWith(e, t = true) {
      let r = this.selection;
      return t && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || Ze.none))), r.replaceWith(this, e), this;
    }
    deleteSelection() {
      return this.selection.replace(this), this;
    }
    insertText(e, t, r) {
      let i = this.doc.type.schema;
      if (t == null) return e ? this.replaceSelectionWith(i.text(e), true) : this.deleteSelection();
      {
        if (r == null && (r = t), r = r ?? t, !e) return this.deleteRange(t, r);
        let s = this.storedMarks;
        if (!s) {
          let o = this.doc.resolve(t);
          s = r == t ? o.marks() : o.marksAcross(this.doc.resolve(r));
        }
        return this.replaceRangeWith(t, r, i.text(e, s)), this.selection.empty || this.setSelection(Ie.near(this.selection.$to)), this;
      }
    }
    setMeta(e, t) {
      return this.meta[typeof e == "string" ? e : e.key] = t, this;
    }
    getMeta(e) {
      return this.meta[typeof e == "string" ? e : e.key];
    }
    get isGeneric() {
      for (let e in this.meta) return false;
      return true;
    }
    scrollIntoView() {
      return this.updated |= Pc, this;
    }
    get scrolledIntoView() {
      return (this.updated & Pc) > 0;
    }
  }
  function Dc(n, e) {
    return !e || !n ? n : n.bind(e);
  }
  class Di {
    constructor(e, t, r) {
      this.name = e, this.init = Dc(t.init, r), this.apply = Dc(t.apply, r);
    }
  }
  const X1 = [
    new Di("doc", {
      init(n) {
        return n.doc || n.schema.topNodeType.createAndFill();
      },
      apply(n) {
        return n.doc;
      }
    }),
    new Di("selection", {
      init(n, e) {
        return n.selection || Ie.atStart(e.doc);
      },
      apply(n) {
        return n.selection;
      }
    }),
    new Di("storedMarks", {
      init(n) {
        return n.storedMarks || null;
      },
      apply(n, e, t, r) {
        return r.selection.$cursor ? n.storedMarks : null;
      }
    }),
    new Di("scrollToSelection", {
      init() {
        return 0;
      },
      apply(n, e) {
        return n.scrolledIntoView ? e + 1 : e;
      }
    })
  ];
  class ga {
    constructor(e, t) {
      this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = X1.slice(), t && t.forEach((r) => {
        if (this.pluginsByKey[r.key]) throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
        this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new Di(r.key, r.spec.state, r));
      });
    }
  }
  class ei {
    constructor(e) {
      this.config = e;
    }
    get schema() {
      return this.config.schema;
    }
    get plugins() {
      return this.config.plugins;
    }
    apply(e) {
      return this.applyTransaction(e).state;
    }
    filterTransaction(e, t = -1) {
      for (let r = 0; r < this.config.plugins.length; r++) if (r != t) {
        let i = this.config.plugins[r];
        if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, e, this)) return false;
      }
      return true;
    }
    applyTransaction(e) {
      if (!this.filterTransaction(e)) return {
        state: this,
        transactions: []
      };
      let t = [
        e
      ], r = this.applyInner(e), i = null;
      for (; ; ) {
        let s = false;
        for (let o = 0; o < this.config.plugins.length; o++) {
          let a = this.config.plugins[o];
          if (a.spec.appendTransaction) {
            let u = i ? i[o].n : 0, l = i ? i[o].state : this, c = u < t.length && a.spec.appendTransaction.call(a, u ? t.slice(u) : t, l, r);
            if (c && r.filterTransaction(c, o)) {
              if (c.setMeta("appendedTransaction", e), !i) {
                i = [];
                for (let h = 0; h < this.config.plugins.length; h++) i.push(h < o ? {
                  state: r,
                  n: t.length
                } : {
                  state: this,
                  n: 0
                });
              }
              t.push(c), r = r.applyInner(c), s = true;
            }
            i && (i[o] = {
              state: r,
              n: t.length
            });
          }
        }
        if (!s) return {
          state: r,
          transactions: t
        };
      }
    }
    applyInner(e) {
      if (!e.before.eq(this.doc)) throw new RangeError("Applying a mismatched transaction");
      let t = new ei(this.config), r = this.config.fields;
      for (let i = 0; i < r.length; i++) {
        let s = r[i];
        t[s.name] = s.apply(e, this[s.name], this, t);
      }
      return t;
    }
    get tr() {
      return new Y1(this);
    }
    static create(e) {
      let t = new ga(e.doc ? e.doc.type.schema : e.schema, e.plugins), r = new ei(t);
      for (let i = 0; i < t.fields.length; i++) r[t.fields[i].name] = t.fields[i].init(e, r);
      return r;
    }
    reconfigure(e) {
      let t = new ga(this.schema, e.plugins), r = t.fields, i = new ei(t);
      for (let s = 0; s < r.length; s++) {
        let o = r[s].name;
        i[o] = this.hasOwnProperty(o) ? this[o] : r[s].init(e, i);
      }
      return i;
    }
    toJSON(e) {
      let t = {
        doc: this.doc.toJSON(),
        selection: this.selection.toJSON()
      };
      if (this.storedMarks && (t.storedMarks = this.storedMarks.map((r) => r.toJSON())), e && typeof e == "object") for (let r in e) {
        if (r == "doc" || r == "selection") throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let i = e[r], s = i.spec.state;
        s && s.toJSON && (t[r] = s.toJSON.call(i, this[i.key]));
      }
      return t;
    }
    static fromJSON(e, t, r) {
      if (!t) throw new RangeError("Invalid input for EditorState.fromJSON");
      if (!e.schema) throw new RangeError("Required config field 'schema' missing");
      let i = new ga(e.schema, e.plugins), s = new ei(i);
      return i.fields.forEach((o) => {
        if (o.name == "doc") s.doc = zn.fromJSON(e.schema, t.doc);
        else if (o.name == "selection") s.selection = Ie.fromJSON(s.doc, t.selection);
        else if (o.name == "storedMarks") t.storedMarks && (s.storedMarks = t.storedMarks.map(e.schema.markFromJSON));
        else {
          if (r) for (let a in r) {
            let u = r[a], l = u.spec.state;
            if (u.key == o.name && l && l.fromJSON && Object.prototype.hasOwnProperty.call(t, a)) {
              s[o.name] = l.fromJSON.call(u, e, t[a], s);
              return;
            }
          }
          s[o.name] = o.init(e, s);
        }
      }), s;
    }
  }
  function yp(n, e, t) {
    for (let r in n) {
      let i = n[r];
      i instanceof Function ? i = i.bind(e) : r == "handleDOMEvents" && (i = yp(i, e, {})), t[r] = i;
    }
    return t;
  }
  class Dt {
    constructor(e) {
      this.spec = e, this.props = {}, e.props && yp(e.props, this, this.props), this.key = e.key ? e.key.key : vp("plugin");
    }
    getState(e) {
      return e[this.key];
    }
  }
  const ba = /* @__PURE__ */ Object.create(null);
  function vp(n) {
    return n in ba ? n + "$" + ++ba[n] : (ba[n] = 0, n + "$");
  }
  class Vt {
    constructor(e = "key") {
      this.key = vp(e);
    }
    get(e) {
      return e.config.pluginsByKey[this.key];
    }
    getState(e) {
      return e[this.key];
    }
  }
  const Q1 = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
  function Z1(n) {
    let e = n.split(/-(?!$)/), t = e[e.length - 1];
    t == "Space" && (t = " ");
    let r, i, s, o;
    for (let a = 0; a < e.length - 1; a++) {
      let u = e[a];
      if (/^(cmd|meta|m)$/i.test(u)) o = true;
      else if (/^a(lt)?$/i.test(u)) r = true;
      else if (/^(c|ctrl|control)$/i.test(u)) i = true;
      else if (/^s(hift)?$/i.test(u)) s = true;
      else if (/^mod$/i.test(u)) Q1 ? o = true : i = true;
      else throw new Error("Unrecognized modifier name: " + u);
    }
    return r && (t = "Alt-" + t), i && (t = "Ctrl-" + t), o && (t = "Meta-" + t), s && (t = "Shift-" + t), t;
  }
  function ey(n) {
    let e = /* @__PURE__ */ Object.create(null);
    for (let t in n) e[Z1(t)] = n[t];
    return e;
  }
  function ya(n, e, t = true) {
    return e.altKey && (n = "Alt-" + n), e.ctrlKey && (n = "Ctrl-" + n), e.metaKey && (n = "Meta-" + n), t && e.shiftKey && (n = "Shift-" + n), n;
  }
  function wp(n) {
    return new Dt({
      props: {
        handleKeyDown: xp(n)
      }
    });
  }
  function xp(n) {
    let e = ey(n);
    return function(t, r) {
      let i = t1(r), s, o = e[ya(i, r)];
      if (o && o(t.state, t.dispatch, t)) return true;
      if (i.length == 1 && i != " ") {
        if (r.shiftKey) {
          let a = e[ya(i, r, false)];
          if (a && a(t.state, t.dispatch, t)) return true;
        }
        if ((r.shiftKey || r.altKey || r.metaKey || i.charCodeAt(0) > 127) && (s = lr[r.keyCode]) && s != i) {
          let a = e[ya(s, r)];
          if (a && a(t.state, t.dispatch, t)) return true;
        }
      }
      return false;
    };
  }
  const Ot = function(n) {
    for (var e = 0; ; e++) if (n = n.previousSibling, !n) return e;
  }, li = function(n) {
    let e = n.assignedSlot || n.parentNode;
    return e && e.nodeType == 11 ? e.host : e;
  };
  let Iu = null;
  const Ln = function(n, e, t) {
    let r = Iu || (Iu = document.createRange());
    return r.setEnd(n, t ?? n.nodeValue.length), r.setStart(n, e || 0), r;
  }, ty = function() {
    Iu = null;
  }, zr = function(n, e, t, r) {
    return t && (Ic(n, e, t, r, -1) || Ic(n, e, t, r, 1));
  }, ny = /^(img|br|input|textarea|hr)$/i;
  function Ic(n, e, t, r, i) {
    for (; ; ) {
      if (n == t && e == r) return true;
      if (e == (i < 0 ? 0 : Gt(n))) {
        let s = n.parentNode;
        if (!s || s.nodeType != 1 || es(n) || ny.test(n.nodeName) || n.contentEditable == "false") return false;
        e = Ot(n) + (i < 0 ? 0 : 1), n = s;
      } else if (n.nodeType == 1) {
        if (n = n.childNodes[e + (i < 0 ? -1 : 0)], n.contentEditable == "false") return false;
        e = i < 0 ? Gt(n) : 0;
      } else return false;
    }
  }
  function Gt(n) {
    return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
  }
  function ry(n, e) {
    for (; ; ) {
      if (n.nodeType == 3 && e) return n;
      if (n.nodeType == 1 && e > 0) {
        if (n.contentEditable == "false") return null;
        n = n.childNodes[e - 1], e = Gt(n);
      } else if (n.parentNode && !es(n)) e = Ot(n), n = n.parentNode;
      else return null;
    }
  }
  function iy(n, e) {
    for (; ; ) {
      if (n.nodeType == 3 && e < n.nodeValue.length) return n;
      if (n.nodeType == 1 && e < n.childNodes.length) {
        if (n.contentEditable == "false") return null;
        n = n.childNodes[e], e = 0;
      } else if (n.parentNode && !es(n)) e = Ot(n) + 1, n = n.parentNode;
      else return null;
    }
  }
  function sy(n, e, t) {
    for (let r = e == 0, i = e == Gt(n); r || i; ) {
      if (n == t) return true;
      let s = Ot(n);
      if (n = n.parentNode, !n) return false;
      r = r && s == 0, i = i && s == Gt(n);
    }
  }
  function es(n) {
    let e;
    for (let t = n; t && !(e = t.pmViewDesc); t = t.parentNode) ;
    return e && e.node && e.node.isBlock && (e.dom == n || e.contentDOM == n);
  }
  const Bo = function(n) {
    return n.focusNode && zr(n.focusNode, n.focusOffset, n.anchorNode, n.anchorOffset);
  };
  function Sr(n, e) {
    let t = document.createEvent("Event");
    return t.initEvent("keydown", true, true), t.keyCode = n, t.key = t.code = e, t;
  }
  function oy(n) {
    let e = n.activeElement;
    for (; e && e.shadowRoot; ) e = e.shadowRoot.activeElement;
    return e;
  }
  function ay(n, e, t) {
    if (n.caretPositionFromPoint) try {
      let r = n.caretPositionFromPoint(e, t);
      if (r) return {
        node: r.offsetNode,
        offset: Math.min(Gt(r.offsetNode), r.offset)
      };
    } catch {
    }
    if (n.caretRangeFromPoint) {
      let r = n.caretRangeFromPoint(e, t);
      if (r) return {
        node: r.startContainer,
        offset: Math.min(Gt(r.startContainer), r.startOffset)
      };
    }
  }
  const En = typeof navigator < "u" ? navigator : null, Rc = typeof document < "u" ? document : null, pr = En && En.userAgent || "", Ru = /Edge\/(\d+)/.exec(pr), kp = /MSIE \d/.exec(pr), _u = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(pr), qt = !!(kp || _u || Ru), or = kp ? document.documentMode : _u ? +_u[1] : Ru ? +Ru[1] : 0, dn = !qt && /gecko\/(\d+)/i.test(pr);
  dn && +(/Firefox\/(\d+)/.exec(pr) || [
    0,
    0
  ])[1];
  const Lu = !qt && /Chrome\/(\d+)/.exec(pr), Nt = !!Lu, Sp = Lu ? +Lu[1] : 0, Rt = !qt && !!En && /Apple Computer/.test(En.vendor), ci = Rt && (/Mobile\/\w+/.test(pr) || !!En && En.maxTouchPoints > 2), Ut = ci || (En ? /Mac/.test(En.platform) : false), uy = En ? /Win/.test(En.platform) : false, Fn = /Android \d/.test(pr), ts = !!Rc && "webkitFontSmoothing" in Rc.documentElement.style, ly = ts ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [
    0,
    0
  ])[1] : 0;
  function cy(n) {
    let e = n.defaultView && n.defaultView.visualViewport;
    return e ? {
      left: 0,
      right: e.width,
      top: 0,
      bottom: e.height
    } : {
      left: 0,
      right: n.documentElement.clientWidth,
      top: 0,
      bottom: n.documentElement.clientHeight
    };
  }
  function Pn(n, e) {
    return typeof n == "number" ? n : n[e];
  }
  function dy(n) {
    let e = n.getBoundingClientRect(), t = e.width / n.offsetWidth || 1, r = e.height / n.offsetHeight || 1;
    return {
      left: e.left,
      right: e.left + n.clientWidth * t,
      top: e.top,
      bottom: e.top + n.clientHeight * r
    };
  }
  function _c(n, e, t) {
    let r = n.someProp("scrollThreshold") || 0, i = n.someProp("scrollMargin") || 5, s = n.dom.ownerDocument;
    for (let o = t || n.dom; o; ) {
      if (o.nodeType != 1) {
        o = li(o);
        continue;
      }
      let a = o, u = a == s.body, l = u ? cy(s) : dy(a), c = 0, h = 0;
      if (e.top < l.top + Pn(r, "top") ? h = -(l.top - e.top + Pn(i, "top")) : e.bottom > l.bottom - Pn(r, "bottom") && (h = e.bottom - e.top > l.bottom - l.top ? e.top + Pn(i, "top") - l.top : e.bottom - l.bottom + Pn(i, "bottom")), e.left < l.left + Pn(r, "left") ? c = -(l.left - e.left + Pn(i, "left")) : e.right > l.right - Pn(r, "right") && (c = e.right - l.right + Pn(i, "right")), c || h) if (u) s.defaultView.scrollBy(c, h);
      else {
        let f = a.scrollLeft, p = a.scrollTop;
        h && (a.scrollTop += h), c && (a.scrollLeft += c);
        let m = a.scrollLeft - f, b = a.scrollTop - p;
        e = {
          left: e.left - m,
          top: e.top - b,
          right: e.right - m,
          bottom: e.bottom - b
        };
      }
      let d = u ? "fixed" : getComputedStyle(o).position;
      if (/^(fixed|sticky)$/.test(d)) break;
      o = d == "absolute" ? o.offsetParent : li(o);
    }
  }
  function fy(n) {
    let e = n.dom.getBoundingClientRect(), t = Math.max(0, e.top), r, i;
    for (let s = (e.left + e.right) / 2, o = t + 1; o < Math.min(innerHeight, e.bottom); o += 5) {
      let a = n.root.elementFromPoint(s, o);
      if (!a || a == n.dom || !n.dom.contains(a)) continue;
      let u = a.getBoundingClientRect();
      if (u.top >= t - 20) {
        r = a, i = u.top;
        break;
      }
    }
    return {
      refDOM: r,
      refTop: i,
      stack: Tp(n.dom)
    };
  }
  function Tp(n) {
    let e = [], t = n.ownerDocument;
    for (let r = n; r && (e.push({
      dom: r,
      top: r.scrollTop,
      left: r.scrollLeft
    }), n != t); r = li(r)) ;
    return e;
  }
  function hy({ refDOM: n, refTop: e, stack: t }) {
    let r = n ? n.getBoundingClientRect().top : 0;
    Ep(t, r == 0 ? 0 : r - e);
  }
  function Ep(n, e) {
    for (let t = 0; t < n.length; t++) {
      let { dom: r, top: i, left: s } = n[t];
      r.scrollTop != i + e && (r.scrollTop = i + e), r.scrollLeft != s && (r.scrollLeft = s);
    }
  }
  let Kr = null;
  function py(n) {
    if (n.setActive) return n.setActive();
    if (Kr) return n.focus(Kr);
    let e = Tp(n);
    n.focus(Kr == null ? {
      get preventScroll() {
        return Kr = {
          preventScroll: true
        }, true;
      }
    } : void 0), Kr || (Kr = false, Ep(e, 0));
  }
  function Cp(n, e) {
    let t, r = 2e8, i, s = 0, o = e.top, a = e.top, u, l;
    for (let c = n.firstChild, h = 0; c; c = c.nextSibling, h++) {
      let d;
      if (c.nodeType == 1) d = c.getClientRects();
      else if (c.nodeType == 3) d = Ln(c).getClientRects();
      else continue;
      for (let f = 0; f < d.length; f++) {
        let p = d[f];
        if (p.top <= o && p.bottom >= a) {
          o = Math.max(p.bottom, o), a = Math.min(p.top, a);
          let m = p.left > e.left ? p.left - e.left : p.right < e.left ? e.left - p.right : 0;
          if (m < r) {
            t = c, r = m, i = m && t.nodeType == 3 ? {
              left: p.right < e.left ? p.right : p.left,
              top: e.top
            } : e, c.nodeType == 1 && m && (s = h + (e.left >= (p.left + p.right) / 2 ? 1 : 0));
            continue;
          }
        } else p.top > e.top && !u && p.left <= e.left && p.right >= e.left && (u = c, l = {
          left: Math.max(p.left, Math.min(p.right, e.left)),
          top: p.top
        });
        !t && (e.left >= p.right && e.top >= p.top || e.left >= p.left && e.top >= p.bottom) && (s = h + 1);
      }
    }
    return !t && u && (t = u, i = l, r = 0), t && t.nodeType == 3 ? my(t, i) : !t || r && t.nodeType == 1 ? {
      node: n,
      offset: s
    } : Cp(t, i);
  }
  function my(n, e) {
    let t = n.nodeValue.length, r = document.createRange();
    for (let i = 0; i < t; i++) {
      r.setEnd(n, i + 1), r.setStart(n, i);
      let s = Kn(r, 1);
      if (s.top != s.bottom && pl(e, s)) return {
        node: n,
        offset: i + (e.left >= (s.left + s.right) / 2 ? 1 : 0)
      };
    }
    return {
      node: n,
      offset: 0
    };
  }
  function pl(n, e) {
    return n.left >= e.left - 1 && n.left <= e.right + 1 && n.top >= e.top - 1 && n.top <= e.bottom + 1;
  }
  function gy(n, e) {
    let t = n.parentNode;
    return t && /^li$/i.test(t.nodeName) && e.left < n.getBoundingClientRect().left ? t : n;
  }
  function by(n, e, t) {
    let { node: r, offset: i } = Cp(e, t), s = -1;
    if (r.nodeType == 1 && !r.firstChild) {
      let o = r.getBoundingClientRect();
      s = o.left != o.right && t.left > (o.left + o.right) / 2 ? 1 : -1;
    }
    return n.docView.posFromDOM(r, i, s);
  }
  function yy(n, e, t, r) {
    let i = -1;
    for (let s = e, o = false; s != n.dom; ) {
      let a = n.docView.nearestDesc(s, true), u;
      if (!a) return null;
      if (a.dom.nodeType == 1 && (a.node.isBlock && a.parent || !a.contentDOM) && ((u = a.dom.getBoundingClientRect()).width || u.height) && (a.node.isBlock && a.parent && (!o && u.left > r.left || u.top > r.top ? i = a.posBefore : (!o && u.right < r.left || u.bottom < r.top) && (i = a.posAfter), o = true), !a.contentDOM && i < 0 && !a.node.isText)) return (a.node.isBlock ? r.top < (u.top + u.bottom) / 2 : r.left < (u.left + u.right) / 2) ? a.posBefore : a.posAfter;
      s = a.dom.parentNode;
    }
    return i > -1 ? i : n.docView.posFromDOM(e, t, -1);
  }
  function Op(n, e, t) {
    let r = n.childNodes.length;
    if (r && t.top < t.bottom) for (let i = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - t.top) / (t.bottom - t.top)) - 2)), s = i; ; ) {
      let o = n.childNodes[s];
      if (o.nodeType == 1) {
        let a = o.getClientRects();
        for (let u = 0; u < a.length; u++) {
          let l = a[u];
          if (pl(e, l)) return Op(o, e, l);
        }
      }
      if ((s = (s + 1) % r) == i) break;
    }
    return n;
  }
  function vy(n, e) {
    let t = n.dom.ownerDocument, r, i = 0, s = ay(t, e.left, e.top);
    s && ({ node: r, offset: i } = s);
    let o = (n.root.elementFromPoint ? n.root : t).elementFromPoint(e.left, e.top), a;
    if (!o || !n.dom.contains(o.nodeType != 1 ? o.parentNode : o)) {
      let l = n.dom.getBoundingClientRect();
      if (!pl(e, l) || (o = Op(n.dom, e, l), !o)) return null;
    }
    if (Rt) for (let l = o; r && l; l = li(l)) l.draggable && (r = void 0);
    if (o = gy(o, e), r) {
      if (dn && r.nodeType == 1 && (i = Math.min(i, r.childNodes.length), i < r.childNodes.length)) {
        let c = r.childNodes[i], h;
        c.nodeName == "IMG" && (h = c.getBoundingClientRect()).right <= e.left && h.bottom > e.top && i++;
      }
      let l;
      ts && i && r.nodeType == 1 && (l = r.childNodes[i - 1]).nodeType == 1 && l.contentEditable == "false" && l.getBoundingClientRect().top >= e.top && i--, r == n.dom && i == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? a = n.state.doc.content.size : (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != "BR") && (a = yy(n, r, i, e));
    }
    a == null && (a = by(n, o, e));
    let u = n.docView.nearestDesc(o, true);
    return {
      pos: a,
      inside: u ? u.posAtStart - u.border : -1
    };
  }
  function Lc(n) {
    return n.top < n.bottom || n.left < n.right;
  }
  function Kn(n, e) {
    let t = n.getClientRects();
    if (t.length) {
      let r = t[e < 0 ? 0 : t.length - 1];
      if (Lc(r)) return r;
    }
    return Array.prototype.find.call(t, Lc) || n.getBoundingClientRect();
  }
  const wy = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
  function Ap(n, e, t) {
    let { node: r, offset: i, atom: s } = n.docView.domFromPos(e, t < 0 ? -1 : 1), o = ts || dn;
    if (r.nodeType == 3) if (o && (wy.test(r.nodeValue) || (t < 0 ? !i : i == r.nodeValue.length))) {
      let u = Kn(Ln(r, i, i), t);
      if (dn && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) {
        let l = Kn(Ln(r, i - 1, i - 1), -1);
        if (l.top == u.top) {
          let c = Kn(Ln(r, i, i + 1), -1);
          if (c.top != u.top) return ki(c, c.left < l.left);
        }
      }
      return u;
    } else {
      let u = i, l = i, c = t < 0 ? 1 : -1;
      return t < 0 && !i ? (l++, c = -1) : t >= 0 && i == r.nodeValue.length ? (u--, c = 1) : t < 0 ? u-- : l++, ki(Kn(Ln(r, u, l), c), c < 0);
    }
    if (!n.state.doc.resolve(e - (s || 0)).parent.inlineContent) {
      if (s == null && i && (t < 0 || i == Gt(r))) {
        let u = r.childNodes[i - 1];
        if (u.nodeType == 1) return va(u.getBoundingClientRect(), false);
      }
      if (s == null && i < Gt(r)) {
        let u = r.childNodes[i];
        if (u.nodeType == 1) return va(u.getBoundingClientRect(), true);
      }
      return va(r.getBoundingClientRect(), t >= 0);
    }
    if (s == null && i && (t < 0 || i == Gt(r))) {
      let u = r.childNodes[i - 1], l = u.nodeType == 3 ? Ln(u, Gt(u) - (o ? 0 : 1)) : u.nodeType == 1 && (u.nodeName != "BR" || !u.nextSibling) ? u : null;
      if (l) return ki(Kn(l, 1), false);
    }
    if (s == null && i < Gt(r)) {
      let u = r.childNodes[i];
      for (; u.pmViewDesc && u.pmViewDesc.ignoreForCoords; ) u = u.nextSibling;
      let l = u ? u.nodeType == 3 ? Ln(u, 0, o ? 0 : 1) : u.nodeType == 1 ? u : null : null;
      if (l) return ki(Kn(l, -1), true);
    }
    return ki(Kn(r.nodeType == 3 ? Ln(r) : r, -t), t >= 0);
  }
  function ki(n, e) {
    if (n.width == 0) return n;
    let t = e ? n.left : n.right;
    return {
      top: n.top,
      bottom: n.bottom,
      left: t,
      right: t
    };
  }
  function va(n, e) {
    if (n.height == 0) return n;
    let t = e ? n.top : n.bottom;
    return {
      top: t,
      bottom: t,
      left: n.left,
      right: n.right
    };
  }
  function Mp(n, e, t) {
    let r = n.state, i = n.root.activeElement;
    r != e && n.updateState(e), i != n.dom && n.focus();
    try {
      return t();
    } finally {
      r != e && n.updateState(r), i != n.dom && i && i.focus();
    }
  }
  function xy(n, e, t) {
    let r = e.selection, i = t == "up" ? r.$from : r.$to;
    return Mp(n, e, () => {
      let { node: s } = n.docView.domFromPos(i.pos, t == "up" ? -1 : 1);
      for (; ; ) {
        let a = n.docView.nearestDesc(s, true);
        if (!a) break;
        if (a.node.isBlock) {
          s = a.contentDOM || a.dom;
          break;
        }
        s = a.dom.parentNode;
      }
      let o = Ap(n, i.pos, 1);
      for (let a = s.firstChild; a; a = a.nextSibling) {
        let u;
        if (a.nodeType == 1) u = a.getClientRects();
        else if (a.nodeType == 3) u = Ln(a, 0, a.nodeValue.length).getClientRects();
        else continue;
        for (let l = 0; l < u.length; l++) {
          let c = u[l];
          if (c.bottom > c.top + 1 && (t == "up" ? o.top - c.top > (c.bottom - o.top) * 2 : c.bottom - o.bottom > (o.bottom - c.top) * 2)) return false;
        }
      }
      return true;
    });
  }
  const ky = /[\u0590-\u08ac]/;
  function Sy(n, e, t) {
    let { $head: r } = e.selection;
    if (!r.parent.isTextblock) return false;
    let i = r.parentOffset, s = !i, o = i == r.parent.content.size, a = n.domSelection();
    return a ? !ky.test(r.parent.textContent) || !a.modify ? t == "left" || t == "backward" ? s : o : Mp(n, e, () => {
      let { focusNode: u, focusOffset: l, anchorNode: c, anchorOffset: h } = n.domSelectionRange(), d = a.caretBidiLevel;
      a.modify("move", t, "character");
      let f = r.depth ? n.docView.domAfterPos(r.before()) : n.dom, { focusNode: p, focusOffset: m } = n.domSelectionRange(), b = p && !f.contains(p.nodeType == 1 ? p : p.parentNode) || u == p && l == m;
      try {
        a.collapse(c, h), u && (u != c || l != h) && a.extend && a.extend(u, l);
      } catch {
      }
      return d != null && (a.caretBidiLevel = d), b;
    }) : r.pos == r.start() || r.pos == r.end();
  }
  let Bc = null, Fc = null, zc = false;
  function Ty(n, e, t) {
    return Bc == e && Fc == t ? zc : (Bc = e, Fc = t, zc = t == "up" || t == "down" ? xy(n, e, t) : Sy(n, e, t));
  }
  const Yt = 0, jc = 1, Er = 2, Cn = 3;
  class ns {
    constructor(e, t, r, i) {
      this.parent = e, this.children = t, this.dom = r, this.contentDOM = i, this.dirty = Yt, r.pmViewDesc = this;
    }
    matchesWidget(e) {
      return false;
    }
    matchesMark(e) {
      return false;
    }
    matchesNode(e, t, r) {
      return false;
    }
    matchesHack(e) {
      return false;
    }
    parseRule() {
      return null;
    }
    stopEvent(e) {
      return false;
    }
    get size() {
      let e = 0;
      for (let t = 0; t < this.children.length; t++) e += this.children[t].size;
      return e;
    }
    get border() {
      return 0;
    }
    destroy() {
      this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
      for (let e = 0; e < this.children.length; e++) this.children[e].destroy();
    }
    posBeforeChild(e) {
      for (let t = 0, r = this.posAtStart; ; t++) {
        let i = this.children[t];
        if (i == e) return r;
        r += i.size;
      }
    }
    get posBefore() {
      return this.parent.posBeforeChild(this);
    }
    get posAtStart() {
      return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
    }
    get posAfter() {
      return this.posBefore + this.size;
    }
    get posAtEnd() {
      return this.posAtStart + this.size - 2 * this.border;
    }
    localPosFromDOM(e, t, r) {
      if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode)) if (r < 0) {
        let s, o;
        if (e == this.contentDOM) s = e.childNodes[t - 1];
        else {
          for (; e.parentNode != this.contentDOM; ) e = e.parentNode;
          s = e.previousSibling;
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); ) s = s.previousSibling;
        return s ? this.posBeforeChild(o) + o.size : this.posAtStart;
      } else {
        let s, o;
        if (e == this.contentDOM) s = e.childNodes[t];
        else {
          for (; e.parentNode != this.contentDOM; ) e = e.parentNode;
          s = e.nextSibling;
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); ) s = s.nextSibling;
        return s ? this.posBeforeChild(o) : this.posAtEnd;
      }
      let i;
      if (e == this.dom && this.contentDOM) i = t > Ot(this.contentDOM);
      else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) i = e.compareDocumentPosition(this.contentDOM) & 2;
      else if (this.dom.firstChild) {
        if (t == 0) for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            i = false;
            break;
          }
          if (s.previousSibling) break;
        }
        if (i == null && t == e.childNodes.length) for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            i = true;
            break;
          }
          if (s.nextSibling) break;
        }
      }
      return i ?? r > 0 ? this.posAtEnd : this.posAtStart;
    }
    nearestDesc(e, t = false) {
      for (let r = true, i = e; i; i = i.parentNode) {
        let s = this.getDesc(i), o;
        if (s && (!t || s.node)) if (r && (o = s.nodeDOM) && !(o.nodeType == 1 ? o.contains(e.nodeType == 1 ? e : e.parentNode) : o == e)) r = false;
        else return s;
      }
    }
    getDesc(e) {
      let t = e.pmViewDesc;
      for (let r = t; r; r = r.parent) if (r == this) return t;
    }
    posFromDOM(e, t, r) {
      for (let i = e; i; i = i.parentNode) {
        let s = this.getDesc(i);
        if (s) return s.localPosFromDOM(e, t, r);
      }
      return -1;
    }
    descAt(e) {
      for (let t = 0, r = 0; t < this.children.length; t++) {
        let i = this.children[t], s = r + i.size;
        if (r == e && s != r) {
          for (; !i.border && i.children.length; ) for (let o = 0; o < i.children.length; o++) {
            let a = i.children[o];
            if (a.size) {
              i = a;
              break;
            }
          }
          return i;
        }
        if (e < s) return i.descAt(e - r - i.border);
        r = s;
      }
    }
    domFromPos(e, t) {
      if (!this.contentDOM) return {
        node: this.dom,
        offset: 0,
        atom: e + 1
      };
      let r = 0, i = 0;
      for (let s = 0; r < this.children.length; r++) {
        let o = this.children[r], a = s + o.size;
        if (a > e || o instanceof Pp) {
          i = e - s;
          break;
        }
        s = a;
      }
      if (i) return this.children[r].domFromPos(i - this.children[r].border, t);
      for (let s; r && !(s = this.children[r - 1]).size && s instanceof Np && s.side >= 0; r--) ;
      if (t <= 0) {
        let s, o = true;
        for (; s = r ? this.children[r - 1] : null, !(!s || s.dom.parentNode == this.contentDOM); r--, o = false) ;
        return s && t && o && !s.border && !s.domAtom ? s.domFromPos(s.size, t) : {
          node: this.contentDOM,
          offset: s ? Ot(s.dom) + 1 : 0
        };
      } else {
        let s, o = true;
        for (; s = r < this.children.length ? this.children[r] : null, !(!s || s.dom.parentNode == this.contentDOM); r++, o = false) ;
        return s && o && !s.border && !s.domAtom ? s.domFromPos(0, t) : {
          node: this.contentDOM,
          offset: s ? Ot(s.dom) : this.contentDOM.childNodes.length
        };
      }
    }
    parseRange(e, t, r = 0) {
      if (this.children.length == 0) return {
        node: this.contentDOM,
        from: e,
        to: t,
        fromOffset: 0,
        toOffset: this.contentDOM.childNodes.length
      };
      let i = -1, s = -1;
      for (let o = r, a = 0; ; a++) {
        let u = this.children[a], l = o + u.size;
        if (i == -1 && e <= l) {
          let c = o + u.border;
          if (e >= c && t <= l - u.border && u.node && u.contentDOM && this.contentDOM.contains(u.contentDOM)) return u.parseRange(e, t, c);
          e = o;
          for (let h = a; h > 0; h--) {
            let d = this.children[h - 1];
            if (d.size && d.dom.parentNode == this.contentDOM && !d.emptyChildAt(1)) {
              i = Ot(d.dom) + 1;
              break;
            }
            e -= d.size;
          }
          i == -1 && (i = 0);
        }
        if (i > -1 && (l > t || a == this.children.length - 1)) {
          t = l;
          for (let c = a + 1; c < this.children.length; c++) {
            let h = this.children[c];
            if (h.size && h.dom.parentNode == this.contentDOM && !h.emptyChildAt(-1)) {
              s = Ot(h.dom);
              break;
            }
            t += h.size;
          }
          s == -1 && (s = this.contentDOM.childNodes.length);
          break;
        }
        o = l;
      }
      return {
        node: this.contentDOM,
        from: e,
        to: t,
        fromOffset: i,
        toOffset: s
      };
    }
    emptyChildAt(e) {
      if (this.border || !this.contentDOM || !this.children.length) return false;
      let t = this.children[e < 0 ? 0 : this.children.length - 1];
      return t.size == 0 || t.emptyChildAt(e);
    }
    domAfterPos(e) {
      let { node: t, offset: r } = this.domFromPos(e, 0);
      if (t.nodeType != 1 || r == t.childNodes.length) throw new RangeError("No node after pos " + e);
      return t.childNodes[r];
    }
    setSelection(e, t, r, i = false) {
      let s = Math.min(e, t), o = Math.max(e, t);
      for (let f = 0, p = 0; f < this.children.length; f++) {
        let m = this.children[f], b = p + m.size;
        if (s > p && o < b) return m.setSelection(e - p - m.border, t - p - m.border, r, i);
        p = b;
      }
      let a = this.domFromPos(e, e ? -1 : 1), u = t == e ? a : this.domFromPos(t, t ? -1 : 1), l = r.root.getSelection(), c = r.domSelectionRange(), h = false;
      if ((dn || Rt) && e == t) {
        let { node: f, offset: p } = a;
        if (f.nodeType == 3) {
          if (h = !!(p && f.nodeValue[p - 1] == `
`), h && p == f.nodeValue.length) for (let m = f, b; m; m = m.parentNode) {
            if (b = m.nextSibling) {
              b.nodeName == "BR" && (a = u = {
                node: b.parentNode,
                offset: Ot(b) + 1
              });
              break;
            }
            let g = m.pmViewDesc;
            if (g && g.node && g.node.isBlock) break;
          }
        } else {
          let m = f.childNodes[p - 1];
          h = m && (m.nodeName == "BR" || m.contentEditable == "false");
        }
      }
      if (dn && c.focusNode && c.focusNode != u.node && c.focusNode.nodeType == 1) {
        let f = c.focusNode.childNodes[c.focusOffset];
        f && f.contentEditable == "false" && (i = true);
      }
      if (!(i || h && Rt) && zr(a.node, a.offset, c.anchorNode, c.anchorOffset) && zr(u.node, u.offset, c.focusNode, c.focusOffset)) return;
      let d = false;
      if ((l.extend || e == t) && !h) {
        l.collapse(a.node, a.offset);
        try {
          e != t && l.extend(u.node, u.offset), d = true;
        } catch {
        }
      }
      if (!d) {
        if (e > t) {
          let p = a;
          a = u, u = p;
        }
        let f = document.createRange();
        f.setEnd(u.node, u.offset), f.setStart(a.node, a.offset), l.removeAllRanges(), l.addRange(f);
      }
    }
    ignoreMutation(e) {
      return !this.contentDOM && e.type != "selection";
    }
    get contentLost() {
      return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
    }
    markDirty(e, t) {
      for (let r = 0, i = 0; i < this.children.length; i++) {
        let s = this.children[i], o = r + s.size;
        if (r == o ? e <= o && t >= r : e < o && t > r) {
          let a = r + s.border, u = o - s.border;
          if (e >= a && t <= u) {
            this.dirty = e == r || t == o ? Er : jc, e == a && t == u && (s.contentLost || s.dom.parentNode != this.contentDOM) ? s.dirty = Cn : s.markDirty(e - a, t - a);
            return;
          } else s.dirty = s.dom == s.contentDOM && s.dom.parentNode == this.contentDOM && !s.children.length ? Er : Cn;
        }
        r = o;
      }
      this.dirty = Er;
    }
    markParentsDirty() {
      let e = 1;
      for (let t = this.parent; t; t = t.parent, e++) {
        let r = e == 1 ? Er : jc;
        t.dirty < r && (t.dirty = r);
      }
    }
    get domAtom() {
      return false;
    }
    get ignoreForCoords() {
      return false;
    }
    isText(e) {
      return false;
    }
  }
  class Np extends ns {
    constructor(e, t, r, i) {
      let s, o = t.type.toDOM;
      if (typeof o == "function" && (o = o(r, () => {
        if (!s) return i;
        if (s.parent) return s.parent.posBeforeChild(s);
      })), !t.type.spec.raw) {
        if (o.nodeType != 1) {
          let a = document.createElement("span");
          a.appendChild(o), o = a;
        }
        o.contentEditable = "false", o.classList.add("ProseMirror-widget");
      }
      super(e, [], o, null), this.widget = t, this.widget = t, s = this;
    }
    matchesWidget(e) {
      return this.dirty == Yt && e.type.eq(this.widget.type);
    }
    parseRule() {
      return {
        ignore: true
      };
    }
    stopEvent(e) {
      let t = this.widget.spec.stopEvent;
      return t ? t(e) : false;
    }
    ignoreMutation(e) {
      return e.type != "selection" || this.widget.spec.ignoreSelection;
    }
    destroy() {
      this.widget.type.destroy(this.dom), super.destroy();
    }
    get domAtom() {
      return true;
    }
    get side() {
      return this.widget.type.side;
    }
  }
  class Ey extends ns {
    constructor(e, t, r, i) {
      super(e, [], t, null), this.textDOM = r, this.text = i;
    }
    get size() {
      return this.text.length;
    }
    localPosFromDOM(e, t) {
      return e != this.textDOM ? this.posAtStart + (t ? this.size : 0) : this.posAtStart + t;
    }
    domFromPos(e) {
      return {
        node: this.textDOM,
        offset: e
      };
    }
    ignoreMutation(e) {
      return e.type === "characterData" && e.target.nodeValue == e.oldValue;
    }
  }
  class jr extends ns {
    constructor(e, t, r, i, s) {
      super(e, [], r, i), this.mark = t, this.spec = s;
    }
    static create(e, t, r, i) {
      let s = i.nodeViews[t.type.name], o = s && s(t, i, r);
      return (!o || !o.dom) && (o = Vr.renderSpec(document, t.type.spec.toDOM(t, r), null, t.attrs)), new jr(e, t, o.dom, o.contentDOM || o.dom, o);
    }
    parseRule() {
      return this.dirty & Cn || this.mark.type.spec.reparseInView ? null : {
        mark: this.mark.type.name,
        attrs: this.mark.attrs,
        contentElement: this.contentDOM
      };
    }
    matchesMark(e) {
      return this.dirty != Cn && this.mark.eq(e);
    }
    markDirty(e, t) {
      if (super.markDirty(e, t), this.dirty != Yt) {
        let r = this.parent;
        for (; !r.node; ) r = r.parent;
        r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = Yt;
      }
    }
    slice(e, t, r) {
      let i = jr.create(this.parent, this.mark, true, r), s = this.children, o = this.size;
      t < o && (s = Fu(s, t, o, r)), e > 0 && (s = Fu(s, 0, e, r));
      for (let a = 0; a < s.length; a++) s[a].parent = i;
      return i.children = s, i;
    }
    ignoreMutation(e) {
      return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
    }
    destroy() {
      this.spec.destroy && this.spec.destroy(), super.destroy();
    }
  }
  class ar extends ns {
    constructor(e, t, r, i, s, o, a, u, l) {
      super(e, [], s, o), this.node = t, this.outerDeco = r, this.innerDeco = i, this.nodeDOM = a;
    }
    static create(e, t, r, i, s, o) {
      let a = s.nodeViews[t.type.name], u, l = a && a(t, s, () => {
        if (!u) return o;
        if (u.parent) return u.parent.posBeforeChild(u);
      }, r, i), c = l && l.dom, h = l && l.contentDOM;
      if (t.isText) {
        if (!c) c = document.createTextNode(t.text);
        else if (c.nodeType != 3) throw new RangeError("Text must be rendered as a DOM text node");
      } else c || ({ dom: c, contentDOM: h } = Vr.renderSpec(document, t.type.spec.toDOM(t), null, t.attrs));
      !h && !t.isText && c.nodeName != "BR" && (c.hasAttribute("contenteditable") || (c.contentEditable = "false"), t.type.spec.draggable && (c.draggable = true));
      let d = c;
      return c = Rp(c, r, t), l ? u = new Cy(e, t, r, i, c, h || null, d, l, s, o + 1) : t.isText ? new Fo(e, t, r, i, c, d, s) : new ar(e, t, r, i, c, h || null, d, s, o + 1);
    }
    parseRule() {
      if (this.node.type.spec.reparseInView) return null;
      let e = {
        node: this.node.type.name,
        attrs: this.node.attrs
      };
      if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM) e.getContent = () => this.node.content;
      else if (!this.contentLost) e.contentElement = this.contentDOM;
      else {
        for (let t = this.children.length - 1; t >= 0; t--) {
          let r = this.children[t];
          if (this.dom.contains(r.dom.parentNode)) {
            e.contentElement = r.dom.parentNode;
            break;
          }
        }
        e.contentElement || (e.getContent = () => G.empty);
      }
      return e;
    }
    matchesNode(e, t, r) {
      return this.dirty == Yt && e.eq(this.node) && ro(t, this.outerDeco) && r.eq(this.innerDeco);
    }
    get size() {
      return this.node.nodeSize;
    }
    get border() {
      return this.node.isLeaf ? 0 : 1;
    }
    updateChildren(e, t) {
      let r = this.node.inlineContent, i = t, s = e.composing ? this.localCompositionInfo(e, t) : null, o = s && s.pos > -1 ? s : null, a = s && s.pos < 0, u = new Ay(this, o && o.node, e);
      Py(this.node, this.innerDeco, (l, c, h) => {
        l.spec.marks ? u.syncToMarks(l.spec.marks, r, e) : l.type.side >= 0 && !h && u.syncToMarks(c == this.node.childCount ? Ze.none : this.node.child(c).marks, r, e), u.placeWidget(l, e, i);
      }, (l, c, h, d) => {
        u.syncToMarks(l.marks, r, e);
        let f;
        u.findNodeMatch(l, c, h, d) || a && e.state.selection.from > i && e.state.selection.to < i + l.nodeSize && (f = u.findIndexWithChild(s.node)) > -1 && u.updateNodeAt(l, c, h, f, e) || u.updateNextNode(l, c, h, e, d, i) || u.addNode(l, c, h, e, i), i += l.nodeSize;
      }), u.syncToMarks([], r, e), this.node.isTextblock && u.addTextblockHacks(), u.destroyRest(), (u.changed || this.dirty == Er) && (o && this.protectLocalComposition(e, o), Dp(this.contentDOM, this.children, e), ci && Dy(this.dom));
    }
    localCompositionInfo(e, t) {
      let { from: r, to: i } = e.state.selection;
      if (!(e.state.selection instanceof Te) || r < t || i > t + this.node.content.size) return null;
      let s = e.input.compositionNode;
      if (!s || !this.dom.contains(s.parentNode)) return null;
      if (this.node.inlineContent) {
        let o = s.nodeValue, a = Iy(this.node.content, o, r - t, i - t);
        return a < 0 ? null : {
          node: s,
          pos: a,
          text: o
        };
      } else return {
        node: s,
        pos: -1,
        text: ""
      };
    }
    protectLocalComposition(e, { node: t, pos: r, text: i }) {
      if (this.getDesc(t)) return;
      let s = t;
      for (; s.parentNode != this.contentDOM; s = s.parentNode) {
        for (; s.previousSibling; ) s.parentNode.removeChild(s.previousSibling);
        for (; s.nextSibling; ) s.parentNode.removeChild(s.nextSibling);
        s.pmViewDesc && (s.pmViewDesc = void 0);
      }
      let o = new Ey(this, s, t, i);
      e.input.compositionNodes.push(o), this.children = Fu(this.children, r, r + i.length, e, o);
    }
    update(e, t, r, i) {
      return this.dirty == Cn || !e.sameMarkup(this.node) ? false : (this.updateInner(e, t, r, i), true);
    }
    updateInner(e, t, r, i) {
      this.updateOuterDeco(t), this.node = e, this.innerDeco = r, this.contentDOM && this.updateChildren(i, this.posAtStart), this.dirty = Yt;
    }
    updateOuterDeco(e) {
      if (ro(e, this.outerDeco)) return;
      let t = this.nodeDOM.nodeType != 1, r = this.dom;
      this.dom = Ip(this.dom, this.nodeDOM, Bu(this.outerDeco, this.node, t), Bu(e, this.node, t)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
    }
    selectNode() {
      this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = true);
    }
    deselectNode() {
      this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable"));
    }
    get domAtom() {
      return this.node.isAtom;
    }
  }
  function qc(n, e, t, r, i) {
    Rp(r, e, n);
    let s = new ar(void 0, n, e, t, r, r, r, i, 0);
    return s.contentDOM && s.updateChildren(i, 0), s;
  }
  class Fo extends ar {
    constructor(e, t, r, i, s, o, a) {
      super(e, t, r, i, s, null, o, a, 0);
    }
    parseRule() {
      let e = this.nodeDOM.parentNode;
      for (; e && e != this.dom && !e.pmIsDeco; ) e = e.parentNode;
      return {
        skip: e || true
      };
    }
    update(e, t, r, i) {
      return this.dirty == Cn || this.dirty != Yt && !this.inParent() || !e.sameMarkup(this.node) ? false : (this.updateOuterDeco(t), (this.dirty != Yt || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, i.trackWrites == this.nodeDOM && (i.trackWrites = null)), this.node = e, this.dirty = Yt, true);
    }
    inParent() {
      let e = this.parent.contentDOM;
      for (let t = this.nodeDOM; t; t = t.parentNode) if (t == e) return true;
      return false;
    }
    domFromPos(e) {
      return {
        node: this.nodeDOM,
        offset: e
      };
    }
    localPosFromDOM(e, t, r) {
      return e == this.nodeDOM ? this.posAtStart + Math.min(t, this.node.text.length) : super.localPosFromDOM(e, t, r);
    }
    ignoreMutation(e) {
      return e.type != "characterData" && e.type != "selection";
    }
    slice(e, t, r) {
      let i = this.node.cut(e, t), s = document.createTextNode(i.text);
      return new Fo(this.parent, i, this.outerDeco, this.innerDeco, s, s, r);
    }
    markDirty(e, t) {
      super.markDirty(e, t), this.dom != this.nodeDOM && (e == 0 || t == this.nodeDOM.nodeValue.length) && (this.dirty = Cn);
    }
    get domAtom() {
      return false;
    }
    isText(e) {
      return this.node.text == e;
    }
  }
  class Pp extends ns {
    parseRule() {
      return {
        ignore: true
      };
    }
    matchesHack(e) {
      return this.dirty == Yt && this.dom.nodeName == e;
    }
    get domAtom() {
      return true;
    }
    get ignoreForCoords() {
      return this.dom.nodeName == "IMG";
    }
  }
  class Cy extends ar {
    constructor(e, t, r, i, s, o, a, u, l, c) {
      super(e, t, r, i, s, o, a, l, c), this.spec = u;
    }
    update(e, t, r, i) {
      if (this.dirty == Cn) return false;
      if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
        let s = this.spec.update(e, t, r);
        return s && this.updateInner(e, t, r, i), s;
      } else return !this.contentDOM && !e.isLeaf ? false : super.update(e, t, r, i);
    }
    selectNode() {
      this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
    }
    deselectNode() {
      this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
    }
    setSelection(e, t, r, i) {
      this.spec.setSelection ? this.spec.setSelection(e, t, r.root) : super.setSelection(e, t, r, i);
    }
    destroy() {
      this.spec.destroy && this.spec.destroy(), super.destroy();
    }
    stopEvent(e) {
      return this.spec.stopEvent ? this.spec.stopEvent(e) : false;
    }
    ignoreMutation(e) {
      return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
    }
  }
  function Dp(n, e, t) {
    let r = n.firstChild, i = false;
    for (let s = 0; s < e.length; s++) {
      let o = e[s], a = o.dom;
      if (a.parentNode == n) {
        for (; a != r; ) r = $c(r), i = true;
        r = r.nextSibling;
      } else i = true, n.insertBefore(a, r);
      if (o instanceof jr) {
        let u = r ? r.previousSibling : n.lastChild;
        Dp(o.contentDOM, o.children, t), r = u ? u.nextSibling : n.firstChild;
      }
    }
    for (; r; ) r = $c(r), i = true;
    i && t.trackWrites == n && (t.trackWrites = null);
  }
  const _i = function(n) {
    n && (this.nodeName = n);
  };
  _i.prototype = /* @__PURE__ */ Object.create(null);
  const Cr = [
    new _i()
  ];
  function Bu(n, e, t) {
    if (n.length == 0) return Cr;
    let r = t ? Cr[0] : new _i(), i = [
      r
    ];
    for (let s = 0; s < n.length; s++) {
      let o = n[s].type.attrs;
      if (o) {
        o.nodeName && i.push(r = new _i(o.nodeName));
        for (let a in o) {
          let u = o[a];
          u != null && (t && i.length == 1 && i.push(r = new _i(e.isInline ? "span" : "div")), a == "class" ? r.class = (r.class ? r.class + " " : "") + u : a == "style" ? r.style = (r.style ? r.style + ";" : "") + u : a != "nodeName" && (r[a] = u));
        }
      }
    }
    return i;
  }
  function Ip(n, e, t, r) {
    if (t == Cr && r == Cr) return e;
    let i = e;
    for (let s = 0; s < r.length; s++) {
      let o = r[s], a = t[s];
      if (s) {
        let u;
        a && a.nodeName == o.nodeName && i != n && (u = i.parentNode) && u.nodeName.toLowerCase() == o.nodeName || (u = document.createElement(o.nodeName), u.pmIsDeco = true, u.appendChild(i), a = Cr[0]), i = u;
      }
      Oy(i, a || Cr[0], o);
    }
    return i;
  }
  function Oy(n, e, t) {
    for (let r in e) r != "class" && r != "style" && r != "nodeName" && !(r in t) && n.removeAttribute(r);
    for (let r in t) r != "class" && r != "style" && r != "nodeName" && t[r] != e[r] && n.setAttribute(r, t[r]);
    if (e.class != t.class) {
      let r = e.class ? e.class.split(" ").filter(Boolean) : [], i = t.class ? t.class.split(" ").filter(Boolean) : [];
      for (let s = 0; s < r.length; s++) i.indexOf(r[s]) == -1 && n.classList.remove(r[s]);
      for (let s = 0; s < i.length; s++) r.indexOf(i[s]) == -1 && n.classList.add(i[s]);
      n.classList.length == 0 && n.removeAttribute("class");
    }
    if (e.style != t.style) {
      if (e.style) {
        let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, i;
        for (; i = r.exec(e.style); ) n.style.removeProperty(i[1]);
      }
      t.style && (n.style.cssText += t.style);
    }
  }
  function Rp(n, e, t) {
    return Ip(n, n, Cr, Bu(e, t, n.nodeType != 1));
  }
  function ro(n, e) {
    if (n.length != e.length) return false;
    for (let t = 0; t < n.length; t++) if (!n[t].type.eq(e[t].type)) return false;
    return true;
  }
  function $c(n) {
    let e = n.nextSibling;
    return n.parentNode.removeChild(n), e;
  }
  class Ay {
    constructor(e, t, r) {
      this.lock = t, this.view = r, this.index = 0, this.stack = [], this.changed = false, this.top = e, this.preMatch = My(e.node.content, e);
    }
    destroyBetween(e, t) {
      if (e != t) {
        for (let r = e; r < t; r++) this.top.children[r].destroy();
        this.top.children.splice(e, t - e), this.changed = true;
      }
    }
    destroyRest() {
      this.destroyBetween(this.index, this.top.children.length);
    }
    syncToMarks(e, t, r) {
      let i = 0, s = this.stack.length >> 1, o = Math.min(s, e.length);
      for (; i < o && (i == s - 1 ? this.top : this.stack[i + 1 << 1]).matchesMark(e[i]) && e[i].type.spec.spanning !== false; ) i++;
      for (; i < s; ) this.destroyRest(), this.top.dirty = Yt, this.index = this.stack.pop(), this.top = this.stack.pop(), s--;
      for (; s < e.length; ) {
        this.stack.push(this.top, this.index + 1);
        let a = -1;
        for (let u = this.index; u < Math.min(this.index + 3, this.top.children.length); u++) {
          let l = this.top.children[u];
          if (l.matchesMark(e[s]) && !this.isLocked(l.dom)) {
            a = u;
            break;
          }
        }
        if (a > -1) a > this.index && (this.changed = true, this.destroyBetween(this.index, a)), this.top = this.top.children[this.index];
        else {
          let u = jr.create(this.top, e[s], t, r);
          this.top.children.splice(this.index, 0, u), this.top = u, this.changed = true;
        }
        this.index = 0, s++;
      }
    }
    findNodeMatch(e, t, r, i) {
      let s = -1, o;
      if (i >= this.preMatch.index && (o = this.preMatch.matches[i - this.preMatch.index]).parent == this.top && o.matchesNode(e, t, r)) s = this.top.children.indexOf(o, this.index);
      else for (let a = this.index, u = Math.min(this.top.children.length, a + 5); a < u; a++) {
        let l = this.top.children[a];
        if (l.matchesNode(e, t, r) && !this.preMatch.matched.has(l)) {
          s = a;
          break;
        }
      }
      return s < 0 ? false : (this.destroyBetween(this.index, s), this.index++, true);
    }
    updateNodeAt(e, t, r, i, s) {
      let o = this.top.children[i];
      return o.dirty == Cn && o.dom == o.contentDOM && (o.dirty = Er), o.update(e, t, r, s) ? (this.destroyBetween(this.index, i), this.index++, true) : false;
    }
    findIndexWithChild(e) {
      for (; ; ) {
        let t = e.parentNode;
        if (!t) return -1;
        if (t == this.top.contentDOM) {
          let r = e.pmViewDesc;
          if (r) {
            for (let i = this.index; i < this.top.children.length; i++) if (this.top.children[i] == r) return i;
          }
          return -1;
        }
        e = t;
      }
    }
    updateNextNode(e, t, r, i, s, o) {
      for (let a = this.index; a < this.top.children.length; a++) {
        let u = this.top.children[a];
        if (u instanceof ar) {
          let l = this.preMatch.matched.get(u);
          if (l != null && l != s) return false;
          let c = u.dom, h, d = this.isLocked(c) && !(e.isText && u.node && u.node.isText && u.nodeDOM.nodeValue == e.text && u.dirty != Cn && ro(t, u.outerDeco));
          if (!d && u.update(e, t, r, i)) return this.destroyBetween(this.index, a), u.dom != c && (this.changed = true), this.index++, true;
          if (!d && (h = this.recreateWrapper(u, e, t, r, i, o))) return this.destroyBetween(this.index, a), this.top.children[this.index] = h, h.contentDOM && (h.dirty = Er, h.updateChildren(i, o + 1), h.dirty = Yt), this.changed = true, this.index++, true;
          break;
        }
      }
      return false;
    }
    recreateWrapper(e, t, r, i, s, o) {
      if (e.dirty || t.isAtom || !e.children.length || !e.node.content.eq(t.content) || !ro(r, e.outerDeco) || !i.eq(e.innerDeco)) return null;
      let a = ar.create(this.top, t, r, i, s, o);
      if (a.contentDOM) {
        a.children = e.children, e.children = [];
        for (let u of a.children) u.parent = a;
      }
      return e.destroy(), a;
    }
    addNode(e, t, r, i, s) {
      let o = ar.create(this.top, e, t, r, i, s);
      o.contentDOM && o.updateChildren(i, s + 1), this.top.children.splice(this.index++, 0, o), this.changed = true;
    }
    placeWidget(e, t, r) {
      let i = this.index < this.top.children.length ? this.top.children[this.index] : null;
      if (i && i.matchesWidget(e) && (e == i.widget || !i.widget.type.toDOM.parentNode)) this.index++;
      else {
        let s = new Np(this.top, e, t, r);
        this.top.children.splice(this.index++, 0, s), this.changed = true;
      }
    }
    addTextblockHacks() {
      let e = this.top.children[this.index - 1], t = this.top;
      for (; e instanceof jr; ) t = e, e = t.children[t.children.length - 1];
      (!e || !(e instanceof Fo) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((Rt || Nt) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", t), this.addHackNode("BR", this.top));
    }
    addHackNode(e, t) {
      if (t == this.top && this.index < t.children.length && t.children[this.index].matchesHack(e)) this.index++;
      else {
        let r = document.createElement(e);
        e == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), e == "BR" && (r.className = "ProseMirror-trailingBreak");
        let i = new Pp(this.top, [], r, null);
        t != this.top ? t.children.push(i) : t.children.splice(this.index++, 0, i), this.changed = true;
      }
    }
    isLocked(e) {
      return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
    }
  }
  function My(n, e) {
    let t = e, r = t.children.length, i = n.childCount, s = /* @__PURE__ */ new Map(), o = [];
    e: for (; i > 0; ) {
      let a;
      for (; ; ) if (r) {
        let l = t.children[r - 1];
        if (l instanceof jr) t = l, r = l.children.length;
        else {
          a = l, r--;
          break;
        }
      } else {
        if (t == e) break e;
        r = t.parent.children.indexOf(t), t = t.parent;
      }
      let u = a.node;
      if (u) {
        if (u != n.child(i - 1)) break;
        --i, s.set(a, i), o.push(a);
      }
    }
    return {
      index: i,
      matched: s,
      matches: o.reverse()
    };
  }
  function Ny(n, e) {
    return n.type.side - e.type.side;
  }
  function Py(n, e, t, r) {
    let i = e.locals(n), s = 0;
    if (i.length == 0) {
      for (let l = 0; l < n.childCount; l++) {
        let c = n.child(l);
        r(c, i, e.forChild(s, c), l), s += c.nodeSize;
      }
      return;
    }
    let o = 0, a = [], u = null;
    for (let l = 0; ; ) {
      let c, h;
      for (; o < i.length && i[o].to == s; ) {
        let b = i[o++];
        b.widget && (c ? (h || (h = [
          c
        ])).push(b) : c = b);
      }
      if (c) if (h) {
        h.sort(Ny);
        for (let b = 0; b < h.length; b++) t(h[b], l, !!u);
      } else t(c, l, !!u);
      let d, f;
      if (u) f = -1, d = u, u = null;
      else if (l < n.childCount) f = l, d = n.child(l++);
      else break;
      for (let b = 0; b < a.length; b++) a[b].to <= s && a.splice(b--, 1);
      for (; o < i.length && i[o].from <= s && i[o].to > s; ) a.push(i[o++]);
      let p = s + d.nodeSize;
      if (d.isText) {
        let b = p;
        o < i.length && i[o].from < b && (b = i[o].from);
        for (let g = 0; g < a.length; g++) a[g].to < b && (b = a[g].to);
        b < p && (u = d.cut(b - s), d = d.cut(0, b - s), p = b, f = -1);
      } else for (; o < i.length && i[o].to < p; ) o++;
      let m = d.isInline && !d.isLeaf ? a.filter((b) => !b.inline) : a.slice();
      r(d, m, e.forChild(s, d), f), s = p;
    }
  }
  function Dy(n) {
    if (n.nodeName == "UL" || n.nodeName == "OL") {
      let e = n.style.cssText;
      n.style.cssText = e + "; list-style: square !important", window.getComputedStyle(n).listStyle, n.style.cssText = e;
    }
  }
  function Iy(n, e, t, r) {
    for (let i = 0, s = 0; i < n.childCount && s <= r; ) {
      let o = n.child(i++), a = s;
      if (s += o.nodeSize, !o.isText) continue;
      let u = o.text;
      for (; i < n.childCount; ) {
        let l = n.child(i++);
        if (s += l.nodeSize, !l.isText) break;
        u += l.text;
      }
      if (s >= t) {
        if (s >= r && u.slice(r - e.length - a, r - a) == e) return r - e.length;
        let l = a < r ? u.lastIndexOf(e, r - a - 1) : -1;
        if (l >= 0 && l + e.length + a >= t) return a + l;
        if (t == r && u.length >= r + e.length - a && u.slice(r - a, r - a + e.length) == e) return r;
      }
    }
    return -1;
  }
  function Fu(n, e, t, r, i) {
    let s = [];
    for (let o = 0, a = 0; o < n.length; o++) {
      let u = n[o], l = a, c = a += u.size;
      l >= t || c <= e ? s.push(u) : (l < e && s.push(u.slice(0, e - l, r)), i && (s.push(i), i = void 0), c > t && s.push(u.slice(t - l, u.size, r)));
    }
    return s;
  }
  function ml(n, e = null) {
    let t = n.domSelectionRange(), r = n.state.doc;
    if (!t.focusNode) return null;
    let i = n.docView.nearestDesc(t.focusNode), s = i && i.size == 0, o = n.docView.posFromDOM(t.focusNode, t.focusOffset, 1);
    if (o < 0) return null;
    let a = r.resolve(o), u, l;
    if (Bo(t)) {
      for (u = o; i && !i.node; ) i = i.parent;
      let h = i.node;
      if (i && h.isAtom && ye.isSelectable(h) && i.parent && !(h.isInline && sy(t.focusNode, t.focusOffset, i.dom))) {
        let d = i.posBefore;
        l = new ye(o == d ? a : r.resolve(d));
      }
    } else {
      if (t instanceof n.dom.ownerDocument.defaultView.Selection && t.rangeCount > 1) {
        let h = o, d = o;
        for (let f = 0; f < t.rangeCount; f++) {
          let p = t.getRangeAt(f);
          h = Math.min(h, n.docView.posFromDOM(p.startContainer, p.startOffset, 1)), d = Math.max(d, n.docView.posFromDOM(p.endContainer, p.endOffset, -1));
        }
        if (h < 0) return null;
        [u, o] = d == n.state.selection.anchor ? [
          d,
          h
        ] : [
          h,
          d
        ], a = r.resolve(o);
      } else u = n.docView.posFromDOM(t.anchorNode, t.anchorOffset, 1);
      if (u < 0) return null;
    }
    let c = r.resolve(u);
    if (!l) {
      let h = e == "pointer" || n.state.selection.head < a.pos && !s ? 1 : -1;
      l = gl(n, c, a, h);
    }
    return l;
  }
  function _p(n) {
    return n.editable ? n.hasFocus() : Bp(n) && document.activeElement && document.activeElement.contains(n.dom);
  }
  function qn(n, e = false) {
    let t = n.state.selection;
    if (Lp(n, t), !!_p(n)) {
      if (!e && n.input.mouseDown && n.input.mouseDown.allowDefault && Nt) {
        let r = n.domSelectionRange(), i = n.domObserver.currentSelection;
        if (r.anchorNode && i.anchorNode && zr(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)) {
          n.input.mouseDown.delayedSelectionSync = true, n.domObserver.setCurSelection();
          return;
        }
      }
      if (n.domObserver.disconnectSelection(), n.cursorWrapper) _y(n);
      else {
        let { anchor: r, head: i } = t, s, o;
        Vc && !(t instanceof Te) && (t.$from.parent.inlineContent || (s = Hc(n, t.from)), !t.empty && !t.$from.parent.inlineContent && (o = Hc(n, t.to))), n.docView.setSelection(r, i, n, e), Vc && (s && Wc(s), o && Wc(o)), t.visible ? n.dom.classList.remove("ProseMirror-hideselection") : (n.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && Ry(n));
      }
      n.domObserver.setCurSelection(), n.domObserver.connectSelection();
    }
  }
  const Vc = Rt || Nt && Sp < 63;
  function Hc(n, e) {
    let { node: t, offset: r } = n.docView.domFromPos(e, 0), i = r < t.childNodes.length ? t.childNodes[r] : null, s = r ? t.childNodes[r - 1] : null;
    if (Rt && i && i.contentEditable == "false") return wa(i);
    if ((!i || i.contentEditable == "false") && (!s || s.contentEditable == "false")) {
      if (i) return wa(i);
      if (s) return wa(s);
    }
  }
  function wa(n) {
    return n.contentEditable = "true", Rt && n.draggable && (n.draggable = false, n.wasDraggable = true), n;
  }
  function Wc(n) {
    n.contentEditable = "false", n.wasDraggable && (n.draggable = true, n.wasDraggable = null);
  }
  function Ry(n) {
    let e = n.dom.ownerDocument;
    e.removeEventListener("selectionchange", n.input.hideSelectionGuard);
    let t = n.domSelectionRange(), r = t.anchorNode, i = t.anchorOffset;
    e.addEventListener("selectionchange", n.input.hideSelectionGuard = () => {
      (t.anchorNode != r || t.anchorOffset != i) && (e.removeEventListener("selectionchange", n.input.hideSelectionGuard), setTimeout(() => {
        (!_p(n) || n.state.selection.visible) && n.dom.classList.remove("ProseMirror-hideselection");
      }, 20));
    });
  }
  function _y(n) {
    let e = n.domSelection(), t = document.createRange();
    if (!e) return;
    let r = n.cursorWrapper.dom, i = r.nodeName == "IMG";
    i ? t.setStart(r.parentNode, Ot(r) + 1) : t.setStart(r, 0), t.collapse(true), e.removeAllRanges(), e.addRange(t), !i && !n.state.selection.visible && qt && or <= 11 && (r.disabled = true, r.disabled = false);
  }
  function Lp(n, e) {
    if (e instanceof ye) {
      let t = n.docView.descAt(e.from);
      t != n.lastSelectedViewDesc && (Uc(n), t && t.selectNode(), n.lastSelectedViewDesc = t);
    } else Uc(n);
  }
  function Uc(n) {
    n.lastSelectedViewDesc && (n.lastSelectedViewDesc.parent && n.lastSelectedViewDesc.deselectNode(), n.lastSelectedViewDesc = void 0);
  }
  function gl(n, e, t, r) {
    return n.someProp("createSelectionBetween", (i) => i(n, e, t)) || Te.between(e, t, r);
  }
  function Gc(n) {
    return n.editable && !n.hasFocus() ? false : Bp(n);
  }
  function Bp(n) {
    let e = n.domSelectionRange();
    if (!e.anchorNode) return false;
    try {
      return n.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (n.editable || n.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
    } catch {
      return false;
    }
  }
  function Ly(n) {
    let e = n.docView.domFromPos(n.state.selection.anchor, 0), t = n.domSelectionRange();
    return zr(e.node, e.offset, t.anchorNode, t.anchorOffset);
  }
  function zu(n, e) {
    let { $anchor: t, $head: r } = n.selection, i = e > 0 ? t.max(r) : t.min(r), s = i.parent.inlineContent ? i.depth ? n.doc.resolve(e > 0 ? i.after() : i.before()) : null : i;
    return s && Ie.findFrom(s, e);
  }
  function Yn(n, e) {
    return n.dispatch(n.state.tr.setSelection(e).scrollIntoView()), true;
  }
  function Kc(n, e, t) {
    let r = n.state.selection;
    if (r instanceof Te) if (t.indexOf("s") > -1) {
      let { $head: i } = r, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter;
      if (!s || s.isText || !s.isLeaf) return false;
      let o = n.state.doc.resolve(i.pos + s.nodeSize * (e < 0 ? -1 : 1));
      return Yn(n, new Te(r.$anchor, o));
    } else if (r.empty) {
      if (n.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let i = zu(n.state, e);
        return i && i instanceof ye ? Yn(n, i) : false;
      } else if (!(Ut && t.indexOf("m") > -1)) {
        let i = r.$head, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter, o;
        if (!s || s.isText) return false;
        let a = e < 0 ? i.pos - s.nodeSize : i.pos;
        return s.isAtom || (o = n.docView.descAt(a)) && !o.contentDOM ? ye.isSelectable(s) ? Yn(n, new ye(e < 0 ? n.state.doc.resolve(i.pos - s.nodeSize) : i)) : ts ? Yn(n, new Te(n.state.doc.resolve(e < 0 ? a : a + s.nodeSize))) : false : false;
      }
    } else return false;
    else {
      if (r instanceof ye && r.node.isInline) return Yn(n, new Te(e > 0 ? r.$to : r.$from));
      {
        let i = zu(n.state, e);
        return i ? Yn(n, i) : false;
      }
    }
  }
  function io(n) {
    return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
  }
  function Li(n, e) {
    let t = n.pmViewDesc;
    return t && t.size == 0 && (e < 0 || n.nextSibling || n.nodeName != "BR");
  }
  function Jr(n, e) {
    return e < 0 ? By(n) : Fy(n);
  }
  function By(n) {
    let e = n.domSelectionRange(), t = e.focusNode, r = e.focusOffset;
    if (!t) return;
    let i, s, o = false;
    for (dn && t.nodeType == 1 && r < io(t) && Li(t.childNodes[r], -1) && (o = true); ; ) if (r > 0) {
      if (t.nodeType != 1) break;
      {
        let a = t.childNodes[r - 1];
        if (Li(a, -1)) i = t, s = --r;
        else if (a.nodeType == 3) t = a, r = t.nodeValue.length;
        else break;
      }
    } else {
      if (Fp(t)) break;
      {
        let a = t.previousSibling;
        for (; a && Li(a, -1); ) i = t.parentNode, s = Ot(a), a = a.previousSibling;
        if (a) t = a, r = io(t);
        else {
          if (t = t.parentNode, t == n.dom) break;
          r = 0;
        }
      }
    }
    o ? ju(n, t, r) : i && ju(n, i, s);
  }
  function Fy(n) {
    let e = n.domSelectionRange(), t = e.focusNode, r = e.focusOffset;
    if (!t) return;
    let i = io(t), s, o;
    for (; ; ) if (r < i) {
      if (t.nodeType != 1) break;
      let a = t.childNodes[r];
      if (Li(a, 1)) s = t, o = ++r;
      else break;
    } else {
      if (Fp(t)) break;
      {
        let a = t.nextSibling;
        for (; a && Li(a, 1); ) s = a.parentNode, o = Ot(a) + 1, a = a.nextSibling;
        if (a) t = a, r = 0, i = io(t);
        else {
          if (t = t.parentNode, t == n.dom) break;
          r = i = 0;
        }
      }
    }
    s && ju(n, s, o);
  }
  function Fp(n) {
    let e = n.pmViewDesc;
    return e && e.node && e.node.isBlock;
  }
  function zy(n, e) {
    for (; n && e == n.childNodes.length && !es(n); ) e = Ot(n) + 1, n = n.parentNode;
    for (; n && e < n.childNodes.length; ) {
      let t = n.childNodes[e];
      if (t.nodeType == 3) return t;
      if (t.nodeType == 1 && t.contentEditable == "false") break;
      n = t, e = 0;
    }
  }
  function jy(n, e) {
    for (; n && !e && !es(n); ) e = Ot(n), n = n.parentNode;
    for (; n && e; ) {
      let t = n.childNodes[e - 1];
      if (t.nodeType == 3) return t;
      if (t.nodeType == 1 && t.contentEditable == "false") break;
      n = t, e = n.childNodes.length;
    }
  }
  function ju(n, e, t) {
    if (e.nodeType != 3) {
      let s, o;
      (o = zy(e, t)) ? (e = o, t = 0) : (s = jy(e, t)) && (e = s, t = s.nodeValue.length);
    }
    let r = n.domSelection();
    if (!r) return;
    if (Bo(r)) {
      let s = document.createRange();
      s.setEnd(e, t), s.setStart(e, t), r.removeAllRanges(), r.addRange(s);
    } else r.extend && r.extend(e, t);
    n.domObserver.setCurSelection();
    let { state: i } = n;
    setTimeout(() => {
      n.state == i && qn(n);
    }, 50);
  }
  function Jc(n, e) {
    let t = n.state.doc.resolve(e);
    if (!(Nt || uy) && t.parent.inlineContent) {
      let i = n.coordsAtPos(e);
      if (e > t.start()) {
        let s = n.coordsAtPos(e - 1), o = (s.top + s.bottom) / 2;
        if (o > i.top && o < i.bottom && Math.abs(s.left - i.left) > 1) return s.left < i.left ? "ltr" : "rtl";
      }
      if (e < t.end()) {
        let s = n.coordsAtPos(e + 1), o = (s.top + s.bottom) / 2;
        if (o > i.top && o < i.bottom && Math.abs(s.left - i.left) > 1) return s.left > i.left ? "ltr" : "rtl";
      }
    }
    return getComputedStyle(n.dom).direction == "rtl" ? "rtl" : "ltr";
  }
  function Yc(n, e, t) {
    let r = n.state.selection;
    if (r instanceof Te && !r.empty || t.indexOf("s") > -1 || Ut && t.indexOf("m") > -1) return false;
    let { $from: i, $to: s } = r;
    if (!i.parent.inlineContent || n.endOfTextblock(e < 0 ? "up" : "down")) {
      let o = zu(n.state, e);
      if (o && o instanceof ye) return Yn(n, o);
    }
    if (!i.parent.inlineContent) {
      let o = e < 0 ? i : s, a = r instanceof Wt ? Ie.near(o, e) : Ie.findFrom(o, e);
      return a ? Yn(n, a) : false;
    }
    return false;
  }
  function Xc(n, e) {
    if (!(n.state.selection instanceof Te)) return true;
    let { $head: t, $anchor: r, empty: i } = n.state.selection;
    if (!t.sameParent(r)) return true;
    if (!i) return false;
    if (n.endOfTextblock(e > 0 ? "forward" : "backward")) return true;
    let s = !t.textOffset && (e < 0 ? t.nodeBefore : t.nodeAfter);
    if (s && !s.isText) {
      let o = n.state.tr;
      return e < 0 ? o.delete(t.pos - s.nodeSize, t.pos) : o.delete(t.pos, t.pos + s.nodeSize), n.dispatch(o), true;
    }
    return false;
  }
  function Qc(n, e, t) {
    n.domObserver.stop(), e.contentEditable = t, n.domObserver.start();
  }
  function qy(n) {
    if (!Rt || n.state.selection.$head.parentOffset > 0) return false;
    let { focusNode: e, focusOffset: t } = n.domSelectionRange();
    if (e && e.nodeType == 1 && t == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
      let r = e.firstChild;
      Qc(n, r, "true"), setTimeout(() => Qc(n, r, "false"), 20);
    }
    return false;
  }
  function $y(n) {
    let e = "";
    return n.ctrlKey && (e += "c"), n.metaKey && (e += "m"), n.altKey && (e += "a"), n.shiftKey && (e += "s"), e;
  }
  function Vy(n, e) {
    let t = e.keyCode, r = $y(e);
    if (t == 8 || Ut && t == 72 && r == "c") return Xc(n, -1) || Jr(n, -1);
    if (t == 46 && !e.shiftKey || Ut && t == 68 && r == "c") return Xc(n, 1) || Jr(n, 1);
    if (t == 13 || t == 27) return true;
    if (t == 37 || Ut && t == 66 && r == "c") {
      let i = t == 37 ? Jc(n, n.state.selection.from) == "ltr" ? -1 : 1 : -1;
      return Kc(n, i, r) || Jr(n, i);
    } else if (t == 39 || Ut && t == 70 && r == "c") {
      let i = t == 39 ? Jc(n, n.state.selection.from) == "ltr" ? 1 : -1 : 1;
      return Kc(n, i, r) || Jr(n, i);
    } else {
      if (t == 38 || Ut && t == 80 && r == "c") return Yc(n, -1, r) || Jr(n, -1);
      if (t == 40 || Ut && t == 78 && r == "c") return qy(n) || Yc(n, 1, r) || Jr(n, 1);
      if (r == (Ut ? "m" : "c") && (t == 66 || t == 73 || t == 89 || t == 90)) return true;
    }
    return false;
  }
  function bl(n, e) {
    n.someProp("transformCopied", (f) => {
      e = f(e, n);
    });
    let t = [], { content: r, openStart: i, openEnd: s } = e;
    for (; i > 1 && s > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
      i--, s--;
      let f = r.firstChild;
      t.push(f.type.name, f.attrs != f.type.defaultAttrs ? f.attrs : null), r = f.content;
    }
    let o = n.someProp("clipboardSerializer") || Vr.fromSchema(n.state.schema), a = Hp(), u = a.createElement("div");
    u.appendChild(o.serializeFragment(r, {
      document: a
    }));
    let l = u.firstChild, c, h = 0;
    for (; l && l.nodeType == 1 && (c = Vp[l.nodeName.toLowerCase()]); ) {
      for (let f = c.length - 1; f >= 0; f--) {
        let p = a.createElement(c[f]);
        for (; u.firstChild; ) p.appendChild(u.firstChild);
        u.appendChild(p), h++;
      }
      l = u.firstChild;
    }
    l && l.nodeType == 1 && l.setAttribute("data-pm-slice", `${i} ${s}${h ? ` -${h}` : ""} ${JSON.stringify(t)}`);
    let d = n.someProp("clipboardTextSerializer", (f) => f(e, n)) || e.content.textBetween(0, e.content.size, `

`);
    return {
      dom: u,
      text: d,
      slice: e
    };
  }
  function zp(n, e, t, r, i) {
    let s = i.parent.type.spec.code, o, a;
    if (!t && !e) return null;
    let u = e && (r || s || !t);
    if (u) {
      if (n.someProp("transformPastedText", (d) => {
        e = d(e, s || r, n);
      }), s) return e ? new re(G.from(n.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : re.empty;
      let h = n.someProp("clipboardTextParser", (d) => d(e, i, r, n));
      if (h) a = h;
      else {
        let d = i.marks(), { schema: f } = n.state, p = Vr.fromSchema(f);
        o = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((m) => {
          let b = o.appendChild(document.createElement("p"));
          m && b.appendChild(p.serializeNode(f.text(m, d)));
        });
      }
    } else n.someProp("transformPastedHTML", (h) => {
      t = h(t, n);
    }), o = Gy(t), ts && Ky(o);
    let l = o && o.querySelector("[data-pm-slice]"), c = l && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(l.getAttribute("data-pm-slice") || "");
    if (c && c[3]) for (let h = +c[3]; h > 0; h--) {
      let d = o.firstChild;
      for (; d && d.nodeType != 1; ) d = d.nextSibling;
      if (!d) break;
      o = d;
    }
    if (a || (a = (n.someProp("clipboardParser") || n.someProp("domParser") || sr.fromSchema(n.state.schema)).parseSlice(o, {
      preserveWhitespace: !!(u || c),
      context: i,
      ruleFromNode(d) {
        return d.nodeName == "BR" && !d.nextSibling && d.parentNode && !Hy.test(d.parentNode.nodeName) ? {
          ignore: true
        } : null;
      }
    })), c) a = Jy(Zc(a, +c[1], +c[2]), c[4]);
    else if (a = re.maxOpen(Wy(a.content, i), true), a.openStart || a.openEnd) {
      let h = 0, d = 0;
      for (let f = a.content.firstChild; h < a.openStart && !f.type.spec.isolating; h++, f = f.firstChild) ;
      for (let f = a.content.lastChild; d < a.openEnd && !f.type.spec.isolating; d++, f = f.lastChild) ;
      a = Zc(a, h, d);
    }
    return n.someProp("transformPasted", (h) => {
      a = h(a, n);
    }), a;
  }
  const Hy = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
  function Wy(n, e) {
    if (n.childCount < 2) return n;
    for (let t = e.depth; t >= 0; t--) {
      let i = e.node(t).contentMatchAt(e.index(t)), s, o = [];
      if (n.forEach((a) => {
        if (!o) return;
        let u = i.findWrapping(a.type), l;
        if (!u) return o = null;
        if (l = o.length && s.length && qp(u, s, a, o[o.length - 1], 0)) o[o.length - 1] = l;
        else {
          o.length && (o[o.length - 1] = $p(o[o.length - 1], s.length));
          let c = jp(a, u);
          o.push(c), i = i.matchType(c.type), s = u;
        }
      }), o) return G.from(o);
    }
    return n;
  }
  function jp(n, e, t = 0) {
    for (let r = e.length - 1; r >= t; r--) n = e[r].create(null, G.from(n));
    return n;
  }
  function qp(n, e, t, r, i) {
    if (i < n.length && i < e.length && n[i] == e[i]) {
      let s = qp(n, e, t, r.lastChild, i + 1);
      if (s) return r.copy(r.content.replaceChild(r.childCount - 1, s));
      if (r.contentMatchAt(r.childCount).matchType(i == n.length - 1 ? t.type : n[i + 1])) return r.copy(r.content.append(G.from(jp(t, n, i + 1))));
    }
  }
  function $p(n, e) {
    if (e == 0) return n;
    let t = n.content.replaceChild(n.childCount - 1, $p(n.lastChild, e - 1)), r = n.contentMatchAt(n.childCount).fillBefore(G.empty, true);
    return n.copy(t.append(r));
  }
  function qu(n, e, t, r, i, s) {
    let o = e < 0 ? n.firstChild : n.lastChild, a = o.content;
    return n.childCount > 1 && (s = 0), i < r - 1 && (a = qu(a, e, t, r, i + 1, s)), i >= t && (a = e < 0 ? o.contentMatchAt(0).fillBefore(a, s <= i).append(a) : a.append(o.contentMatchAt(o.childCount).fillBefore(G.empty, true))), n.replaceChild(e < 0 ? 0 : n.childCount - 1, o.copy(a));
  }
  function Zc(n, e, t) {
    return e < n.openStart && (n = new re(qu(n.content, -1, e, n.openStart, 0, n.openEnd), e, n.openEnd)), t < n.openEnd && (n = new re(qu(n.content, 1, t, n.openEnd, 0, 0), n.openStart, t)), n;
  }
  const Vp = {
    thead: [
      "table"
    ],
    tbody: [
      "table"
    ],
    tfoot: [
      "table"
    ],
    caption: [
      "table"
    ],
    colgroup: [
      "table"
    ],
    col: [
      "table",
      "colgroup"
    ],
    tr: [
      "table",
      "tbody"
    ],
    td: [
      "table",
      "tbody",
      "tr"
    ],
    th: [
      "table",
      "tbody",
      "tr"
    ]
  };
  let ed = null;
  function Hp() {
    return ed || (ed = document.implementation.createHTMLDocument("title"));
  }
  let xa = null;
  function Uy(n) {
    let e = window.trustedTypes;
    return e ? (xa || (xa = e.createPolicy("ProseMirrorClipboard", {
      createHTML: (t) => t
    })), xa.createHTML(n)) : n;
  }
  function Gy(n) {
    let e = /^(\s*<meta [^>]*>)*/.exec(n);
    e && (n = n.slice(e[0].length));
    let t = Hp().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(n), i;
    if ((i = r && Vp[r[1].toLowerCase()]) && (n = i.map((s) => "<" + s + ">").join("") + n + i.map((s) => "</" + s + ">").reverse().join("")), t.innerHTML = Uy(n), i) for (let s = 0; s < i.length; s++) t = t.querySelector(i[s]) || t;
    return t;
  }
  function Ky(n) {
    let e = n.querySelectorAll(Nt ? "span:not([class]):not([style])" : "span.Apple-converted-space");
    for (let t = 0; t < e.length; t++) {
      let r = e[t];
      r.childNodes.length == 1 && r.textContent == "\xA0" && r.parentNode && r.parentNode.replaceChild(n.ownerDocument.createTextNode(" "), r);
    }
  }
  function Jy(n, e) {
    if (!n.size) return n;
    let t = n.content.firstChild.type.schema, r;
    try {
      r = JSON.parse(e);
    } catch {
      return n;
    }
    let { content: i, openStart: s, openEnd: o } = n;
    for (let a = r.length - 2; a >= 0; a -= 2) {
      let u = t.nodes[r[a]];
      if (!u || u.hasRequiredAttrs()) break;
      i = G.from(u.create(r[a + 1], i)), s++, o++;
    }
    return new re(i, s, o);
  }
  const _t = {}, Lt = {}, Yy = {
    touchstart: true,
    touchmove: true
  };
  class Xy {
    constructor() {
      this.shiftKey = false, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = {
        time: 0,
        x: 0,
        y: 0,
        type: ""
      }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = false, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
    }
  }
  function Qy(n) {
    for (let e in _t) {
      let t = _t[e];
      n.dom.addEventListener(e, n.input.eventHandlers[e] = (r) => {
        ev(n, r) && !yl(n, r) && (n.editable || !(r.type in Lt)) && t(n, r);
      }, Yy[e] ? {
        passive: true
      } : void 0);
    }
    Rt && n.dom.addEventListener("input", () => null), $u(n);
  }
  function rr(n, e) {
    n.input.lastSelectionOrigin = e, n.input.lastSelectionTime = Date.now();
  }
  function Zy(n) {
    n.domObserver.stop();
    for (let e in n.input.eventHandlers) n.dom.removeEventListener(e, n.input.eventHandlers[e]);
    clearTimeout(n.input.composingTimeout), clearTimeout(n.input.lastIOSEnterFallbackTimeout);
  }
  function $u(n) {
    n.someProp("handleDOMEvents", (e) => {
      for (let t in e) n.input.eventHandlers[t] || n.dom.addEventListener(t, n.input.eventHandlers[t] = (r) => yl(n, r));
    });
  }
  function yl(n, e) {
    return n.someProp("handleDOMEvents", (t) => {
      let r = t[e.type];
      return r ? r(n, e) || e.defaultPrevented : false;
    });
  }
  function ev(n, e) {
    if (!e.bubbles) return true;
    if (e.defaultPrevented) return false;
    for (let t = e.target; t != n.dom; t = t.parentNode) if (!t || t.nodeType == 11 || t.pmViewDesc && t.pmViewDesc.stopEvent(e)) return false;
    return true;
  }
  function tv(n, e) {
    !yl(n, e) && _t[e.type] && (n.editable || !(e.type in Lt)) && _t[e.type](n, e);
  }
  Lt.keydown = (n, e) => {
    let t = e;
    if (n.input.shiftKey = t.keyCode == 16 || t.shiftKey, !Up(n, t) && (n.input.lastKeyCode = t.keyCode, n.input.lastKeyCodeTime = Date.now(), !(Fn && Nt && t.keyCode == 13))) if (t.keyCode != 229 && n.domObserver.forceFlush(), ci && t.keyCode == 13 && !t.ctrlKey && !t.altKey && !t.metaKey) {
      let r = Date.now();
      n.input.lastIOSEnter = r, n.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        n.input.lastIOSEnter == r && (n.someProp("handleKeyDown", (i) => i(n, Sr(13, "Enter"))), n.input.lastIOSEnter = 0);
      }, 200);
    } else n.someProp("handleKeyDown", (r) => r(n, t)) || Vy(n, t) ? t.preventDefault() : rr(n, "key");
  };
  Lt.keyup = (n, e) => {
    e.keyCode == 16 && (n.input.shiftKey = false);
  };
  Lt.keypress = (n, e) => {
    let t = e;
    if (Up(n, t) || !t.charCode || t.ctrlKey && !t.altKey || Ut && t.metaKey) return;
    if (n.someProp("handleKeyPress", (i) => i(n, t))) {
      t.preventDefault();
      return;
    }
    let r = n.state.selection;
    if (!(r instanceof Te) || !r.$from.sameParent(r.$to)) {
      let i = String.fromCharCode(t.charCode);
      !/[\r\n]/.test(i) && !n.someProp("handleTextInput", (s) => s(n, r.$from.pos, r.$to.pos, i)) && n.dispatch(n.state.tr.insertText(i).scrollIntoView()), t.preventDefault();
    }
  };
  function zo(n) {
    return {
      left: n.clientX,
      top: n.clientY
    };
  }
  function nv(n, e) {
    let t = e.x - n.clientX, r = e.y - n.clientY;
    return t * t + r * r < 100;
  }
  function vl(n, e, t, r, i) {
    if (r == -1) return false;
    let s = n.state.doc.resolve(r);
    for (let o = s.depth + 1; o > 0; o--) if (n.someProp(e, (a) => o > s.depth ? a(n, t, s.nodeAfter, s.before(o), i, true) : a(n, t, s.node(o), s.before(o), i, false))) return true;
    return false;
  }
  function ni(n, e, t) {
    if (n.focused || n.focus(), n.state.selection.eq(e)) return;
    let r = n.state.tr.setSelection(e);
    r.setMeta("pointer", true), n.dispatch(r);
  }
  function rv(n, e) {
    if (e == -1) return false;
    let t = n.state.doc.resolve(e), r = t.nodeAfter;
    return r && r.isAtom && ye.isSelectable(r) ? (ni(n, new ye(t)), true) : false;
  }
  function iv(n, e) {
    if (e == -1) return false;
    let t = n.state.selection, r, i;
    t instanceof ye && (r = t.node);
    let s = n.state.doc.resolve(e);
    for (let o = s.depth + 1; o > 0; o--) {
      let a = o > s.depth ? s.nodeAfter : s.node(o);
      if (ye.isSelectable(a)) {
        r && t.$from.depth > 0 && o >= t.$from.depth && s.before(t.$from.depth + 1) == t.$from.pos ? i = s.before(t.$from.depth) : i = s.before(o);
        break;
      }
    }
    return i != null ? (ni(n, ye.create(n.state.doc, i)), true) : false;
  }
  function sv(n, e, t, r, i) {
    return vl(n, "handleClickOn", e, t, r) || n.someProp("handleClick", (s) => s(n, e, r)) || (i ? iv(n, t) : rv(n, t));
  }
  function ov(n, e, t, r) {
    return vl(n, "handleDoubleClickOn", e, t, r) || n.someProp("handleDoubleClick", (i) => i(n, e, r));
  }
  function av(n, e, t, r) {
    return vl(n, "handleTripleClickOn", e, t, r) || n.someProp("handleTripleClick", (i) => i(n, e, r)) || uv(n, t, r);
  }
  function uv(n, e, t) {
    if (t.button != 0) return false;
    let r = n.state.doc;
    if (e == -1) return r.inlineContent ? (ni(n, Te.create(r, 0, r.content.size)), true) : false;
    let i = r.resolve(e);
    for (let s = i.depth + 1; s > 0; s--) {
      let o = s > i.depth ? i.nodeAfter : i.node(s), a = i.before(s);
      if (o.inlineContent) ni(n, Te.create(r, a + 1, a + 1 + o.content.size));
      else if (ye.isSelectable(o)) ni(n, ye.create(r, a));
      else continue;
      return true;
    }
  }
  function wl(n) {
    return so(n);
  }
  const Wp = Ut ? "metaKey" : "ctrlKey";
  _t.mousedown = (n, e) => {
    let t = e;
    n.input.shiftKey = t.shiftKey;
    let r = wl(n), i = Date.now(), s = "singleClick";
    i - n.input.lastClick.time < 500 && nv(t, n.input.lastClick) && !t[Wp] && (n.input.lastClick.type == "singleClick" ? s = "doubleClick" : n.input.lastClick.type == "doubleClick" && (s = "tripleClick")), n.input.lastClick = {
      time: i,
      x: t.clientX,
      y: t.clientY,
      type: s
    };
    let o = n.posAtCoords(zo(t));
    o && (s == "singleClick" ? (n.input.mouseDown && n.input.mouseDown.done(), n.input.mouseDown = new lv(n, o, t, !!r)) : (s == "doubleClick" ? ov : av)(n, o.pos, o.inside, t) ? t.preventDefault() : rr(n, "pointer"));
  };
  class lv {
    constructor(e, t, r, i) {
      this.view = e, this.pos = t, this.event = r, this.flushed = i, this.delayedSelectionSync = false, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!r[Wp], this.allowDefault = r.shiftKey;
      let s, o;
      if (t.inside > -1) s = e.state.doc.nodeAt(t.inside), o = t.inside;
      else {
        let c = e.state.doc.resolve(t.pos);
        s = c.parent, o = c.depth ? c.before() : 0;
      }
      const a = i ? null : r.target, u = a ? e.docView.nearestDesc(a, true) : null;
      this.target = u && u.dom.nodeType == 1 ? u.dom : null;
      let { selection: l } = e.state;
      (r.button == 0 && s.type.spec.draggable && s.type.spec.selectable !== false || l instanceof ye && l.from <= o && l.to > o) && (this.mightDrag = {
        node: s,
        pos: o,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && dn && !this.target.hasAttribute("contentEditable"))
      }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = true), this.mightDrag.setUneditable && setTimeout(() => {
        this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
      }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), rr(e, "pointer");
    }
    done() {
      this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => qn(this.view)), this.view.input.mouseDown = null;
    }
    up(e) {
      if (this.done(), !this.view.dom.contains(e.target)) return;
      let t = this.pos;
      this.view.state.doc != this.startDoc && (t = this.view.posAtCoords(zo(e))), this.updateAllowDefault(e), this.allowDefault || !t ? rr(this.view, "pointer") : sv(this.view, t.pos, t.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || Rt && this.mightDrag && !this.mightDrag.node.isAtom || Nt && !this.view.state.selection.visible && Math.min(Math.abs(t.pos - this.view.state.selection.from), Math.abs(t.pos - this.view.state.selection.to)) <= 2) ? (ni(this.view, Ie.near(this.view.state.doc.resolve(t.pos))), e.preventDefault()) : rr(this.view, "pointer");
    }
    move(e) {
      this.updateAllowDefault(e), rr(this.view, "pointer"), e.buttons == 0 && this.done();
    }
    updateAllowDefault(e) {
      !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = true);
    }
  }
  _t.touchstart = (n) => {
    n.input.lastTouch = Date.now(), wl(n), rr(n, "pointer");
  };
  _t.touchmove = (n) => {
    n.input.lastTouch = Date.now(), rr(n, "pointer");
  };
  _t.contextmenu = (n) => wl(n);
  function Up(n, e) {
    return n.composing ? true : Rt && Math.abs(e.timeStamp - n.input.compositionEndedAt) < 500 ? (n.input.compositionEndedAt = -2e8, true) : false;
  }
  const cv = Fn ? 5e3 : -1;
  Lt.compositionstart = Lt.compositionupdate = (n) => {
    if (!n.composing) {
      n.domObserver.flush();
      let { state: e } = n, t = e.selection.$to;
      if (e.selection instanceof Te && (e.storedMarks || !t.textOffset && t.parentOffset && t.nodeBefore.marks.some((r) => r.type.spec.inclusive === false))) n.markCursor = n.state.storedMarks || t.marks(), so(n, true), n.markCursor = null;
      else if (so(n, !e.selection.empty), dn && e.selection.empty && t.parentOffset && !t.textOffset && t.nodeBefore.marks.length) {
        let r = n.domSelectionRange();
        for (let i = r.focusNode, s = r.focusOffset; i && i.nodeType == 1 && s != 0; ) {
          let o = s < 0 ? i.lastChild : i.childNodes[s - 1];
          if (!o) break;
          if (o.nodeType == 3) {
            let a = n.domSelection();
            a && a.collapse(o, o.nodeValue.length);
            break;
          } else i = o, s = -1;
        }
      }
      n.input.composing = true;
    }
    Gp(n, cv);
  };
  Lt.compositionend = (n, e) => {
    n.composing && (n.input.composing = false, n.input.compositionEndedAt = e.timeStamp, n.input.compositionPendingChanges = n.domObserver.pendingRecords().length ? n.input.compositionID : 0, n.input.compositionNode = null, n.input.compositionPendingChanges && Promise.resolve().then(() => n.domObserver.flush()), n.input.compositionID++, Gp(n, 20));
  };
  function Gp(n, e) {
    clearTimeout(n.input.composingTimeout), e > -1 && (n.input.composingTimeout = setTimeout(() => so(n), e));
  }
  function Kp(n) {
    for (n.composing && (n.input.composing = false, n.input.compositionEndedAt = fv()); n.input.compositionNodes.length > 0; ) n.input.compositionNodes.pop().markParentsDirty();
  }
  function dv(n) {
    let e = n.domSelectionRange();
    if (!e.focusNode) return null;
    let t = ry(e.focusNode, e.focusOffset), r = iy(e.focusNode, e.focusOffset);
    if (t && r && t != r) {
      let i = r.pmViewDesc, s = n.domObserver.lastChangedTextNode;
      if (t == s || r == s) return s;
      if (!i || !i.isText(r.nodeValue)) return r;
      if (n.input.compositionNode == r) {
        let o = t.pmViewDesc;
        if (!(!o || !o.isText(t.nodeValue))) return r;
      }
    }
    return t || r;
  }
  function fv() {
    let n = document.createEvent("Event");
    return n.initEvent("event", true, true), n.timeStamp;
  }
  function so(n, e = false) {
    if (!(Fn && n.domObserver.flushingSoon >= 0)) {
      if (n.domObserver.forceFlush(), Kp(n), e || n.docView && n.docView.dirty) {
        let t = ml(n);
        return t && !t.eq(n.state.selection) ? n.dispatch(n.state.tr.setSelection(t)) : (n.markCursor || e) && !n.state.selection.empty ? n.dispatch(n.state.tr.deleteSelection()) : n.updateState(n.state), true;
      }
      return false;
    }
  }
  function hv(n, e) {
    if (!n.dom.parentNode) return;
    let t = n.dom.parentNode.appendChild(document.createElement("div"));
    t.appendChild(e), t.style.cssText = "position: fixed; left: -10000px; top: 10px";
    let r = getSelection(), i = document.createRange();
    i.selectNodeContents(e), n.dom.blur(), r.removeAllRanges(), r.addRange(i), setTimeout(() => {
      t.parentNode && t.parentNode.removeChild(t), n.focus();
    }, 50);
  }
  const Wi = qt && or < 15 || ci && ly < 604;
  _t.copy = Lt.cut = (n, e) => {
    let t = e, r = n.state.selection, i = t.type == "cut";
    if (r.empty) return;
    let s = Wi ? null : t.clipboardData, o = r.content(), { dom: a, text: u } = bl(n, o);
    s ? (t.preventDefault(), s.clearData(), s.setData("text/html", a.innerHTML), s.setData("text/plain", u)) : hv(n, a), i && n.dispatch(n.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
  };
  function pv(n) {
    return n.openStart == 0 && n.openEnd == 0 && n.content.childCount == 1 ? n.content.firstChild : null;
  }
  function mv(n, e) {
    if (!n.dom.parentNode) return;
    let t = n.input.shiftKey || n.state.selection.$from.parent.type.spec.code, r = n.dom.parentNode.appendChild(document.createElement(t ? "textarea" : "div"));
    t || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus();
    let i = n.input.shiftKey && n.input.lastKeyCode != 45;
    setTimeout(() => {
      n.focus(), r.parentNode && r.parentNode.removeChild(r), t ? Ui(n, r.value, null, i, e) : Ui(n, r.textContent, r.innerHTML, i, e);
    }, 50);
  }
  function Ui(n, e, t, r, i) {
    let s = zp(n, e, t, r, n.state.selection.$from);
    if (n.someProp("handlePaste", (u) => u(n, i, s || re.empty))) return true;
    if (!s) return false;
    let o = pv(s), a = o ? n.state.tr.replaceSelectionWith(o, r) : n.state.tr.replaceSelection(s);
    return n.dispatch(a.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste")), true;
  }
  function Jp(n) {
    let e = n.getData("text/plain") || n.getData("Text");
    if (e) return e;
    let t = n.getData("text/uri-list");
    return t ? t.replace(/\r?\n/g, " ") : "";
  }
  Lt.paste = (n, e) => {
    let t = e;
    if (n.composing && !Fn) return;
    let r = Wi ? null : t.clipboardData, i = n.input.shiftKey && n.input.lastKeyCode != 45;
    r && Ui(n, Jp(r), r.getData("text/html"), i, t) ? t.preventDefault() : mv(n, t);
  };
  class Yp {
    constructor(e, t, r) {
      this.slice = e, this.move = t, this.node = r;
    }
  }
  const Xp = Ut ? "altKey" : "ctrlKey";
  _t.dragstart = (n, e) => {
    let t = e, r = n.input.mouseDown;
    if (r && r.done(), !t.dataTransfer) return;
    let i = n.state.selection, s = i.empty ? null : n.posAtCoords(zo(t)), o;
    if (!(s && s.pos >= i.from && s.pos <= (i instanceof ye ? i.to - 1 : i.to))) {
      if (r && r.mightDrag) o = ye.create(n.state.doc, r.mightDrag.pos);
      else if (t.target && t.target.nodeType == 1) {
        let h = n.docView.nearestDesc(t.target, true);
        h && h.node.type.spec.draggable && h != n.docView && (o = ye.create(n.state.doc, h.posBefore));
      }
    }
    let a = (o || n.state.selection).content(), { dom: u, text: l, slice: c } = bl(n, a);
    (!t.dataTransfer.files.length || !Nt || Sp > 120) && t.dataTransfer.clearData(), t.dataTransfer.setData(Wi ? "Text" : "text/html", u.innerHTML), t.dataTransfer.effectAllowed = "copyMove", Wi || t.dataTransfer.setData("text/plain", l), n.dragging = new Yp(c, !t[Xp], o);
  };
  _t.dragend = (n) => {
    let e = n.dragging;
    window.setTimeout(() => {
      n.dragging == e && (n.dragging = null);
    }, 50);
  };
  Lt.dragover = Lt.dragenter = (n, e) => e.preventDefault();
  Lt.drop = (n, e) => {
    let t = e, r = n.dragging;
    if (n.dragging = null, !t.dataTransfer) return;
    let i = n.posAtCoords(zo(t));
    if (!i) return;
    let s = n.state.doc.resolve(i.pos), o = r && r.slice;
    o ? n.someProp("transformPasted", (p) => {
      o = p(o, n);
    }) : o = zp(n, Jp(t.dataTransfer), Wi ? null : t.dataTransfer.getData("text/html"), false, s);
    let a = !!(r && !t[Xp]);
    if (n.someProp("handleDrop", (p) => p(n, t, o || re.empty, a))) {
      t.preventDefault();
      return;
    }
    if (!o) return;
    t.preventDefault();
    let u = o ? hp(n.state.doc, s.pos, o) : s.pos;
    u == null && (u = s.pos);
    let l = n.state.tr;
    if (a) {
      let { node: p } = r;
      p ? p.replace(l) : l.deleteSelection();
    }
    let c = l.mapping.map(u), h = o.openStart == 0 && o.openEnd == 0 && o.content.childCount == 1, d = l.doc;
    if (h ? l.replaceRangeWith(c, c, o.content.firstChild) : l.replaceRange(c, c, o), l.doc.eq(d)) return;
    let f = l.doc.resolve(c);
    if (h && ye.isSelectable(o.content.firstChild) && f.nodeAfter && f.nodeAfter.sameMarkup(o.content.firstChild)) l.setSelection(new ye(f));
    else {
      let p = l.mapping.map(u);
      l.mapping.maps[l.mapping.maps.length - 1].forEach((m, b, g, w) => p = w), l.setSelection(gl(n, f, l.doc.resolve(p)));
    }
    n.focus(), n.dispatch(l.setMeta("uiEvent", "drop"));
  };
  _t.focus = (n) => {
    n.input.lastFocus = Date.now(), n.focused || (n.domObserver.stop(), n.dom.classList.add("ProseMirror-focused"), n.domObserver.start(), n.focused = true, setTimeout(() => {
      n.docView && n.hasFocus() && !n.domObserver.currentSelection.eq(n.domSelectionRange()) && qn(n);
    }, 20));
  };
  _t.blur = (n, e) => {
    let t = e;
    n.focused && (n.domObserver.stop(), n.dom.classList.remove("ProseMirror-focused"), n.domObserver.start(), t.relatedTarget && n.dom.contains(t.relatedTarget) && n.domObserver.currentSelection.clear(), n.focused = false);
  };
  _t.beforeinput = (n, e) => {
    if (Nt && Fn && e.inputType == "deleteContentBackward") {
      n.domObserver.flushSoon();
      let { domChangeCount: r } = n.input;
      setTimeout(() => {
        if (n.input.domChangeCount != r || (n.dom.blur(), n.focus(), n.someProp("handleKeyDown", (s) => s(n, Sr(8, "Backspace"))))) return;
        let { $cursor: i } = n.state.selection;
        i && i.pos > 0 && n.dispatch(n.state.tr.delete(i.pos - 1, i.pos).scrollIntoView());
      }, 50);
    }
  };
  for (let n in Lt) _t[n] = Lt[n];
  function Gi(n, e) {
    if (n == e) return true;
    for (let t in n) if (n[t] !== e[t]) return false;
    for (let t in e) if (!(t in n)) return false;
    return true;
  }
  class oo {
    constructor(e, t) {
      this.toDOM = e, this.spec = t || Ir, this.side = this.spec.side || 0;
    }
    map(e, t, r, i) {
      let { pos: s, deleted: o } = e.mapResult(t.from + i, this.side < 0 ? -1 : 1);
      return o ? null : new jt(s - r, s - r, this);
    }
    valid() {
      return true;
    }
    eq(e) {
      return this == e || e instanceof oo && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && Gi(this.spec, e.spec));
    }
    destroy(e) {
      this.spec.destroy && this.spec.destroy(e);
    }
  }
  class ur {
    constructor(e, t) {
      this.attrs = e, this.spec = t || Ir;
    }
    map(e, t, r, i) {
      let s = e.map(t.from + i, this.spec.inclusiveStart ? -1 : 1) - r, o = e.map(t.to + i, this.spec.inclusiveEnd ? 1 : -1) - r;
      return s >= o ? null : new jt(s, o, this);
    }
    valid(e, t) {
      return t.from < t.to;
    }
    eq(e) {
      return this == e || e instanceof ur && Gi(this.attrs, e.attrs) && Gi(this.spec, e.spec);
    }
    static is(e) {
      return e.type instanceof ur;
    }
    destroy() {
    }
  }
  class xl {
    constructor(e, t) {
      this.attrs = e, this.spec = t || Ir;
    }
    map(e, t, r, i) {
      let s = e.mapResult(t.from + i, 1);
      if (s.deleted) return null;
      let o = e.mapResult(t.to + i, -1);
      return o.deleted || o.pos <= s.pos ? null : new jt(s.pos - r, o.pos - r, this);
    }
    valid(e, t) {
      let { index: r, offset: i } = e.content.findIndex(t.from), s;
      return i == t.from && !(s = e.child(r)).isText && i + s.nodeSize == t.to;
    }
    eq(e) {
      return this == e || e instanceof xl && Gi(this.attrs, e.attrs) && Gi(this.spec, e.spec);
    }
    destroy() {
    }
  }
  class jt {
    constructor(e, t, r) {
      this.from = e, this.to = t, this.type = r;
    }
    copy(e, t) {
      return new jt(e, t, this.type);
    }
    eq(e, t = 0) {
      return this.type.eq(e.type) && this.from + t == e.from && this.to + t == e.to;
    }
    map(e, t, r) {
      return this.type.map(e, this, t, r);
    }
    static widget(e, t, r) {
      return new jt(e, e, new oo(t, r));
    }
    static inline(e, t, r, i) {
      return new jt(e, t, new ur(r, i));
    }
    static node(e, t, r, i) {
      return new jt(e, t, new xl(r, i));
    }
    get spec() {
      return this.type.spec;
    }
    get inline() {
      return this.type instanceof ur;
    }
    get widget() {
      return this.type instanceof oo;
    }
  }
  const Zr = [], Ir = {};
  class ut {
    constructor(e, t) {
      this.local = e.length ? e : Zr, this.children = t.length ? t : Zr;
    }
    static create(e, t) {
      return t.length ? ao(t, e, 0, Ir) : Mt;
    }
    find(e, t, r) {
      let i = [];
      return this.findInner(e ?? 0, t ?? 1e9, i, 0, r), i;
    }
    findInner(e, t, r, i, s) {
      for (let o = 0; o < this.local.length; o++) {
        let a = this.local[o];
        a.from <= t && a.to >= e && (!s || s(a.spec)) && r.push(a.copy(a.from + i, a.to + i));
      }
      for (let o = 0; o < this.children.length; o += 3) if (this.children[o] < t && this.children[o + 1] > e) {
        let a = this.children[o] + 1;
        this.children[o + 2].findInner(e - a, t - a, r, i + a, s);
      }
    }
    map(e, t, r) {
      return this == Mt || e.maps.length == 0 ? this : this.mapInner(e, t, 0, 0, r || Ir);
    }
    mapInner(e, t, r, i, s) {
      let o;
      for (let a = 0; a < this.local.length; a++) {
        let u = this.local[a].map(e, r, i);
        u && u.type.valid(t, u) ? (o || (o = [])).push(u) : s.onRemove && s.onRemove(this.local[a].spec);
      }
      return this.children.length ? gv(this.children, o || [], e, t, r, i, s) : o ? new ut(o.sort(Rr), Zr) : Mt;
    }
    add(e, t) {
      return t.length ? this == Mt ? ut.create(e, t) : this.addInner(e, t, 0) : this;
    }
    addInner(e, t, r) {
      let i, s = 0;
      e.forEach((a, u) => {
        let l = u + r, c;
        if (c = Zp(t, a, l)) {
          for (i || (i = this.children.slice()); s < i.length && i[s] < u; ) s += 3;
          i[s] == u ? i[s + 2] = i[s + 2].addInner(a, c, l + 1) : i.splice(s, 0, u, u + a.nodeSize, ao(c, a, l + 1, Ir)), s += 3;
        }
      });
      let o = Qp(s ? e0(t) : t, -r);
      for (let a = 0; a < o.length; a++) o[a].type.valid(e, o[a]) || o.splice(a--, 1);
      return new ut(o.length ? this.local.concat(o).sort(Rr) : this.local, i || this.children);
    }
    remove(e) {
      return e.length == 0 || this == Mt ? this : this.removeInner(e, 0);
    }
    removeInner(e, t) {
      let r = this.children, i = this.local;
      for (let s = 0; s < r.length; s += 3) {
        let o, a = r[s] + t, u = r[s + 1] + t;
        for (let c = 0, h; c < e.length; c++) (h = e[c]) && h.from > a && h.to < u && (e[c] = null, (o || (o = [])).push(h));
        if (!o) continue;
        r == this.children && (r = this.children.slice());
        let l = r[s + 2].removeInner(o, a + 1);
        l != Mt ? r[s + 2] = l : (r.splice(s, 3), s -= 3);
      }
      if (i.length) {
        for (let s = 0, o; s < e.length; s++) if (o = e[s]) for (let a = 0; a < i.length; a++) i[a].eq(o, t) && (i == this.local && (i = this.local.slice()), i.splice(a--, 1));
      }
      return r == this.children && i == this.local ? this : i.length || r.length ? new ut(i, r) : Mt;
    }
    forChild(e, t) {
      if (this == Mt) return this;
      if (t.isLeaf) return ut.empty;
      let r, i;
      for (let a = 0; a < this.children.length; a += 3) if (this.children[a] >= e) {
        this.children[a] == e && (r = this.children[a + 2]);
        break;
      }
      let s = e + 1, o = s + t.content.size;
      for (let a = 0; a < this.local.length; a++) {
        let u = this.local[a];
        if (u.from < o && u.to > s && u.type instanceof ur) {
          let l = Math.max(s, u.from) - s, c = Math.min(o, u.to) - s;
          l < c && (i || (i = [])).push(u.copy(l, c));
        }
      }
      if (i) {
        let a = new ut(i.sort(Rr), Zr);
        return r ? new Zn([
          a,
          r
        ]) : a;
      }
      return r || Mt;
    }
    eq(e) {
      if (this == e) return true;
      if (!(e instanceof ut) || this.local.length != e.local.length || this.children.length != e.children.length) return false;
      for (let t = 0; t < this.local.length; t++) if (!this.local[t].eq(e.local[t])) return false;
      for (let t = 0; t < this.children.length; t += 3) if (this.children[t] != e.children[t] || this.children[t + 1] != e.children[t + 1] || !this.children[t + 2].eq(e.children[t + 2])) return false;
      return true;
    }
    locals(e) {
      return kl(this.localsInner(e));
    }
    localsInner(e) {
      if (this == Mt) return Zr;
      if (e.inlineContent || !this.local.some(ur.is)) return this.local;
      let t = [];
      for (let r = 0; r < this.local.length; r++) this.local[r].type instanceof ur || t.push(this.local[r]);
      return t;
    }
    forEachSet(e) {
      e(this);
    }
  }
  ut.empty = new ut([], []);
  ut.removeOverlap = kl;
  const Mt = ut.empty;
  class Zn {
    constructor(e) {
      this.members = e;
    }
    map(e, t) {
      const r = this.members.map((i) => i.map(e, t, Ir));
      return Zn.from(r);
    }
    forChild(e, t) {
      if (t.isLeaf) return ut.empty;
      let r = [];
      for (let i = 0; i < this.members.length; i++) {
        let s = this.members[i].forChild(e, t);
        s != Mt && (s instanceof Zn ? r = r.concat(s.members) : r.push(s));
      }
      return Zn.from(r);
    }
    eq(e) {
      if (!(e instanceof Zn) || e.members.length != this.members.length) return false;
      for (let t = 0; t < this.members.length; t++) if (!this.members[t].eq(e.members[t])) return false;
      return true;
    }
    locals(e) {
      let t, r = true;
      for (let i = 0; i < this.members.length; i++) {
        let s = this.members[i].localsInner(e);
        if (s.length) if (!t) t = s;
        else {
          r && (t = t.slice(), r = false);
          for (let o = 0; o < s.length; o++) t.push(s[o]);
        }
      }
      return t ? kl(r ? t : t.sort(Rr)) : Zr;
    }
    static from(e) {
      switch (e.length) {
        case 0:
          return Mt;
        case 1:
          return e[0];
        default:
          return new Zn(e.every((t) => t instanceof ut) ? e : e.reduce((t, r) => t.concat(r instanceof ut ? r : r.members), []));
      }
    }
    forEachSet(e) {
      for (let t = 0; t < this.members.length; t++) this.members[t].forEachSet(e);
    }
  }
  function gv(n, e, t, r, i, s, o) {
    let a = n.slice();
    for (let l = 0, c = s; l < t.maps.length; l++) {
      let h = 0;
      t.maps[l].forEach((d, f, p, m) => {
        let b = m - p - (f - d);
        for (let g = 0; g < a.length; g += 3) {
          let w = a[g + 1];
          if (w < 0 || d > w + c - h) continue;
          let v = a[g] + c - h;
          f >= v ? a[g + 1] = d <= v ? -2 : -1 : d >= c && b && (a[g] += b, a[g + 1] += b);
        }
        h += b;
      }), c = t.maps[l].map(c, -1);
    }
    let u = false;
    for (let l = 0; l < a.length; l += 3) if (a[l + 1] < 0) {
      if (a[l + 1] == -2) {
        u = true, a[l + 1] = -1;
        continue;
      }
      let c = t.map(n[l] + s), h = c - i;
      if (h < 0 || h >= r.content.size) {
        u = true;
        continue;
      }
      let d = t.map(n[l + 1] + s, -1), f = d - i, { index: p, offset: m } = r.content.findIndex(h), b = r.maybeChild(p);
      if (b && m == h && m + b.nodeSize == f) {
        let g = a[l + 2].mapInner(t, b, c + 1, n[l] + s + 1, o);
        g != Mt ? (a[l] = h, a[l + 1] = f, a[l + 2] = g) : (a[l + 1] = -2, u = true);
      } else u = true;
    }
    if (u) {
      let l = bv(a, n, e, t, i, s, o), c = ao(l, r, 0, o);
      e = c.local;
      for (let h = 0; h < a.length; h += 3) a[h + 1] < 0 && (a.splice(h, 3), h -= 3);
      for (let h = 0, d = 0; h < c.children.length; h += 3) {
        let f = c.children[h];
        for (; d < a.length && a[d] < f; ) d += 3;
        a.splice(d, 0, c.children[h], c.children[h + 1], c.children[h + 2]);
      }
    }
    return new ut(e.sort(Rr), a);
  }
  function Qp(n, e) {
    if (!e || !n.length) return n;
    let t = [];
    for (let r = 0; r < n.length; r++) {
      let i = n[r];
      t.push(new jt(i.from + e, i.to + e, i.type));
    }
    return t;
  }
  function bv(n, e, t, r, i, s, o) {
    function a(u, l) {
      for (let c = 0; c < u.local.length; c++) {
        let h = u.local[c].map(r, i, l);
        h ? t.push(h) : o.onRemove && o.onRemove(u.local[c].spec);
      }
      for (let c = 0; c < u.children.length; c += 3) a(u.children[c + 2], u.children[c] + l + 1);
    }
    for (let u = 0; u < n.length; u += 3) n[u + 1] == -1 && a(n[u + 2], e[u] + s + 1);
    return t;
  }
  function Zp(n, e, t) {
    if (e.isLeaf) return null;
    let r = t + e.nodeSize, i = null;
    for (let s = 0, o; s < n.length; s++) (o = n[s]) && o.from > t && o.to < r && ((i || (i = [])).push(o), n[s] = null);
    return i;
  }
  function e0(n) {
    let e = [];
    for (let t = 0; t < n.length; t++) n[t] != null && e.push(n[t]);
    return e;
  }
  function ao(n, e, t, r) {
    let i = [], s = false;
    e.forEach((a, u) => {
      let l = Zp(n, a, u + t);
      if (l) {
        s = true;
        let c = ao(l, a, t + u + 1, r);
        c != Mt && i.push(u, u + a.nodeSize, c);
      }
    });
    let o = Qp(s ? e0(n) : n, -t).sort(Rr);
    for (let a = 0; a < o.length; a++) o[a].type.valid(e, o[a]) || (r.onRemove && r.onRemove(o[a].spec), o.splice(a--, 1));
    return o.length || i.length ? new ut(o, i) : Mt;
  }
  function Rr(n, e) {
    return n.from - e.from || n.to - e.to;
  }
  function kl(n) {
    let e = n;
    for (let t = 0; t < e.length - 1; t++) {
      let r = e[t];
      if (r.from != r.to) for (let i = t + 1; i < e.length; i++) {
        let s = e[i];
        if (s.from == r.from) {
          s.to != r.to && (e == n && (e = n.slice()), e[i] = s.copy(s.from, r.to), td(e, i + 1, s.copy(r.to, s.to)));
          continue;
        } else {
          s.from < r.to && (e == n && (e = n.slice()), e[t] = r.copy(r.from, s.from), td(e, i, r.copy(s.from, r.to)));
          break;
        }
      }
    }
    return e;
  }
  function td(n, e, t) {
    for (; e < n.length && Rr(t, n[e]) > 0; ) e++;
    n.splice(e, 0, t);
  }
  function ka(n) {
    let e = [];
    return n.someProp("decorations", (t) => {
      let r = t(n.state);
      r && r != Mt && e.push(r);
    }), n.cursorWrapper && e.push(ut.create(n.state.doc, [
      n.cursorWrapper.deco
    ])), Zn.from(e);
  }
  const yv = {
    childList: true,
    characterData: true,
    characterDataOldValue: true,
    attributes: true,
    attributeOldValue: true,
    subtree: true
  }, vv = qt && or <= 11;
  class wv {
    constructor() {
      this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
    }
    set(e) {
      this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
    }
    clear() {
      this.anchorNode = this.focusNode = null;
    }
    eq(e) {
      return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
    }
  }
  class xv {
    constructor(e, t) {
      this.view = e, this.handleDOMChange = t, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new wv(), this.onCharData = null, this.suppressingSelectionUpdates = false, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((r) => {
        for (let i = 0; i < r.length; i++) this.queue.push(r[i]);
        qt && or <= 11 && r.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
      }), vv && (this.onCharData = (r) => {
        this.queue.push({
          target: r.target,
          type: "characterData",
          oldValue: r.prevValue
        }), this.flushSoon();
      }), this.onSelectionChange = this.onSelectionChange.bind(this);
    }
    flushSoon() {
      this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
        this.flushingSoon = -1, this.flush();
      }, 20));
    }
    forceFlush() {
      this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
    }
    start() {
      this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, yv)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
    }
    stop() {
      if (this.observer) {
        let e = this.observer.takeRecords();
        if (e.length) {
          for (let t = 0; t < e.length; t++) this.queue.push(e[t]);
          window.setTimeout(() => this.flush(), 20);
        }
        this.observer.disconnect();
      }
      this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
    }
    connectSelection() {
      this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
    }
    disconnectSelection() {
      this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
    }
    suppressSelectionUpdates() {
      this.suppressingSelectionUpdates = true, setTimeout(() => this.suppressingSelectionUpdates = false, 50);
    }
    onSelectionChange() {
      if (Gc(this.view)) {
        if (this.suppressingSelectionUpdates) return qn(this.view);
        if (qt && or <= 11 && !this.view.state.selection.empty) {
          let e = this.view.domSelectionRange();
          if (e.focusNode && zr(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset)) return this.flushSoon();
        }
        this.flush();
      }
    }
    setCurSelection() {
      this.currentSelection.set(this.view.domSelectionRange());
    }
    ignoreSelectionChange(e) {
      if (!e.focusNode) return true;
      let t = /* @__PURE__ */ new Set(), r;
      for (let s = e.focusNode; s; s = li(s)) t.add(s);
      for (let s = e.anchorNode; s; s = li(s)) if (t.has(s)) {
        r = s;
        break;
      }
      let i = r && this.view.docView.nearestDesc(r);
      if (i && i.ignoreMutation({
        type: "selection",
        target: r.nodeType == 3 ? r.parentNode : r
      })) return this.setCurSelection(), true;
    }
    pendingRecords() {
      if (this.observer) for (let e of this.observer.takeRecords()) this.queue.push(e);
      return this.queue;
    }
    flush() {
      let { view: e } = this;
      if (!e.docView || this.flushingSoon > -1) return;
      let t = this.pendingRecords();
      t.length && (this.queue = []);
      let r = e.domSelectionRange(), i = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && Gc(e) && !this.ignoreSelectionChange(r), s = -1, o = -1, a = false, u = [];
      if (e.editable) for (let c = 0; c < t.length; c++) {
        let h = this.registerMutation(t[c], u);
        h && (s = s < 0 ? h.from : Math.min(h.from, s), o = o < 0 ? h.to : Math.max(h.to, o), h.typeOver && (a = true));
      }
      if (dn && u.length) {
        let c = u.filter((h) => h.nodeName == "BR");
        if (c.length == 2) {
          let [h, d] = c;
          h.parentNode && h.parentNode.parentNode == d.parentNode ? d.remove() : h.remove();
        } else {
          let { focusNode: h } = this.currentSelection;
          for (let d of c) {
            let f = d.parentNode;
            f && f.nodeName == "LI" && (!h || Tv(e, h) != f) && d.remove();
          }
        }
      }
      let l = null;
      s < 0 && i && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && Bo(r) && (l = ml(e)) && l.eq(Ie.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, qn(e), this.currentSelection.set(r), e.scrollToSelection()) : (s > -1 || i) && (s > -1 && (e.docView.markDirty(s, o), kv(e)), this.handleDOMChange(s, o, a, u), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || qn(e), this.currentSelection.set(r));
    }
    registerMutation(e, t) {
      if (t.indexOf(e.target) > -1) return null;
      let r = this.view.docView.nearestDesc(e.target);
      if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e)) return null;
      if (e.type == "childList") {
        for (let c = 0; c < e.addedNodes.length; c++) {
          let h = e.addedNodes[c];
          t.push(h), h.nodeType == 3 && (this.lastChangedTextNode = h);
        }
        if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target)) return {
          from: r.posBefore,
          to: r.posAfter
        };
        let i = e.previousSibling, s = e.nextSibling;
        if (qt && or <= 11 && e.addedNodes.length) for (let c = 0; c < e.addedNodes.length; c++) {
          let { previousSibling: h, nextSibling: d } = e.addedNodes[c];
          (!h || Array.prototype.indexOf.call(e.addedNodes, h) < 0) && (i = h), (!d || Array.prototype.indexOf.call(e.addedNodes, d) < 0) && (s = d);
        }
        let o = i && i.parentNode == e.target ? Ot(i) + 1 : 0, a = r.localPosFromDOM(e.target, o, -1), u = s && s.parentNode == e.target ? Ot(s) : e.target.childNodes.length, l = r.localPosFromDOM(e.target, u, 1);
        return {
          from: a,
          to: l
        };
      } else return e.type == "attributes" ? {
        from: r.posAtStart - r.border,
        to: r.posAtEnd + r.border
      } : (this.lastChangedTextNode = e.target, {
        from: r.posAtStart,
        to: r.posAtEnd,
        typeOver: e.target.nodeValue == e.oldValue
      });
    }
  }
  let nd = /* @__PURE__ */ new WeakMap(), rd = false;
  function kv(n) {
    if (!nd.has(n) && (nd.set(n, null), [
      "normal",
      "nowrap",
      "pre-line"
    ].indexOf(getComputedStyle(n.dom).whiteSpace) !== -1)) {
      if (n.requiresGeckoHackNode = dn, rd) return;
      console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), rd = true;
    }
  }
  function id(n, e) {
    let t = e.startContainer, r = e.startOffset, i = e.endContainer, s = e.endOffset, o = n.domAtPos(n.state.selection.anchor);
    return zr(o.node, o.offset, i, s) && ([t, r, i, s] = [
      i,
      s,
      t,
      r
    ]), {
      anchorNode: t,
      anchorOffset: r,
      focusNode: i,
      focusOffset: s
    };
  }
  function Sv(n, e) {
    if (e.getComposedRanges) {
      let i = e.getComposedRanges(n.root)[0];
      if (i) return id(n, i);
    }
    let t;
    function r(i) {
      i.preventDefault(), i.stopImmediatePropagation(), t = i.getTargetRanges()[0];
    }
    return n.dom.addEventListener("beforeinput", r, true), document.execCommand("indent"), n.dom.removeEventListener("beforeinput", r, true), t ? id(n, t) : null;
  }
  function Tv(n, e) {
    for (let t = e.parentNode; t && t != n.dom; t = t.parentNode) {
      let r = n.docView.nearestDesc(t, true);
      if (r && r.node.isBlock) return t;
    }
    return null;
  }
  function Ev(n, e, t) {
    let { node: r, fromOffset: i, toOffset: s, from: o, to: a } = n.docView.parseRange(e, t), u = n.domSelectionRange(), l, c = u.anchorNode;
    if (c && n.dom.contains(c.nodeType == 1 ? c : c.parentNode) && (l = [
      {
        node: c,
        offset: u.anchorOffset
      }
    ], Bo(u) || l.push({
      node: u.focusNode,
      offset: u.focusOffset
    })), Nt && n.input.lastKeyCode === 8) for (let b = s; b > i; b--) {
      let g = r.childNodes[b - 1], w = g.pmViewDesc;
      if (g.nodeName == "BR" && !w) {
        s = b;
        break;
      }
      if (!w || w.size) break;
    }
    let h = n.state.doc, d = n.someProp("domParser") || sr.fromSchema(n.state.schema), f = h.resolve(o), p = null, m = d.parse(r, {
      topNode: f.parent,
      topMatch: f.parent.contentMatchAt(f.index()),
      topOpen: true,
      from: i,
      to: s,
      preserveWhitespace: f.parent.type.whitespace == "pre" ? "full" : true,
      findPositions: l,
      ruleFromNode: Cv,
      context: f
    });
    if (l && l[0].pos != null) {
      let b = l[0].pos, g = l[1] && l[1].pos;
      g == null && (g = b), p = {
        anchor: b + o,
        head: g + o
      };
    }
    return {
      doc: m,
      sel: p,
      from: o,
      to: a
    };
  }
  function Cv(n) {
    let e = n.pmViewDesc;
    if (e) return e.parseRule();
    if (n.nodeName == "BR" && n.parentNode) {
      if (Rt && /^(ul|ol)$/i.test(n.parentNode.nodeName)) {
        let t = document.createElement("div");
        return t.appendChild(document.createElement("li")), {
          skip: t
        };
      } else if (n.parentNode.lastChild == n || Rt && /^(tr|table)$/i.test(n.parentNode.nodeName)) return {
        ignore: true
      };
    } else if (n.nodeName == "IMG" && n.getAttribute("mark-placeholder")) return {
      ignore: true
    };
    return null;
  }
  const Ov = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
  function Av(n, e, t, r, i) {
    let s = n.input.compositionPendingChanges || (n.composing ? n.input.compositionID : 0);
    if (n.input.compositionPendingChanges = 0, e < 0) {
      let D = n.input.lastSelectionTime > Date.now() - 50 ? n.input.lastSelectionOrigin : null, I = ml(n, D);
      if (I && !n.state.selection.eq(I)) {
        if (Nt && Fn && n.input.lastKeyCode === 13 && Date.now() - 100 < n.input.lastKeyCodeTime && n.someProp("handleKeyDown", (O) => O(n, Sr(13, "Enter")))) return;
        let C = n.state.tr.setSelection(I);
        D == "pointer" ? C.setMeta("pointer", true) : D == "key" && C.scrollIntoView(), s && C.setMeta("composition", s), n.dispatch(C);
      }
      return;
    }
    let o = n.state.doc.resolve(e), a = o.sharedDepth(t);
    e = o.before(a + 1), t = n.state.doc.resolve(t).after(a + 1);
    let u = n.state.selection, l = Ev(n, e, t), c = n.state.doc, h = c.slice(l.from, l.to), d, f;
    n.input.lastKeyCode === 8 && Date.now() - 100 < n.input.lastKeyCodeTime ? (d = n.state.selection.to, f = "end") : (d = n.state.selection.from, f = "start"), n.input.lastKeyCode = null;
    let p = Pv(h.content, l.doc.content, l.from, d, f);
    if (p && n.input.domChangeCount++, (ci && n.input.lastIOSEnter > Date.now() - 225 || Fn) && i.some((D) => D.nodeType == 1 && !Ov.test(D.nodeName)) && (!p || p.endA >= p.endB) && n.someProp("handleKeyDown", (D) => D(n, Sr(13, "Enter")))) {
      n.input.lastIOSEnter = 0;
      return;
    }
    if (!p) if (r && u instanceof Te && !u.empty && u.$head.sameParent(u.$anchor) && !n.composing && !(l.sel && l.sel.anchor != l.sel.head)) p = {
      start: u.from,
      endA: u.to,
      endB: u.to
    };
    else {
      if (l.sel) {
        let D = sd(n, n.state.doc, l.sel);
        if (D && !D.eq(n.state.selection)) {
          let I = n.state.tr.setSelection(D);
          s && I.setMeta("composition", s), n.dispatch(I);
        }
      }
      return;
    }
    n.state.selection.from < n.state.selection.to && p.start == p.endB && n.state.selection instanceof Te && (p.start > n.state.selection.from && p.start <= n.state.selection.from + 2 && n.state.selection.from >= l.from ? p.start = n.state.selection.from : p.endA < n.state.selection.to && p.endA >= n.state.selection.to - 2 && n.state.selection.to <= l.to && (p.endB += n.state.selection.to - p.endA, p.endA = n.state.selection.to)), qt && or <= 11 && p.endB == p.start + 1 && p.endA == p.start && p.start > l.from && l.doc.textBetween(p.start - l.from - 1, p.start - l.from + 1) == " \xA0" && (p.start--, p.endA--, p.endB--);
    let m = l.doc.resolveNoCache(p.start - l.from), b = l.doc.resolveNoCache(p.endB - l.from), g = c.resolve(p.start), w = m.sameParent(b) && m.parent.inlineContent && g.end() >= p.endA, v;
    if ((ci && n.input.lastIOSEnter > Date.now() - 225 && (!w || i.some((D) => D.nodeName == "DIV" || D.nodeName == "P")) || !w && m.pos < l.doc.content.size && !m.sameParent(b) && (v = Ie.findFrom(l.doc.resolve(m.pos + 1), 1, true)) && v.head == b.pos) && n.someProp("handleKeyDown", (D) => D(n, Sr(13, "Enter")))) {
      n.input.lastIOSEnter = 0;
      return;
    }
    if (n.state.selection.anchor > p.start && Nv(c, p.start, p.endA, m, b) && n.someProp("handleKeyDown", (D) => D(n, Sr(8, "Backspace")))) {
      Fn && Nt && n.domObserver.suppressSelectionUpdates();
      return;
    }
    Nt && p.endB == p.start && (n.input.lastChromeDelete = Date.now()), Fn && !w && m.start() != b.start() && b.parentOffset == 0 && m.depth == b.depth && l.sel && l.sel.anchor == l.sel.head && l.sel.head == p.endA && (p.endB -= 2, b = l.doc.resolveNoCache(p.endB - l.from), setTimeout(() => {
      n.someProp("handleKeyDown", function(D) {
        return D(n, Sr(13, "Enter"));
      });
    }, 20));
    let y = p.start, x = p.endA, k, T, M;
    if (w) {
      if (m.pos == b.pos) qt && or <= 11 && m.parentOffset == 0 && (n.domObserver.suppressSelectionUpdates(), setTimeout(() => qn(n), 20)), k = n.state.tr.delete(y, x), T = c.resolve(p.start).marksAcross(c.resolve(p.endA));
      else if (p.endA == p.endB && (M = Mv(m.parent.content.cut(m.parentOffset, b.parentOffset), g.parent.content.cut(g.parentOffset, p.endA - g.start())))) k = n.state.tr, M.type == "add" ? k.addMark(y, x, M.mark) : k.removeMark(y, x, M.mark);
      else if (m.parent.child(m.index()).isText && m.index() == b.index() - (b.textOffset ? 0 : 1)) {
        let D = m.parent.textBetween(m.parentOffset, b.parentOffset);
        if (n.someProp("handleTextInput", (I) => I(n, y, x, D))) return;
        k = n.state.tr.insertText(D, y, x);
      }
    }
    if (k || (k = n.state.tr.replace(y, x, l.doc.slice(p.start - l.from, p.endB - l.from))), l.sel) {
      let D = sd(n, k.doc, l.sel);
      D && !(Nt && n.composing && D.empty && (p.start != p.endB || n.input.lastChromeDelete < Date.now() - 100) && (D.head == y || D.head == k.mapping.map(x) - 1) || qt && D.empty && D.head == y) && k.setSelection(D);
    }
    T && k.ensureMarks(T), s && k.setMeta("composition", s), n.dispatch(k.scrollIntoView());
  }
  function sd(n, e, t) {
    return Math.max(t.anchor, t.head) > e.content.size ? null : gl(n, e.resolve(t.anchor), e.resolve(t.head));
  }
  function Mv(n, e) {
    let t = n.firstChild.marks, r = e.firstChild.marks, i = t, s = r, o, a, u;
    for (let c = 0; c < r.length; c++) i = r[c].removeFromSet(i);
    for (let c = 0; c < t.length; c++) s = t[c].removeFromSet(s);
    if (i.length == 1 && s.length == 0) a = i[0], o = "add", u = (c) => c.mark(a.addToSet(c.marks));
    else if (i.length == 0 && s.length == 1) a = s[0], o = "remove", u = (c) => c.mark(a.removeFromSet(c.marks));
    else return null;
    let l = [];
    for (let c = 0; c < e.childCount; c++) l.push(u(e.child(c)));
    if (G.from(l).eq(n)) return {
      mark: a,
      type: o
    };
  }
  function Nv(n, e, t, r, i) {
    if (t - e <= i.pos - r.pos || Sa(r, true, false) < i.pos) return false;
    let s = n.resolve(e);
    if (!r.parent.isTextblock) {
      let a = s.nodeAfter;
      return a != null && t == e + a.nodeSize;
    }
    if (s.parentOffset < s.parent.content.size || !s.parent.isTextblock) return false;
    let o = n.resolve(Sa(s, true, true));
    return !o.parent.isTextblock || o.pos > t || Sa(o, true, false) < t ? false : r.parent.content.cut(r.parentOffset).eq(o.parent.content);
  }
  function Sa(n, e, t) {
    let r = n.depth, i = e ? n.end() : n.pos;
    for (; r > 0 && (e || n.indexAfter(r) == n.node(r).childCount); ) r--, i++, e = false;
    if (t) {
      let s = n.node(r).maybeChild(n.indexAfter(r));
      for (; s && !s.isLeaf; ) s = s.firstChild, i++;
    }
    return i;
  }
  function Pv(n, e, t, r, i) {
    let s = n.findDiffStart(e, t);
    if (s == null) return null;
    let { a: o, b: a } = n.findDiffEnd(e, t + n.size, t + e.size);
    if (i == "end") {
      let u = Math.max(0, s - Math.min(o, a));
      r -= o + u - s;
    }
    if (o < s && n.size < e.size) {
      let u = r <= s && r >= o ? s - r : 0;
      s -= u, s && s < e.size && od(e.textBetween(s - 1, s + 1)) && (s += u ? 1 : -1), a = s + (a - o), o = s;
    } else if (a < s) {
      let u = r <= s && r >= a ? s - r : 0;
      s -= u, s && s < n.size && od(n.textBetween(s - 1, s + 1)) && (s += u ? 1 : -1), o = s + (o - a), a = s;
    }
    return {
      start: s,
      endA: o,
      endB: a
    };
  }
  function od(n) {
    if (n.length != 2) return false;
    let e = n.charCodeAt(0), t = n.charCodeAt(1);
    return e >= 56320 && e <= 57343 && t >= 55296 && t <= 56319;
  }
  class Dv {
    constructor(e, t) {
      this._root = null, this.focused = false, this.trackWrites = null, this.mounted = false, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new Xy(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = false, this.dragging = null, this._props = t, this.state = t.state, this.directPlugins = t.plugins || [], this.directPlugins.forEach(dd), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = true)), this.editable = ld(this), ud(this), this.nodeViews = cd(this), this.docView = qc(this.state.doc, ad(this), ka(this), this.dom, this), this.domObserver = new xv(this, (r, i, s, o) => Av(this, r, i, s, o)), this.domObserver.start(), Qy(this), this.updatePluginViews();
    }
    get composing() {
      return this.input.composing;
    }
    get props() {
      if (this._props.state != this.state) {
        let e = this._props;
        this._props = {};
        for (let t in e) this._props[t] = e[t];
        this._props.state = this.state;
      }
      return this._props;
    }
    update(e) {
      e.handleDOMEvents != this._props.handleDOMEvents && $u(this);
      let t = this._props;
      this._props = e, e.plugins && (e.plugins.forEach(dd), this.directPlugins = e.plugins), this.updateStateInner(e.state, t);
    }
    setProps(e) {
      let t = {};
      for (let r in this._props) t[r] = this._props[r];
      t.state = this.state;
      for (let r in e) t[r] = e[r];
      this.update(t);
    }
    updateState(e) {
      this.updateStateInner(e, this._props);
    }
    updateStateInner(e, t) {
      var r;
      let i = this.state, s = false, o = false;
      e.storedMarks && this.composing && (Kp(this), o = true), this.state = e;
      let a = i.plugins != e.plugins || this._props.plugins != t.plugins;
      if (a || this._props.plugins != t.plugins || this._props.nodeViews != t.nodeViews) {
        let f = cd(this);
        Rv(f, this.nodeViews) && (this.nodeViews = f, s = true);
      }
      (a || t.handleDOMEvents != this._props.handleDOMEvents) && $u(this), this.editable = ld(this), ud(this);
      let u = ka(this), l = ad(this), c = i.plugins != e.plugins && !i.doc.eq(e.doc) ? "reset" : e.scrollToSelection > i.scrollToSelection ? "to selection" : "preserve", h = s || !this.docView.matchesNode(e.doc, l, u);
      (h || !e.selection.eq(i.selection)) && (o = true);
      let d = c == "preserve" && o && this.dom.style.overflowAnchor == null && fy(this);
      if (o) {
        this.domObserver.stop();
        let f = h && (qt || Nt) && !this.composing && !i.selection.empty && !e.selection.empty && Iv(i.selection, e.selection);
        if (h) {
          let p = Nt ? this.trackWrites = this.domSelectionRange().focusNode : null;
          this.composing && (this.input.compositionNode = dv(this)), (s || !this.docView.update(e.doc, l, u, this)) && (this.docView.updateOuterDeco(l), this.docView.destroy(), this.docView = qc(e.doc, l, u, this.dom, this)), p && !this.trackWrites && (f = true);
        }
        f || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && Ly(this)) ? qn(this, f) : (Lp(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
      }
      this.updatePluginViews(i), !((r = this.dragging) === null || r === void 0) && r.node && !i.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, i), c == "reset" ? this.dom.scrollTop = 0 : c == "to selection" ? this.scrollToSelection() : d && hy(d);
    }
    scrollToSelection() {
      let e = this.domSelectionRange().focusNode;
      if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) {
        if (!this.someProp("handleScrollToSelection", (t) => t(this))) if (this.state.selection instanceof ye) {
          let t = this.docView.domAfterPos(this.state.selection.from);
          t.nodeType == 1 && _c(this, t.getBoundingClientRect(), e);
        } else _c(this, this.coordsAtPos(this.state.selection.head, 1), e);
      }
    }
    destroyPluginViews() {
      let e;
      for (; e = this.pluginViews.pop(); ) e.destroy && e.destroy();
    }
    updatePluginViews(e) {
      if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
        this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
        for (let t = 0; t < this.directPlugins.length; t++) {
          let r = this.directPlugins[t];
          r.spec.view && this.pluginViews.push(r.spec.view(this));
        }
        for (let t = 0; t < this.state.plugins.length; t++) {
          let r = this.state.plugins[t];
          r.spec.view && this.pluginViews.push(r.spec.view(this));
        }
      } else for (let t = 0; t < this.pluginViews.length; t++) {
        let r = this.pluginViews[t];
        r.update && r.update(this, e);
      }
    }
    updateDraggedNode(e, t) {
      let r = e.node, i = -1;
      if (this.state.doc.nodeAt(r.from) == r.node) i = r.from;
      else {
        let s = r.from + (this.state.doc.content.size - t.doc.content.size);
        (s > 0 && this.state.doc.nodeAt(s)) == r.node && (i = s);
      }
      this.dragging = new Yp(e.slice, e.move, i < 0 ? void 0 : ye.create(this.state.doc, i));
    }
    someProp(e, t) {
      let r = this._props && this._props[e], i;
      if (r != null && (i = t ? t(r) : r)) return i;
      for (let o = 0; o < this.directPlugins.length; o++) {
        let a = this.directPlugins[o].props[e];
        if (a != null && (i = t ? t(a) : a)) return i;
      }
      let s = this.state.plugins;
      if (s) for (let o = 0; o < s.length; o++) {
        let a = s[o].props[e];
        if (a != null && (i = t ? t(a) : a)) return i;
      }
    }
    hasFocus() {
      if (qt) {
        let e = this.root.activeElement;
        if (e == this.dom) return true;
        if (!e || !this.dom.contains(e)) return false;
        for (; e && this.dom != e && this.dom.contains(e); ) {
          if (e.contentEditable == "false") return false;
          e = e.parentElement;
        }
        return true;
      }
      return this.root.activeElement == this.dom;
    }
    focus() {
      this.domObserver.stop(), this.editable && py(this.dom), qn(this), this.domObserver.start();
    }
    get root() {
      let e = this._root;
      if (e == null) {
        for (let t = this.dom.parentNode; t; t = t.parentNode) if (t.nodeType == 9 || t.nodeType == 11 && t.host) return t.getSelection || (Object.getPrototypeOf(t).getSelection = () => t.ownerDocument.getSelection()), this._root = t;
      }
      return e || document;
    }
    updateRoot() {
      this._root = null;
    }
    posAtCoords(e) {
      return vy(this, e);
    }
    coordsAtPos(e, t = 1) {
      return Ap(this, e, t);
    }
    domAtPos(e, t = 0) {
      return this.docView.domFromPos(e, t);
    }
    nodeDOM(e) {
      let t = this.docView.descAt(e);
      return t ? t.nodeDOM : null;
    }
    posAtDOM(e, t, r = -1) {
      let i = this.docView.posFromDOM(e, t, r);
      if (i == null) throw new RangeError("DOM position not inside the editor");
      return i;
    }
    endOfTextblock(e, t) {
      return Ty(this, t || this.state, e);
    }
    pasteHTML(e, t) {
      return Ui(this, "", e, false, t || new ClipboardEvent("paste"));
    }
    pasteText(e, t) {
      return Ui(this, e, null, true, t || new ClipboardEvent("paste"));
    }
    serializeForClipboard(e) {
      return bl(this, e);
    }
    destroy() {
      this.docView && (Zy(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], ka(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, ty());
    }
    get isDestroyed() {
      return this.docView == null;
    }
    dispatchEvent(e) {
      return tv(this, e);
    }
    dispatch(e) {
      let t = this._props.dispatchTransaction;
      t ? t.call(this, e) : this.updateState(this.state.apply(e));
    }
    domSelectionRange() {
      let e = this.domSelection();
      return e ? Rt && this.root.nodeType === 11 && oy(this.dom.ownerDocument) == this.dom && Sv(this, e) || e : {
        focusNode: null,
        focusOffset: 0,
        anchorNode: null,
        anchorOffset: 0
      };
    }
    domSelection() {
      return this.root.getSelection();
    }
  }
  function ad(n) {
    let e = /* @__PURE__ */ Object.create(null);
    return e.class = "ProseMirror", e.contenteditable = String(n.editable), n.someProp("attributes", (t) => {
      if (typeof t == "function" && (t = t(n.state)), t) for (let r in t) r == "class" ? e.class += " " + t[r] : r == "style" ? e.style = (e.style ? e.style + ";" : "") + t[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(t[r]));
    }), e.translate || (e.translate = "no"), [
      jt.node(0, n.state.doc.content.size, e)
    ];
  }
  function ud(n) {
    if (n.markCursor) {
      let e = document.createElement("img");
      e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), n.cursorWrapper = {
        dom: e,
        deco: jt.widget(n.state.selection.from, e, {
          raw: true,
          marks: n.markCursor
        })
      };
    } else n.cursorWrapper = null;
  }
  function ld(n) {
    return !n.someProp("editable", (e) => e(n.state) === false);
  }
  function Iv(n, e) {
    let t = Math.min(n.$anchor.sharedDepth(n.head), e.$anchor.sharedDepth(e.head));
    return n.$anchor.start(t) != e.$anchor.start(t);
  }
  function cd(n) {
    let e = /* @__PURE__ */ Object.create(null);
    function t(r) {
      for (let i in r) Object.prototype.hasOwnProperty.call(e, i) || (e[i] = r[i]);
    }
    return n.someProp("nodeViews", t), n.someProp("markViews", t), e;
  }
  function Rv(n, e) {
    let t = 0, r = 0;
    for (let i in n) {
      if (n[i] != e[i]) return true;
      t++;
    }
    for (let i in e) r++;
    return t != r;
  }
  function dd(n) {
    if (n.spec.state || n.spec.filterTransaction || n.spec.appendTransaction) throw new RangeError("Plugins passed directly to the view must not have a state component");
  }
  const Sl = (n, e) => n.selection.empty ? false : (e && e(n.tr.deleteSelection().scrollIntoView()), true);
  function t0(n, e) {
    let { $cursor: t } = n.selection;
    return !t || (e ? !e.endOfTextblock("backward", n) : t.parentOffset > 0) ? null : t;
  }
  const n0 = (n, e, t) => {
    let r = t0(n, t);
    if (!r) return false;
    let i = Tl(r);
    if (!i) {
      let o = r.blockRange(), a = o && mi(o);
      return a == null ? false : (e && e(n.tr.lift(o, a).scrollIntoView()), true);
    }
    let s = i.nodeBefore;
    if (d0(n, i, e, -1)) return true;
    if (r.parent.content.size == 0 && (di(s, "end") || ye.isSelectable(s))) for (let o = r.depth; ; o--) {
      let a = _o(n.doc, r.before(o), r.after(o), re.empty);
      if (a && a.slice.size < a.to - a.from) {
        if (e) {
          let u = n.tr.step(a);
          u.setSelection(di(s, "end") ? Ie.findFrom(u.doc.resolve(u.mapping.map(i.pos, -1)), -1) : ye.create(u.doc, i.pos - s.nodeSize)), e(u.scrollIntoView());
        }
        return true;
      }
      if (o == 1 || r.node(o - 1).childCount > 1) break;
    }
    return s.isAtom && i.depth == r.depth - 1 ? (e && e(n.tr.delete(i.pos - s.nodeSize, i.pos).scrollIntoView()), true) : false;
  }, _v = (n, e, t) => {
    let r = t0(n, t);
    if (!r) return false;
    let i = Tl(r);
    return i ? r0(n, i, e) : false;
  }, Lv = (n, e, t) => {
    let r = s0(n, t);
    if (!r) return false;
    let i = El(r);
    return i ? r0(n, i, e) : false;
  };
  function r0(n, e, t) {
    let r = e.nodeBefore, i = r, s = e.pos - 1;
    for (; !i.isTextblock; s--) {
      if (i.type.spec.isolating) return false;
      let c = i.lastChild;
      if (!c) return false;
      i = c;
    }
    let o = e.nodeAfter, a = o, u = e.pos + 1;
    for (; !a.isTextblock; u++) {
      if (a.type.spec.isolating) return false;
      let c = a.firstChild;
      if (!c) return false;
      a = c;
    }
    let l = _o(n.doc, s, u, re.empty);
    if (!l || l.from != s || l instanceof xt && l.slice.size >= u - s) return false;
    if (t) {
      let c = n.tr.step(l);
      c.setSelection(Te.create(c.doc, s)), t(c.scrollIntoView());
    }
    return true;
  }
  function di(n, e, t = false) {
    for (let r = n; r; r = e == "start" ? r.firstChild : r.lastChild) {
      if (r.isTextblock) return true;
      if (t && r.childCount != 1) return false;
    }
    return false;
  }
  const i0 = (n, e, t) => {
    let { $head: r, empty: i } = n.selection, s = r;
    if (!i) return false;
    if (r.parent.isTextblock) {
      if (t ? !t.endOfTextblock("backward", n) : r.parentOffset > 0) return false;
      s = Tl(r);
    }
    let o = s && s.nodeBefore;
    return !o || !ye.isSelectable(o) ? false : (e && e(n.tr.setSelection(ye.create(n.doc, s.pos - o.nodeSize)).scrollIntoView()), true);
  };
  function Tl(n) {
    if (!n.parent.type.spec.isolating) for (let e = n.depth - 1; e >= 0; e--) {
      if (n.index(e) > 0) return n.doc.resolve(n.before(e + 1));
      if (n.node(e).type.spec.isolating) break;
    }
    return null;
  }
  function s0(n, e) {
    let { $cursor: t } = n.selection;
    return !t || (e ? !e.endOfTextblock("forward", n) : t.parentOffset < t.parent.content.size) ? null : t;
  }
  const o0 = (n, e, t) => {
    let r = s0(n, t);
    if (!r) return false;
    let i = El(r);
    if (!i) return false;
    let s = i.nodeAfter;
    if (d0(n, i, e, 1)) return true;
    if (r.parent.content.size == 0 && (di(s, "start") || ye.isSelectable(s))) {
      let o = _o(n.doc, r.before(), r.after(), re.empty);
      if (o && o.slice.size < o.to - o.from) {
        if (e) {
          let a = n.tr.step(o);
          a.setSelection(di(s, "start") ? Ie.findFrom(a.doc.resolve(a.mapping.map(i.pos)), 1) : ye.create(a.doc, a.mapping.map(i.pos))), e(a.scrollIntoView());
        }
        return true;
      }
    }
    return s.isAtom && i.depth == r.depth - 1 ? (e && e(n.tr.delete(i.pos, i.pos + s.nodeSize).scrollIntoView()), true) : false;
  }, a0 = (n, e, t) => {
    let { $head: r, empty: i } = n.selection, s = r;
    if (!i) return false;
    if (r.parent.isTextblock) {
      if (t ? !t.endOfTextblock("forward", n) : r.parentOffset < r.parent.content.size) return false;
      s = El(r);
    }
    let o = s && s.nodeAfter;
    return !o || !ye.isSelectable(o) ? false : (e && e(n.tr.setSelection(ye.create(n.doc, s.pos)).scrollIntoView()), true);
  };
  function El(n) {
    if (!n.parent.type.spec.isolating) for (let e = n.depth - 1; e >= 0; e--) {
      let t = n.node(e);
      if (n.index(e) + 1 < t.childCount) return n.doc.resolve(n.after(e + 1));
      if (t.type.spec.isolating) break;
    }
    return null;
  }
  const Bv = (n, e) => {
    let t = n.selection, r = t instanceof ye, i;
    if (r) {
      if (t.node.isTextblock || !hr(n.doc, t.from)) return false;
      i = t.from;
    } else if (i = Ro(n.doc, t.from, -1), i == null) return false;
    if (e) {
      let s = n.tr.join(i);
      r && s.setSelection(ye.create(s.doc, i - n.doc.resolve(i).nodeBefore.nodeSize)), e(s.scrollIntoView());
    }
    return true;
  }, Fv = (n, e) => {
    let t = n.selection, r;
    if (t instanceof ye) {
      if (t.node.isTextblock || !hr(n.doc, t.to)) return false;
      r = t.to;
    } else if (r = Ro(n.doc, t.to, 1), r == null) return false;
    return e && e(n.tr.join(r).scrollIntoView()), true;
  }, zv = (n, e) => {
    let { $from: t, $to: r } = n.selection, i = t.blockRange(r), s = i && mi(i);
    return s == null ? false : (e && e(n.tr.lift(i, s).scrollIntoView()), true);
  }, u0 = (n, e) => {
    let { $head: t, $anchor: r } = n.selection;
    return !t.parent.type.spec.code || !t.sameParent(r) ? false : (e && e(n.tr.insertText(`
`).scrollIntoView()), true);
  };
  function Cl(n) {
    for (let e = 0; e < n.edgeCount; e++) {
      let { type: t } = n.edge(e);
      if (t.isTextblock && !t.hasRequiredAttrs()) return t;
    }
    return null;
  }
  const jv = (n, e) => {
    let { $head: t, $anchor: r } = n.selection;
    if (!t.parent.type.spec.code || !t.sameParent(r)) return false;
    let i = t.node(-1), s = t.indexAfter(-1), o = Cl(i.contentMatchAt(s));
    if (!o || !i.canReplaceWith(s, s, o)) return false;
    if (e) {
      let a = t.after(), u = n.tr.replaceWith(a, a, o.createAndFill());
      u.setSelection(Ie.near(u.doc.resolve(a), 1)), e(u.scrollIntoView());
    }
    return true;
  }, l0 = (n, e) => {
    let t = n.selection, { $from: r, $to: i } = t;
    if (t instanceof Wt || r.parent.inlineContent || i.parent.inlineContent) return false;
    let s = Cl(i.parent.contentMatchAt(i.indexAfter()));
    if (!s || !s.isTextblock) return false;
    if (e) {
      let o = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos, a = n.tr.insert(o, s.createAndFill());
      a.setSelection(Te.create(a.doc, o + 1)), e(a.scrollIntoView());
    }
    return true;
  }, c0 = (n, e) => {
    let { $cursor: t } = n.selection;
    if (!t || t.parent.content.size) return false;
    if (t.depth > 1 && t.after() != t.end(-1)) {
      let s = t.before();
      if (jn(n.doc, s)) return e && e(n.tr.split(s).scrollIntoView()), true;
    }
    let r = t.blockRange(), i = r && mi(r);
    return i == null ? false : (e && e(n.tr.lift(r, i).scrollIntoView()), true);
  };
  function qv(n) {
    return (e, t) => {
      let { $from: r, $to: i } = e.selection;
      if (e.selection instanceof ye && e.selection.node.isBlock) return !r.parentOffset || !jn(e.doc, r.pos) ? false : (t && t(e.tr.split(r.pos).scrollIntoView()), true);
      if (!r.depth) return false;
      let s = [], o, a, u = false, l = false;
      for (let f = r.depth; ; f--) if (r.node(f).isBlock) {
        u = r.end(f) == r.pos + (r.depth - f), l = r.start(f) == r.pos - (r.depth - f), a = Cl(r.node(f - 1).contentMatchAt(r.indexAfter(f - 1))), s.unshift(u && a ? {
          type: a
        } : null), o = f;
        break;
      } else {
        if (f == 1) return false;
        s.unshift(null);
      }
      let c = e.tr;
      (e.selection instanceof Te || e.selection instanceof Wt) && c.deleteSelection();
      let h = c.mapping.map(r.pos), d = jn(c.doc, h, s.length, s);
      if (d || (s[0] = a ? {
        type: a
      } : null, d = jn(c.doc, h, s.length, s)), c.split(h, s.length, s), !u && l && r.node(o).type != a) {
        let f = c.mapping.map(r.before(o)), p = c.doc.resolve(f);
        a && r.node(o - 1).canReplaceWith(p.index(), p.index() + 1, a) && c.setNodeMarkup(c.mapping.map(r.before(o)), a);
      }
      return t && t(c.scrollIntoView()), true;
    };
  }
  const $v = qv(), Vv = (n, e) => {
    let { $from: t, to: r } = n.selection, i, s = t.sharedDepth(r);
    return s == 0 ? false : (i = t.before(s), e && e(n.tr.setSelection(ye.create(n.doc, i))), true);
  };
  function Hv(n, e, t) {
    let r = e.nodeBefore, i = e.nodeAfter, s = e.index();
    return !r || !i || !r.type.compatibleContent(i.type) ? false : !r.content.size && e.parent.canReplace(s - 1, s) ? (t && t(n.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), true) : !e.parent.canReplace(s, s + 1) || !(i.isTextblock || hr(n.doc, e.pos)) ? false : (t && t(n.tr.join(e.pos).scrollIntoView()), true);
  }
  function d0(n, e, t, r) {
    let i = e.nodeBefore, s = e.nodeAfter, o, a, u = i.type.spec.isolating || s.type.spec.isolating;
    if (!u && Hv(n, e, t)) return true;
    let l = !u && e.parent.canReplace(e.index(), e.index() + 1);
    if (l && (o = (a = i.contentMatchAt(i.childCount)).findWrapping(s.type)) && a.matchType(o[0] || s.type).validEnd) {
      if (t) {
        let f = e.pos + s.nodeSize, p = G.empty;
        for (let g = o.length - 1; g >= 0; g--) p = G.from(o[g].create(null, p));
        p = G.from(i.copy(p));
        let m = n.tr.step(new kt(e.pos - 1, f, e.pos, f, new re(p, 1, 0), o.length, true)), b = m.doc.resolve(f + 2 * o.length);
        b.nodeAfter && b.nodeAfter.type == i.type && hr(m.doc, b.pos) && m.join(b.pos), t(m.scrollIntoView());
      }
      return true;
    }
    let c = s.type.spec.isolating || r > 0 && u ? null : Ie.findFrom(e, 1), h = c && c.$from.blockRange(c.$to), d = h && mi(h);
    if (d != null && d >= e.depth) return t && t(n.tr.lift(h, d).scrollIntoView()), true;
    if (l && di(s, "start", true) && di(i, "end")) {
      let f = i, p = [];
      for (; p.push(f), !f.isTextblock; ) f = f.lastChild;
      let m = s, b = 1;
      for (; !m.isTextblock; m = m.firstChild) b++;
      if (f.canReplace(f.childCount, f.childCount, m.content)) {
        if (t) {
          let g = G.empty;
          for (let v = p.length - 1; v >= 0; v--) g = G.from(p[v].copy(g));
          let w = n.tr.step(new kt(e.pos - p.length, e.pos + s.nodeSize, e.pos + b, e.pos + s.nodeSize - b, new re(g, p.length, 0), 0, true));
          t(w.scrollIntoView());
        }
        return true;
      }
    }
    return false;
  }
  function f0(n) {
    return function(e, t) {
      let r = e.selection, i = n < 0 ? r.$from : r.$to, s = i.depth;
      for (; i.node(s).isInline; ) {
        if (!s) return false;
        s--;
      }
      return i.node(s).isTextblock ? (t && t(e.tr.setSelection(Te.create(e.doc, n < 0 ? i.start(s) : i.end(s)))), true) : false;
    };
  }
  const Wv = f0(-1), Uv = f0(1);
  function Gv(n, e = null) {
    return function(t, r) {
      let { $from: i, $to: s } = t.selection, o = i.blockRange(s), a = o && fl(o, n, e);
      return a ? (r && r(t.tr.wrap(o, a).scrollIntoView()), true) : false;
    };
  }
  function fd(n, e = null) {
    return function(t, r) {
      let i = false;
      for (let s = 0; s < t.selection.ranges.length && !i; s++) {
        let { $from: { pos: o }, $to: { pos: a } } = t.selection.ranges[s];
        t.doc.nodesBetween(o, a, (u, l) => {
          if (i) return false;
          if (!(!u.isTextblock || u.hasMarkup(n, e))) if (u.type == n) i = true;
          else {
            let c = t.doc.resolve(l), h = c.index();
            i = c.parent.canReplaceWith(h, h + 1, n);
          }
        });
      }
      if (!i) return false;
      if (r) {
        let s = t.tr;
        for (let o = 0; o < t.selection.ranges.length; o++) {
          let { $from: { pos: a }, $to: { pos: u } } = t.selection.ranges[o];
          s.setBlockType(a, u, n, e);
        }
        r(s.scrollIntoView());
      }
      return true;
    };
  }
  function Ol(...n) {
    return function(e, t, r) {
      for (let i = 0; i < n.length; i++) if (n[i](e, t, r)) return true;
      return false;
    };
  }
  Ol(Sl, n0, i0);
  Ol(Sl, o0, a0);
  Ol(u0, l0, c0, $v);
  typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
  function Kv(n, e = null) {
    return function(t, r) {
      let { $from: i, $to: s } = t.selection, o = i.blockRange(s);
      if (!o) return false;
      let a = r ? t.tr : null;
      return Jv(a, o, n, e) ? (r && r(a.scrollIntoView()), true) : false;
    };
  }
  function Jv(n, e, t, r = null) {
    let i = false, s = e, o = e.$from.doc;
    if (e.depth >= 2 && e.$from.node(e.depth - 1).type.compatibleContent(t) && e.startIndex == 0) {
      if (e.$from.index(e.depth - 1) == 0) return false;
      let u = o.resolve(e.start - 2);
      s = new to(u, u, e.depth), e.endIndex < e.parent.childCount && (e = new to(e.$from, o.resolve(e.$to.end(e.depth)), e.depth)), i = true;
    }
    let a = fl(s, t, r, e);
    return a ? (n && Yv(n, e, a, i, t), true) : false;
  }
  function Yv(n, e, t, r, i) {
    let s = G.empty;
    for (let c = t.length - 1; c >= 0; c--) s = G.from(t[c].type.create(t[c].attrs, s));
    n.step(new kt(e.start - (r ? 2 : 0), e.end, e.start, e.end, new re(s, 0, 0), t.length, true));
    let o = 0;
    for (let c = 0; c < t.length; c++) t[c].type == i && (o = c + 1);
    let a = t.length - o, u = e.start + t.length - (r ? 2 : 0), l = e.parent;
    for (let c = e.startIndex, h = e.endIndex, d = true; c < h; c++, d = false) !d && jn(n.doc, u, a) && (n.split(u, a), u += 2 * a), u += l.child(c).nodeSize;
    return n;
  }
  function Xv(n) {
    return function(e, t) {
      let { $from: r, $to: i } = e.selection, s = r.blockRange(i, (o) => o.childCount > 0 && o.firstChild.type == n);
      return s ? t ? r.node(s.depth - 1).type == n ? Qv(e, t, n, s) : Zv(e, t, s) : true : false;
    };
  }
  function Qv(n, e, t, r) {
    let i = n.tr, s = r.end, o = r.$to.end(r.depth);
    s < o && (i.step(new kt(s - 1, o, s, o, new re(G.from(t.create(null, r.parent.copy())), 1, 0), 1, true)), r = new to(i.doc.resolve(r.$from.pos), i.doc.resolve(o), r.depth));
    const a = mi(r);
    if (a == null) return false;
    i.lift(r, a);
    let u = i.doc.resolve(i.mapping.map(s, -1) - 1);
    return hr(i.doc, u.pos) && u.nodeBefore.type == u.nodeAfter.type && i.join(u.pos), e(i.scrollIntoView()), true;
  }
  function Zv(n, e, t) {
    let r = n.tr, i = t.parent;
    for (let f = t.end, p = t.endIndex - 1, m = t.startIndex; p > m; p--) f -= i.child(p).nodeSize, r.delete(f - 1, f + 1);
    let s = r.doc.resolve(t.start), o = s.nodeAfter;
    if (r.mapping.map(t.end) != t.start + s.nodeAfter.nodeSize) return false;
    let a = t.startIndex == 0, u = t.endIndex == i.childCount, l = s.node(-1), c = s.index(-1);
    if (!l.canReplace(c + (a ? 0 : 1), c + 1, o.content.append(u ? G.empty : G.from(i)))) return false;
    let h = s.pos, d = h + o.nodeSize;
    return r.step(new kt(h - (a ? 1 : 0), d + (u ? 1 : 0), h + 1, d - 1, new re((a ? G.empty : G.from(i.copy(G.empty))).append(u ? G.empty : G.from(i.copy(G.empty))), a ? 0 : 1, u ? 0 : 1), a ? 0 : 1)), e(r.scrollIntoView()), true;
  }
  function ew(n) {
    return function(e, t) {
      let { $from: r, $to: i } = e.selection, s = r.blockRange(i, (l) => l.childCount > 0 && l.firstChild.type == n);
      if (!s) return false;
      let o = s.startIndex;
      if (o == 0) return false;
      let a = s.parent, u = a.child(o - 1);
      if (u.type != n) return false;
      if (t) {
        let l = u.lastChild && u.lastChild.type == a.type, c = G.from(l ? n.create() : null), h = new re(G.from(n.create(null, G.from(a.type.create(null, c)))), l ? 3 : 1, 0), d = s.start, f = s.end;
        t(e.tr.step(new kt(d - (l ? 3 : 1), f, d, f, h, 1, true)).scrollIntoView());
      }
      return true;
    };
  }
  function jo(n) {
    const { state: e, transaction: t } = n;
    let { selection: r } = t, { doc: i } = t, { storedMarks: s } = t;
    return {
      ...e,
      apply: e.apply.bind(e),
      applyTransaction: e.applyTransaction.bind(e),
      plugins: e.plugins,
      schema: e.schema,
      reconfigure: e.reconfigure.bind(e),
      toJSON: e.toJSON.bind(e),
      get storedMarks() {
        return s;
      },
      get selection() {
        return r;
      },
      get doc() {
        return i;
      },
      get tr() {
        return r = t.selection, i = t.doc, s = t.storedMarks, t;
      }
    };
  }
  class qo {
    constructor(e) {
      this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state;
    }
    get hasCustomState() {
      return !!this.customState;
    }
    get state() {
      return this.customState || this.editor.state;
    }
    get commands() {
      const { rawCommands: e, editor: t, state: r } = this, { view: i } = t, { tr: s } = r, o = this.buildProps(s);
      return Object.fromEntries(Object.entries(e).map(([a, u]) => [
        a,
        (...c) => {
          const h = u(...c)(o);
          return !s.getMeta("preventDispatch") && !this.hasCustomState && i.dispatch(s), h;
        }
      ]));
    }
    get chain() {
      return () => this.createChain();
    }
    get can() {
      return () => this.createCan();
    }
    createChain(e, t = true) {
      const { rawCommands: r, editor: i, state: s } = this, { view: o } = i, a = [], u = !!e, l = e || s.tr, c = () => (!u && t && !l.getMeta("preventDispatch") && !this.hasCustomState && o.dispatch(l), a.every((d) => d === true)), h = {
        ...Object.fromEntries(Object.entries(r).map(([d, f]) => [
          d,
          (...m) => {
            const b = this.buildProps(l, t), g = f(...m)(b);
            return a.push(g), h;
          }
        ])),
        run: c
      };
      return h;
    }
    createCan(e) {
      const { rawCommands: t, state: r } = this, i = false, s = e || r.tr, o = this.buildProps(s, i);
      return {
        ...Object.fromEntries(Object.entries(t).map(([u, l]) => [
          u,
          (...c) => l(...c)({
            ...o,
            dispatch: void 0
          })
        ])),
        chain: () => this.createChain(s, i)
      };
    }
    buildProps(e, t = true) {
      const { rawCommands: r, editor: i, state: s } = this, { view: o } = i, a = {
        tr: e,
        editor: i,
        view: o,
        state: jo({
          state: s,
          transaction: e
        }),
        dispatch: t ? () => {
        } : void 0,
        chain: () => this.createChain(e, t),
        can: () => this.createCan(e),
        get commands() {
          return Object.fromEntries(Object.entries(r).map(([u, l]) => [
            u,
            (...c) => l(...c)(a)
          ]));
        }
      };
      return a;
    }
  }
  class tw {
    constructor() {
      this.callbacks = {};
    }
    on(e, t) {
      return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(t), this;
    }
    emit(e, ...t) {
      const r = this.callbacks[e];
      return r && r.forEach((i) => i.apply(this, t)), this;
    }
    off(e, t) {
      const r = this.callbacks[e];
      return r && (t ? this.callbacks[e] = r.filter((i) => i !== t) : delete this.callbacks[e]), this;
    }
    once(e, t) {
      const r = (...i) => {
        this.off(e, r), t.apply(this, i);
      };
      return this.on(e, r);
    }
    removeAllListeners() {
      this.callbacks = {};
    }
  }
  function oe(n, e, t) {
    return n.config[e] === void 0 && n.parent ? oe(n.parent, e, t) : typeof n.config[e] == "function" ? n.config[e].bind({
      ...t,
      parent: n.parent ? oe(n.parent, e, t) : null
    }) : n.config[e];
  }
  function $o(n) {
    const e = n.filter((i) => i.type === "extension"), t = n.filter((i) => i.type === "node"), r = n.filter((i) => i.type === "mark");
    return {
      baseExtensions: e,
      nodeExtensions: t,
      markExtensions: r
    };
  }
  function h0(n) {
    const e = [], { nodeExtensions: t, markExtensions: r } = $o(n), i = [
      ...t,
      ...r
    ], s = {
      default: null,
      rendered: true,
      renderHTML: null,
      parseHTML: null,
      keepOnSplit: true,
      isRequired: false
    };
    return n.forEach((o) => {
      const a = {
        name: o.name,
        options: o.options,
        storage: o.storage,
        extensions: i
      }, u = oe(o, "addGlobalAttributes", a);
      if (!u) return;
      u().forEach((c) => {
        c.types.forEach((h) => {
          Object.entries(c.attributes).forEach(([d, f]) => {
            e.push({
              type: h,
              name: d,
              attribute: {
                ...s,
                ...f
              }
            });
          });
        });
      });
    }), i.forEach((o) => {
      const a = {
        name: o.name,
        options: o.options,
        storage: o.storage
      }, u = oe(o, "addAttributes", a);
      if (!u) return;
      const l = u();
      Object.entries(l).forEach(([c, h]) => {
        const d = {
          ...s,
          ...h
        };
        typeof d?.default == "function" && (d.default = d.default()), d?.isRequired && d?.default === void 0 && delete d.default, e.push({
          type: o.name,
          name: c,
          attribute: d
        });
      });
    }), e;
  }
  function Tt(n, e) {
    if (typeof n == "string") {
      if (!e.nodes[n]) throw Error(`There is no node type named '${n}'. Maybe you forgot to add the extension?`);
      return e.nodes[n];
    }
    return n;
  }
  function ot(...n) {
    return n.filter((e) => !!e).reduce((e, t) => {
      const r = {
        ...e
      };
      return Object.entries(t).forEach(([i, s]) => {
        if (!r[i]) {
          r[i] = s;
          return;
        }
        if (i === "class") {
          const a = s ? String(s).split(" ") : [], u = r[i] ? r[i].split(" ") : [], l = a.filter((c) => !u.includes(c));
          r[i] = [
            ...u,
            ...l
          ].join(" ");
        } else if (i === "style") {
          const a = s ? s.split(";").map((c) => c.trim()).filter(Boolean) : [], u = r[i] ? r[i].split(";").map((c) => c.trim()).filter(Boolean) : [], l = /* @__PURE__ */ new Map();
          u.forEach((c) => {
            const [h, d] = c.split(":").map((f) => f.trim());
            l.set(h, d);
          }), a.forEach((c) => {
            const [h, d] = c.split(":").map((f) => f.trim());
            l.set(h, d);
          }), r[i] = Array.from(l.entries()).map(([c, h]) => `${c}: ${h}`).join("; ");
        } else r[i] = s;
      }), r;
    }, {});
  }
  function Vu(n, e) {
    return e.filter((t) => t.type === n.type.name).filter((t) => t.attribute.rendered).map((t) => t.attribute.renderHTML ? t.attribute.renderHTML(n.attrs) || {} : {
      [t.name]: n.attrs[t.name]
    }).reduce((t, r) => ot(t, r), {});
  }
  function p0(n) {
    return typeof n == "function";
  }
  function Fe(n, e = void 0, ...t) {
    return p0(n) ? e ? n.bind(e)(...t) : n(...t) : n;
  }
  function nw(n = {}) {
    return Object.keys(n).length === 0 && n.constructor === Object;
  }
  function rw(n) {
    return typeof n != "string" ? n : n.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(n) : n === "true" ? true : n === "false" ? false : n;
  }
  function hd(n, e) {
    return "style" in n ? n : {
      ...n,
      getAttrs: (t) => {
        const r = n.getAttrs ? n.getAttrs(t) : n.attrs;
        if (r === false) return false;
        const i = e.reduce((s, o) => {
          const a = o.attribute.parseHTML ? o.attribute.parseHTML(t) : rw(t.getAttribute(o.name));
          return a == null ? s : {
            ...s,
            [o.name]: a
          };
        }, {});
        return {
          ...r,
          ...i
        };
      }
    };
  }
  function pd(n) {
    return Object.fromEntries(Object.entries(n).filter(([e, t]) => e === "attrs" && nw(t) ? false : t != null));
  }
  function m0(n, e) {
    var t;
    const r = h0(n), { nodeExtensions: i, markExtensions: s } = $o(n), o = (t = i.find((l) => oe(l, "topNode"))) === null || t === void 0 ? void 0 : t.name, a = Object.fromEntries(i.map((l) => {
      const c = r.filter((g) => g.type === l.name), h = {
        name: l.name,
        options: l.options,
        storage: l.storage,
        editor: e
      }, d = n.reduce((g, w) => {
        const v = oe(w, "extendNodeSchema", h);
        return {
          ...g,
          ...v ? v(l) : {}
        };
      }, {}), f = pd({
        ...d,
        content: Fe(oe(l, "content", h)),
        marks: Fe(oe(l, "marks", h)),
        group: Fe(oe(l, "group", h)),
        inline: Fe(oe(l, "inline", h)),
        atom: Fe(oe(l, "atom", h)),
        selectable: Fe(oe(l, "selectable", h)),
        draggable: Fe(oe(l, "draggable", h)),
        code: Fe(oe(l, "code", h)),
        whitespace: Fe(oe(l, "whitespace", h)),
        linebreakReplacement: Fe(oe(l, "linebreakReplacement", h)),
        defining: Fe(oe(l, "defining", h)),
        isolating: Fe(oe(l, "isolating", h)),
        attrs: Object.fromEntries(c.map((g) => {
          var w;
          return [
            g.name,
            {
              default: (w = g?.attribute) === null || w === void 0 ? void 0 : w.default
            }
          ];
        }))
      }), p = Fe(oe(l, "parseHTML", h));
      p && (f.parseDOM = p.map((g) => hd(g, c)));
      const m = oe(l, "renderHTML", h);
      m && (f.toDOM = (g) => m({
        node: g,
        HTMLAttributes: Vu(g, c)
      }));
      const b = oe(l, "renderText", h);
      return b && (f.toText = b), [
        l.name,
        f
      ];
    })), u = Object.fromEntries(s.map((l) => {
      const c = r.filter((b) => b.type === l.name), h = {
        name: l.name,
        options: l.options,
        storage: l.storage,
        editor: e
      }, d = n.reduce((b, g) => {
        const w = oe(g, "extendMarkSchema", h);
        return {
          ...b,
          ...w ? w(l) : {}
        };
      }, {}), f = pd({
        ...d,
        inclusive: Fe(oe(l, "inclusive", h)),
        excludes: Fe(oe(l, "excludes", h)),
        group: Fe(oe(l, "group", h)),
        spanning: Fe(oe(l, "spanning", h)),
        code: Fe(oe(l, "code", h)),
        attrs: Object.fromEntries(c.map((b) => {
          var g;
          return [
            b.name,
            {
              default: (g = b?.attribute) === null || g === void 0 ? void 0 : g.default
            }
          ];
        }))
      }), p = Fe(oe(l, "parseHTML", h));
      p && (f.parseDOM = p.map((b) => hd(b, c)));
      const m = oe(l, "renderHTML", h);
      return m && (f.toDOM = (b) => m({
        mark: b,
        HTMLAttributes: Vu(b, c)
      })), [
        l.name,
        f
      ];
    }));
    return new np({
      topNode: o,
      nodes: a,
      marks: u
    });
  }
  function Ta(n, e) {
    return e.nodes[n] || e.marks[n] || null;
  }
  function md(n, e) {
    return Array.isArray(e) ? e.some((t) => (typeof t == "string" ? t : t.name) === n.name) : e;
  }
  function Vo(n, e) {
    const t = Vr.fromSchema(e).serializeFragment(n), i = document.implementation.createHTMLDocument().createElement("div");
    return i.appendChild(t), i.innerHTML;
  }
  const iw = (n, e = 500) => {
    let t = "";
    const r = n.parentOffset;
    return n.parent.nodesBetween(Math.max(0, r - e), r, (i, s, o, a) => {
      var u, l;
      const c = ((l = (u = i.type.spec).toText) === null || l === void 0 ? void 0 : l.call(u, {
        node: i,
        pos: s,
        parent: o,
        index: a
      })) || i.textContent || "%leaf%";
      t += i.isAtom && !i.isText ? c : c.slice(0, Math.max(0, r - s));
    }), t;
  };
  function Al(n) {
    return Object.prototype.toString.call(n) === "[object RegExp]";
  }
  class Ho {
    constructor(e) {
      this.find = e.find, this.handler = e.handler;
    }
  }
  const sw = (n, e) => {
    if (Al(e)) return e.exec(n);
    const t = e(n);
    if (!t) return null;
    const r = [
      t.text
    ];
    return r.index = t.index, r.input = n, r.data = t.data, t.replaceWith && (t.text.includes(t.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), r.push(t.replaceWith)), r;
  };
  function ps(n) {
    var e;
    const { editor: t, from: r, to: i, text: s, rules: o, plugin: a } = n, { view: u } = t;
    if (u.composing) return false;
    const l = u.state.doc.resolve(r);
    if (l.parent.type.spec.code || !((e = l.nodeBefore || l.nodeAfter) === null || e === void 0) && e.marks.find((d) => d.type.spec.code)) return false;
    let c = false;
    const h = iw(l) + s;
    return o.forEach((d) => {
      if (c) return;
      const f = sw(h, d.find);
      if (!f) return;
      const p = u.state.tr, m = jo({
        state: u.state,
        transaction: p
      }), b = {
        from: r - (f[0].length - s.length),
        to: i
      }, { commands: g, chain: w, can: v } = new qo({
        editor: t,
        state: m
      });
      d.handler({
        state: m,
        range: b,
        match: f,
        commands: g,
        chain: w,
        can: v
      }) === null || !p.steps.length || (p.setMeta(a, {
        transform: p,
        from: r,
        to: i,
        text: s
      }), u.dispatch(p), c = true);
    }), c;
  }
  function ow(n) {
    const { editor: e, rules: t } = n, r = new Dt({
      state: {
        init() {
          return null;
        },
        apply(i, s, o) {
          const a = i.getMeta(r);
          if (a) return a;
          const u = i.getMeta("applyInputRules");
          return !!u && setTimeout(() => {
            let { text: c } = u;
            typeof c == "string" ? c = c : c = Vo(G.from(c), o.schema);
            const { from: h } = u, d = h + c.length;
            ps({
              editor: e,
              from: h,
              to: d,
              text: c,
              rules: t,
              plugin: r
            });
          }), i.selectionSet || i.docChanged ? null : s;
        }
      },
      props: {
        handleTextInput(i, s, o, a) {
          return ps({
            editor: e,
            from: s,
            to: o,
            text: a,
            rules: t,
            plugin: r
          });
        },
        handleDOMEvents: {
          compositionend: (i) => (setTimeout(() => {
            const { $cursor: s } = i.state.selection;
            s && ps({
              editor: e,
              from: s.pos,
              to: s.pos,
              text: "",
              rules: t,
              plugin: r
            });
          }), false)
        },
        handleKeyDown(i, s) {
          if (s.key !== "Enter") return false;
          const { $cursor: o } = i.state.selection;
          return o ? ps({
            editor: e,
            from: o.pos,
            to: o.pos,
            text: `
`,
            rules: t,
            plugin: r
          }) : false;
        }
      },
      isInputRules: true
    });
    return r;
  }
  function aw(n) {
    return Object.prototype.toString.call(n).slice(8, -1);
  }
  function ms(n) {
    return aw(n) !== "Object" ? false : n.constructor === Object && Object.getPrototypeOf(n) === Object.prototype;
  }
  function Wo(n, e) {
    const t = {
      ...n
    };
    return ms(n) && ms(e) && Object.keys(e).forEach((r) => {
      ms(e[r]) && ms(n[r]) ? t[r] = Wo(n[r], e[r]) : t[r] = e[r];
    }), t;
  }
  class cr {
    constructor(e = {}) {
      this.type = "mark", this.name = "mark", this.parent = null, this.child = null, this.config = {
        name: this.name,
        defaultOptions: {}
      }, this.config = {
        ...this.config,
        ...e
      }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Fe(oe(this, "addOptions", {
        name: this.name
      }))), this.storage = Fe(oe(this, "addStorage", {
        name: this.name,
        options: this.options
      })) || {};
    }
    static create(e = {}) {
      return new cr(e);
    }
    configure(e = {}) {
      const t = this.extend({
        ...this.config,
        addOptions: () => Wo(this.options, e)
      });
      return t.name = this.name, t.parent = this.parent, t;
    }
    extend(e = {}) {
      const t = new cr(e);
      return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = Fe(oe(t, "addOptions", {
        name: t.name
      })), t.storage = Fe(oe(t, "addStorage", {
        name: t.name,
        options: t.options
      })), t;
    }
    static handleExit({ editor: e, mark: t }) {
      const { tr: r } = e.state, i = e.state.selection.$from;
      if (i.pos === i.end()) {
        const o = i.marks();
        if (!!!o.find((l) => l?.type.name === t.name)) return false;
        const u = o.find((l) => l?.type.name === t.name);
        return u && r.removeStoredMark(u), r.insertText(" ", i.pos), e.view.dispatch(r), true;
      }
      return false;
    }
  }
  function uw(n) {
    return typeof n == "number";
  }
  class lw {
    constructor(e) {
      this.find = e.find, this.handler = e.handler;
    }
  }
  const cw = (n, e, t) => {
    if (Al(e)) return [
      ...n.matchAll(e)
    ];
    const r = e(n, t);
    return r ? r.map((i) => {
      const s = [
        i.text
      ];
      return s.index = i.index, s.input = n, s.data = i.data, i.replaceWith && (i.text.includes(i.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), s.push(i.replaceWith)), s;
    }) : [];
  };
  function dw(n) {
    const { editor: e, state: t, from: r, to: i, rule: s, pasteEvent: o, dropEvent: a } = n, { commands: u, chain: l, can: c } = new qo({
      editor: e,
      state: t
    }), h = [];
    return t.doc.nodesBetween(r, i, (f, p) => {
      if (!f.isTextblock || f.type.spec.code) return;
      const m = Math.max(r, p), b = Math.min(i, p + f.content.size), g = f.textBetween(m - p, b - p, void 0, "\uFFFC");
      cw(g, s.find, o).forEach((v) => {
        if (v.index === void 0) return;
        const y = m + v.index + 1, x = y + v[0].length, k = {
          from: t.tr.mapping.map(y),
          to: t.tr.mapping.map(x)
        }, T = s.handler({
          state: t,
          range: k,
          match: v,
          commands: u,
          chain: l,
          can: c,
          pasteEvent: o,
          dropEvent: a
        });
        h.push(T);
      });
    }), h.every((f) => f !== null);
  }
  let gs = null;
  const fw = (n) => {
    var e;
    const t = new ClipboardEvent("paste", {
      clipboardData: new DataTransfer()
    });
    return (e = t.clipboardData) === null || e === void 0 || e.setData("text/html", n), t;
  };
  function hw(n) {
    const { editor: e, rules: t } = n;
    let r = null, i = false, s = false, o = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, a;
    try {
      a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
    } catch {
      a = null;
    }
    const u = ({ state: c, from: h, to: d, rule: f, pasteEvt: p }) => {
      const m = c.tr, b = jo({
        state: c,
        transaction: m
      });
      if (!(!dw({
        editor: e,
        state: b,
        from: Math.max(h - 1, 0),
        to: d.b - 1,
        rule: f,
        pasteEvent: p,
        dropEvent: a
      }) || !m.steps.length)) {
        try {
          a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
        } catch {
          a = null;
        }
        return o = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, m;
      }
    };
    return t.map((c) => new Dt({
      view(h) {
        const d = (p) => {
          var m;
          r = !((m = h.dom.parentElement) === null || m === void 0) && m.contains(p.target) ? h.dom.parentElement : null, r && (gs = e);
        }, f = () => {
          gs && (gs = null);
        };
        return window.addEventListener("dragstart", d), window.addEventListener("dragend", f), {
          destroy() {
            window.removeEventListener("dragstart", d), window.removeEventListener("dragend", f);
          }
        };
      },
      props: {
        handleDOMEvents: {
          drop: (h, d) => {
            if (s = r === h.dom.parentElement, a = d, !s) {
              const f = gs;
              f && setTimeout(() => {
                const p = f.state.selection;
                p && f.commands.deleteRange({
                  from: p.from,
                  to: p.to
                });
              }, 10);
            }
            return false;
          },
          paste: (h, d) => {
            var f;
            const p = (f = d.clipboardData) === null || f === void 0 ? void 0 : f.getData("text/html");
            return o = d, i = !!p?.includes("data-pm-slice"), false;
          }
        }
      },
      appendTransaction: (h, d, f) => {
        const p = h[0], m = p.getMeta("uiEvent") === "paste" && !i, b = p.getMeta("uiEvent") === "drop" && !s, g = p.getMeta("applyPasteRules"), w = !!g;
        if (!m && !b && !w) return;
        if (w) {
          let { text: x } = g;
          typeof x == "string" ? x = x : x = Vo(G.from(x), f.schema);
          const { from: k } = g, T = k + x.length, M = fw(x);
          return u({
            rule: c,
            state: f,
            from: k,
            to: {
              b: T
            },
            pasteEvt: M
          });
        }
        const v = d.doc.content.findDiffStart(f.doc.content), y = d.doc.content.findDiffEnd(f.doc.content);
        if (!(!uw(v) || !y || v === y.b)) return u({
          rule: c,
          state: f,
          from: v,
          to: y,
          pasteEvt: o
        });
      }
    }));
  }
  function pw(n) {
    const e = n.filter((t, r) => n.indexOf(t) !== r);
    return Array.from(new Set(e));
  }
  class Or {
    constructor(e, t) {
      this.splittableMarks = [], this.editor = t, this.extensions = Or.resolve(e), this.schema = m0(this.extensions, t), this.setupExtensions();
    }
    static resolve(e) {
      const t = Or.sort(Or.flatten(e)), r = pw(t.map((i) => i.name));
      return r.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${r.map((i) => `'${i}'`).join(", ")}]. This can lead to issues.`), t;
    }
    static flatten(e) {
      return e.map((t) => {
        const r = {
          name: t.name,
          options: t.options,
          storage: t.storage
        }, i = oe(t, "addExtensions", r);
        return i ? [
          t,
          ...this.flatten(i())
        ] : t;
      }).flat(10);
    }
    static sort(e) {
      return e.sort((r, i) => {
        const s = oe(r, "priority") || 100, o = oe(i, "priority") || 100;
        return s > o ? -1 : s < o ? 1 : 0;
      });
    }
    get commands() {
      return this.extensions.reduce((e, t) => {
        const r = {
          name: t.name,
          options: t.options,
          storage: t.storage,
          editor: this.editor,
          type: Ta(t.name, this.schema)
        }, i = oe(t, "addCommands", r);
        return i ? {
          ...e,
          ...i()
        } : e;
      }, {});
    }
    get plugins() {
      const { editor: e } = this, t = Or.sort([
        ...this.extensions
      ].reverse()), r = [], i = [], s = t.map((o) => {
        const a = {
          name: o.name,
          options: o.options,
          storage: o.storage,
          editor: e,
          type: Ta(o.name, this.schema)
        }, u = [], l = oe(o, "addKeyboardShortcuts", a);
        let c = {};
        if (o.type === "mark" && oe(o, "exitable", a) && (c.ArrowRight = () => cr.handleExit({
          editor: e,
          mark: o
        })), l) {
          const m = Object.fromEntries(Object.entries(l()).map(([b, g]) => [
            b,
            () => g({
              editor: e
            })
          ]));
          c = {
            ...c,
            ...m
          };
        }
        const h = wp(c);
        u.push(h);
        const d = oe(o, "addInputRules", a);
        md(o, e.options.enableInputRules) && d && r.push(...d());
        const f = oe(o, "addPasteRules", a);
        md(o, e.options.enablePasteRules) && f && i.push(...f());
        const p = oe(o, "addProseMirrorPlugins", a);
        if (p) {
          const m = p();
          u.push(...m);
        }
        return u;
      }).flat();
      return [
        ow({
          editor: e,
          rules: r
        }),
        ...hw({
          editor: e,
          rules: i
        }),
        ...s
      ];
    }
    get attributes() {
      return h0(this.extensions);
    }
    get nodeViews() {
      const { editor: e } = this, { nodeExtensions: t } = $o(this.extensions);
      return Object.fromEntries(t.filter((r) => !!oe(r, "addNodeView")).map((r) => {
        const i = this.attributes.filter((u) => u.type === r.name), s = {
          name: r.name,
          options: r.options,
          storage: r.storage,
          editor: e,
          type: Tt(r.name, this.schema)
        }, o = oe(r, "addNodeView", s);
        if (!o) return [];
        const a = (u, l, c, h, d) => {
          const f = Vu(u, i);
          return o()({
            node: u,
            view: l,
            getPos: c,
            decorations: h,
            innerDecorations: d,
            editor: e,
            extension: r,
            HTMLAttributes: f
          });
        };
        return [
          r.name,
          a
        ];
      }));
    }
    setupExtensions() {
      this.extensions.forEach((e) => {
        var t;
        this.editor.extensionStorage[e.name] = e.storage;
        const r = {
          name: e.name,
          options: e.options,
          storage: e.storage,
          editor: this.editor,
          type: Ta(e.name, this.schema)
        };
        e.type === "mark" && (!((t = Fe(oe(e, "keepOnSplit", r))) !== null && t !== void 0) || t) && this.splittableMarks.push(e.name);
        const i = oe(e, "onBeforeCreate", r), s = oe(e, "onCreate", r), o = oe(e, "onUpdate", r), a = oe(e, "onSelectionUpdate", r), u = oe(e, "onTransaction", r), l = oe(e, "onFocus", r), c = oe(e, "onBlur", r), h = oe(e, "onDestroy", r);
        i && this.editor.on("beforeCreate", i), s && this.editor.on("create", s), o && this.editor.on("update", o), a && this.editor.on("selectionUpdate", a), u && this.editor.on("transaction", u), l && this.editor.on("focus", l), c && this.editor.on("blur", c), h && this.editor.on("destroy", h);
      });
    }
  }
  class At {
    constructor(e = {}) {
      this.type = "extension", this.name = "extension", this.parent = null, this.child = null, this.config = {
        name: this.name,
        defaultOptions: {}
      }, this.config = {
        ...this.config,
        ...e
      }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Fe(oe(this, "addOptions", {
        name: this.name
      }))), this.storage = Fe(oe(this, "addStorage", {
        name: this.name,
        options: this.options
      })) || {};
    }
    static create(e = {}) {
      return new At(e);
    }
    configure(e = {}) {
      const t = this.extend({
        ...this.config,
        addOptions: () => Wo(this.options, e)
      });
      return t.name = this.name, t.parent = this.parent, t;
    }
    extend(e = {}) {
      const t = new At({
        ...this.config,
        ...e
      });
      return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = Fe(oe(t, "addOptions", {
        name: t.name
      })), t.storage = Fe(oe(t, "addStorage", {
        name: t.name,
        options: t.options
      })), t;
    }
  }
  function g0(n, e, t) {
    const { from: r, to: i } = e, { blockSeparator: s = `

`, textSerializers: o = {} } = t || {};
    let a = "";
    return n.nodesBetween(r, i, (u, l, c, h) => {
      var d;
      u.isBlock && l > r && (a += s);
      const f = o?.[u.type.name];
      if (f) return c && (a += f({
        node: u,
        pos: l,
        parent: c,
        index: h,
        range: e
      })), false;
      u.isText && (a += (d = u?.text) === null || d === void 0 ? void 0 : d.slice(Math.max(r, l) - l, i - l));
    }), a;
  }
  function b0(n) {
    return Object.fromEntries(Object.entries(n.nodes).filter(([, e]) => e.spec.toText).map(([e, t]) => [
      e,
      t.spec.toText
    ]));
  }
  const mw = At.create({
    name: "clipboardTextSerializer",
    addOptions() {
      return {
        blockSeparator: void 0
      };
    },
    addProseMirrorPlugins() {
      return [
        new Dt({
          key: new Vt("clipboardTextSerializer"),
          props: {
            clipboardTextSerializer: () => {
              const { editor: n } = this, { state: e, schema: t } = n, { doc: r, selection: i } = e, { ranges: s } = i, o = Math.min(...s.map((c) => c.$from.pos)), a = Math.max(...s.map((c) => c.$to.pos)), u = b0(t);
              return g0(r, {
                from: o,
                to: a
              }, {
                ...this.options.blockSeparator !== void 0 ? {
                  blockSeparator: this.options.blockSeparator
                } : {},
                textSerializers: u
              });
            }
          }
        })
      ];
    }
  }), gw = () => ({ editor: n, view: e }) => (requestAnimationFrame(() => {
    var t;
    n.isDestroyed || (e.dom.blur(), (t = window?.getSelection()) === null || t === void 0 || t.removeAllRanges());
  }), true), bw = (n = false) => ({ commands: e }) => e.setContent("", n), yw = () => ({ state: n, tr: e, dispatch: t }) => {
    const { selection: r } = e, { ranges: i } = r;
    return t && i.forEach(({ $from: s, $to: o }) => {
      n.doc.nodesBetween(s.pos, o.pos, (a, u) => {
        if (a.type.isText) return;
        const { doc: l, mapping: c } = e, h = l.resolve(c.map(u)), d = l.resolve(c.map(u + a.nodeSize)), f = h.blockRange(d);
        if (!f) return;
        const p = mi(f);
        if (a.type.isTextblock) {
          const { defaultType: m } = h.parent.contentMatchAt(h.index());
          e.setNodeMarkup(f.start, m);
        }
        (p || p === 0) && e.lift(f, p);
      });
    }), true;
  }, vw = (n) => (e) => n(e), ww = () => ({ state: n, dispatch: e }) => l0(n, e), xw = (n, e) => ({ editor: t, tr: r }) => {
    const { state: i } = t, s = i.doc.slice(n.from, n.to);
    r.deleteRange(n.from, n.to);
    const o = r.mapping.map(e);
    return r.insert(o, s.content), r.setSelection(new Te(r.doc.resolve(o - 1))), true;
  }, kw = () => ({ tr: n, dispatch: e }) => {
    const { selection: t } = n, r = t.$anchor.node();
    if (r.content.size > 0) return false;
    const i = n.selection.$anchor;
    for (let s = i.depth; s > 0; s -= 1) if (i.node(s).type === r.type) {
      if (e) {
        const a = i.before(s), u = i.after(s);
        n.delete(a, u).scrollIntoView();
      }
      return true;
    }
    return false;
  }, Sw = (n) => ({ tr: e, state: t, dispatch: r }) => {
    const i = Tt(n, t.schema), s = e.selection.$anchor;
    for (let o = s.depth; o > 0; o -= 1) if (s.node(o).type === i) {
      if (r) {
        const u = s.before(o), l = s.after(o);
        e.delete(u, l).scrollIntoView();
      }
      return true;
    }
    return false;
  }, Tw = (n) => ({ tr: e, dispatch: t }) => {
    const { from: r, to: i } = n;
    return t && e.delete(r, i), true;
  }, Ew = () => ({ state: n, dispatch: e }) => Sl(n, e), Cw = () => ({ commands: n }) => n.keyboardShortcut("Enter"), Ow = () => ({ state: n, dispatch: e }) => jv(n, e);
  function uo(n, e, t = {
    strict: true
  }) {
    const r = Object.keys(e);
    return r.length ? r.every((i) => t.strict ? e[i] === n[i] : Al(e[i]) ? e[i].test(n[i]) : e[i] === n[i]) : true;
  }
  function y0(n, e, t = {}) {
    return n.find((r) => r.type === e && uo(Object.fromEntries(Object.keys(t).map((i) => [
      i,
      r.attrs[i]
    ])), t));
  }
  function gd(n, e, t = {}) {
    return !!y0(n, e, t);
  }
  function Ml(n, e, t) {
    var r;
    if (!n || !e) return;
    let i = n.parent.childAfter(n.parentOffset);
    if ((!i.node || !i.node.marks.some((c) => c.type === e)) && (i = n.parent.childBefore(n.parentOffset)), !i.node || !i.node.marks.some((c) => c.type === e) || (t = t || ((r = i.node.marks[0]) === null || r === void 0 ? void 0 : r.attrs), !y0([
      ...i.node.marks
    ], e, t))) return;
    let o = i.index, a = n.start() + i.offset, u = o + 1, l = a + i.node.nodeSize;
    for (; o > 0 && gd([
      ...n.parent.child(o - 1).marks
    ], e, t); ) o -= 1, a -= n.parent.child(o).nodeSize;
    for (; u < n.parent.childCount && gd([
      ...n.parent.child(u).marks
    ], e, t); ) l += n.parent.child(u).nodeSize, u += 1;
    return {
      from: a,
      to: l
    };
  }
  function mr(n, e) {
    if (typeof n == "string") {
      if (!e.marks[n]) throw Error(`There is no mark type named '${n}'. Maybe you forgot to add the extension?`);
      return e.marks[n];
    }
    return n;
  }
  const Aw = (n, e = {}) => ({ tr: t, state: r, dispatch: i }) => {
    const s = mr(n, r.schema), { doc: o, selection: a } = t, { $from: u, from: l, to: c } = a;
    if (i) {
      const h = Ml(u, s, e);
      if (h && h.from <= l && h.to >= c) {
        const d = Te.create(o, h.from, h.to);
        t.setSelection(d);
      }
    }
    return true;
  }, Mw = (n) => (e) => {
    const t = typeof n == "function" ? n(e) : n;
    for (let r = 0; r < t.length; r += 1) if (t[r](e)) return true;
    return false;
  };
  function v0(n) {
    return n instanceof Te;
  }
  function Ar(n = 0, e = 0, t = 0) {
    return Math.min(Math.max(n, e), t);
  }
  function w0(n, e = null) {
    if (!e) return null;
    const t = Ie.atStart(n), r = Ie.atEnd(n);
    if (e === "start" || e === true) return t;
    if (e === "end") return r;
    const i = t.from, s = r.to;
    return e === "all" ? Te.create(n, Ar(0, i, s), Ar(n.content.size, i, s)) : Te.create(n, Ar(e, i, s), Ar(e, i, s));
  }
  function Nw() {
    return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
  }
  function Nl() {
    return [
      "iPad Simulator",
      "iPhone Simulator",
      "iPod Simulator",
      "iPad",
      "iPhone",
      "iPod"
    ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
  }
  const Pw = (n = null, e = {}) => ({ editor: t, view: r, tr: i, dispatch: s }) => {
    e = {
      scrollIntoView: true,
      ...e
    };
    const o = () => {
      (Nl() || Nw()) && r.dom.focus(), requestAnimationFrame(() => {
        t.isDestroyed || (r.focus(), e?.scrollIntoView && t.commands.scrollIntoView());
      });
    };
    if (r.hasFocus() && n === null || n === false) return true;
    if (s && n === null && !v0(t.state.selection)) return o(), true;
    const a = w0(i.doc, n) || t.state.selection, u = t.state.selection.eq(a);
    return s && (u || i.setSelection(a), u && i.storedMarks && i.setStoredMarks(i.storedMarks), o()), true;
  }, Dw = (n, e) => (t) => n.every((r, i) => e(r, {
    ...t,
    index: i
  })), Iw = (n, e) => ({ tr: t, commands: r }) => r.insertContentAt({
    from: t.selection.from,
    to: t.selection.to
  }, n, e), x0 = (n) => {
    const e = n.childNodes;
    for (let t = e.length - 1; t >= 0; t -= 1) {
      const r = e[t];
      r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue) ? n.removeChild(r) : r.nodeType === 1 && x0(r);
    }
    return n;
  };
  function bs(n) {
    const e = `<body>${n}</body>`, t = new window.DOMParser().parseFromString(e, "text/html").body;
    return x0(t);
  }
  function lo(n, e, t) {
    if (n instanceof zn || n instanceof G) return n;
    t = {
      slice: true,
      parseOptions: {},
      ...t
    };
    const r = typeof n == "object" && n !== null, i = typeof n == "string";
    if (r) try {
      if (Array.isArray(n) && n.length > 0) return G.fromArray(n.map((a) => e.nodeFromJSON(a)));
      const o = e.nodeFromJSON(n);
      return t.errorOnInvalidContent && o.check(), o;
    } catch (s) {
      if (t.errorOnInvalidContent) throw new Error("[tiptap error]: Invalid JSON content", {
        cause: s
      });
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", n, "Error:", s), lo("", e, t);
    }
    if (i) {
      if (t.errorOnInvalidContent) {
        let o = false, a = "";
        const u = new np({
          topNode: e.spec.topNode,
          marks: e.spec.marks,
          nodes: e.spec.nodes.append({
            __tiptap__private__unknown__catch__all__node: {
              content: "inline*",
              group: "block",
              parseDOM: [
                {
                  tag: "*",
                  getAttrs: (l) => (o = true, a = typeof l == "string" ? l : l.outerHTML, null)
                }
              ]
            }
          })
        });
        if (t.slice ? sr.fromSchema(u).parseSlice(bs(n), t.parseOptions) : sr.fromSchema(u).parse(bs(n), t.parseOptions), t.errorOnInvalidContent && o) throw new Error("[tiptap error]: Invalid HTML content", {
          cause: new Error(`Invalid element found: ${a}`)
        });
      }
      const s = sr.fromSchema(e);
      return t.slice ? s.parseSlice(bs(n), t.parseOptions).content : s.parse(bs(n), t.parseOptions);
    }
    return lo("", e, t);
  }
  function Rw(n, e, t) {
    const r = n.steps.length - 1;
    if (r < e) return;
    const i = n.steps[r];
    if (!(i instanceof xt || i instanceof kt)) return;
    const s = n.mapping.maps[r];
    let o = 0;
    s.forEach((a, u, l, c) => {
      o === 0 && (o = c);
    }), n.setSelection(Ie.near(n.doc.resolve(o), t));
  }
  const _w = (n) => !("type" in n), Lw = (n, e, t) => ({ tr: r, dispatch: i, editor: s }) => {
    var o;
    if (i) {
      t = {
        parseOptions: s.options.parseOptions,
        updateSelection: true,
        applyInputRules: false,
        applyPasteRules: false,
        ...t
      };
      let a;
      try {
        a = lo(e, s.schema, {
          parseOptions: {
            preserveWhitespace: "full",
            ...t.parseOptions
          },
          errorOnInvalidContent: (o = t.errorOnInvalidContent) !== null && o !== void 0 ? o : s.options.enableContentCheck
        });
      } catch (p) {
        return s.emit("contentError", {
          editor: s,
          error: p,
          disableCollaboration: () => {
            s.storage.collaboration && (s.storage.collaboration.isDisabled = true);
          }
        }), false;
      }
      let { from: u, to: l } = typeof n == "number" ? {
        from: n,
        to: n
      } : {
        from: n.from,
        to: n.to
      }, c = true, h = true;
      if ((_w(a) ? a : [
        a
      ]).forEach((p) => {
        p.check(), c = c ? p.isText && p.marks.length === 0 : false, h = h ? p.isBlock : false;
      }), u === l && h) {
        const { parent: p } = r.doc.resolve(u);
        p.isTextblock && !p.type.spec.code && !p.childCount && (u -= 1, l += 1);
      }
      let f;
      if (c) {
        if (Array.isArray(e)) f = e.map((p) => p.text || "").join("");
        else if (e instanceof G) {
          let p = "";
          e.forEach((m) => {
            m.text && (p += m.text);
          }), f = p;
        } else typeof e == "object" && e && e.text ? f = e.text : f = e;
        r.insertText(f, u, l);
      } else f = a, r.replaceWith(u, l, f);
      t.updateSelection && Rw(r, r.steps.length - 1, -1), t.applyInputRules && r.setMeta("applyInputRules", {
        from: u,
        text: f
      }), t.applyPasteRules && r.setMeta("applyPasteRules", {
        from: u,
        text: f
      });
    }
    return true;
  }, Bw = () => ({ state: n, dispatch: e }) => Bv(n, e), Fw = () => ({ state: n, dispatch: e }) => Fv(n, e), zw = () => ({ state: n, dispatch: e }) => n0(n, e), jw = () => ({ state: n, dispatch: e }) => o0(n, e), qw = () => ({ state: n, dispatch: e, tr: t }) => {
    try {
      const r = Ro(n.doc, n.selection.$from.pos, -1);
      return r == null ? false : (t.join(r, 2), e && e(t), true);
    } catch {
      return false;
    }
  }, $w = () => ({ state: n, dispatch: e, tr: t }) => {
    try {
      const r = Ro(n.doc, n.selection.$from.pos, 1);
      return r == null ? false : (t.join(r, 2), e && e(t), true);
    } catch {
      return false;
    }
  }, Vw = () => ({ state: n, dispatch: e }) => _v(n, e), Hw = () => ({ state: n, dispatch: e }) => Lv(n, e);
  function k0() {
    return typeof navigator < "u" ? /Mac/.test(navigator.platform) : false;
  }
  function Ww(n) {
    const e = n.split(/-(?!$)/);
    let t = e[e.length - 1];
    t === "Space" && (t = " ");
    let r, i, s, o;
    for (let a = 0; a < e.length - 1; a += 1) {
      const u = e[a];
      if (/^(cmd|meta|m)$/i.test(u)) o = true;
      else if (/^a(lt)?$/i.test(u)) r = true;
      else if (/^(c|ctrl|control)$/i.test(u)) i = true;
      else if (/^s(hift)?$/i.test(u)) s = true;
      else if (/^mod$/i.test(u)) Nl() || k0() ? o = true : i = true;
      else throw new Error(`Unrecognized modifier name: ${u}`);
    }
    return r && (t = `Alt-${t}`), i && (t = `Ctrl-${t}`), o && (t = `Meta-${t}`), s && (t = `Shift-${t}`), t;
  }
  const Uw = (n) => ({ editor: e, view: t, tr: r, dispatch: i }) => {
    const s = Ww(n).split(/-(?!$)/), o = s.find((l) => ![
      "Alt",
      "Ctrl",
      "Meta",
      "Shift"
    ].includes(l)), a = new KeyboardEvent("keydown", {
      key: o === "Space" ? " " : o,
      altKey: s.includes("Alt"),
      ctrlKey: s.includes("Ctrl"),
      metaKey: s.includes("Meta"),
      shiftKey: s.includes("Shift"),
      bubbles: true,
      cancelable: true
    }), u = e.captureTransaction(() => {
      t.someProp("handleKeyDown", (l) => l(t, a));
    });
    return u?.steps.forEach((l) => {
      const c = l.map(r.mapping);
      c && i && r.maybeStep(c);
    }), true;
  };
  function Ki(n, e, t = {}) {
    const { from: r, to: i, empty: s } = n.selection, o = e ? Tt(e, n.schema) : null, a = [];
    n.doc.nodesBetween(r, i, (h, d) => {
      if (h.isText) return;
      const f = Math.max(r, d), p = Math.min(i, d + h.nodeSize);
      a.push({
        node: h,
        from: f,
        to: p
      });
    });
    const u = i - r, l = a.filter((h) => o ? o.name === h.node.type.name : true).filter((h) => uo(h.node.attrs, t, {
      strict: false
    }));
    return s ? !!l.length : l.reduce((h, d) => h + d.to - d.from, 0) >= u;
  }
  const Gw = (n, e = {}) => ({ state: t, dispatch: r }) => {
    const i = Tt(n, t.schema);
    return Ki(t, i, e) ? zv(t, r) : false;
  }, Kw = () => ({ state: n, dispatch: e }) => c0(n, e), Jw = (n) => ({ state: e, dispatch: t }) => {
    const r = Tt(n, e.schema);
    return Xv(r)(e, t);
  }, Yw = () => ({ state: n, dispatch: e }) => u0(n, e);
  function Uo(n, e) {
    return e.nodes[n] ? "node" : e.marks[n] ? "mark" : null;
  }
  function bd(n, e) {
    const t = typeof e == "string" ? [
      e
    ] : e;
    return Object.keys(n).reduce((r, i) => (t.includes(i) || (r[i] = n[i]), r), {});
  }
  const Xw = (n, e) => ({ tr: t, state: r, dispatch: i }) => {
    let s = null, o = null;
    const a = Uo(typeof n == "string" ? n : n.name, r.schema);
    return a ? (a === "node" && (s = Tt(n, r.schema)), a === "mark" && (o = mr(n, r.schema)), i && t.selection.ranges.forEach((u) => {
      r.doc.nodesBetween(u.$from.pos, u.$to.pos, (l, c) => {
        s && s === l.type && t.setNodeMarkup(c, void 0, bd(l.attrs, e)), o && l.marks.length && l.marks.forEach((h) => {
          o === h.type && t.addMark(c, c + l.nodeSize, o.create(bd(h.attrs, e)));
        });
      });
    }), true) : false;
  }, Qw = () => ({ tr: n, dispatch: e }) => (e && n.scrollIntoView(), true), Zw = () => ({ tr: n, dispatch: e }) => {
    if (e) {
      const t = new Wt(n.doc);
      n.setSelection(t);
    }
    return true;
  }, e2 = () => ({ state: n, dispatch: e }) => i0(n, e), t2 = () => ({ state: n, dispatch: e }) => a0(n, e), n2 = () => ({ state: n, dispatch: e }) => Vv(n, e), r2 = () => ({ state: n, dispatch: e }) => Uv(n, e), i2 = () => ({ state: n, dispatch: e }) => Wv(n, e);
  function Hu(n, e, t = {}, r = {}) {
    return lo(n, e, {
      slice: false,
      parseOptions: t,
      errorOnInvalidContent: r.errorOnInvalidContent
    });
  }
  const s2 = (n, e = false, t = {}, r = {}) => ({ editor: i, tr: s, dispatch: o, commands: a }) => {
    var u, l;
    const { doc: c } = s;
    if (t.preserveWhitespace !== "full") {
      const h = Hu(n, i.schema, t, {
        errorOnInvalidContent: (u = r.errorOnInvalidContent) !== null && u !== void 0 ? u : i.options.enableContentCheck
      });
      return o && s.replaceWith(0, c.content.size, h).setMeta("preventUpdate", !e), true;
    }
    return o && s.setMeta("preventUpdate", !e), a.insertContentAt({
      from: 0,
      to: c.content.size
    }, n, {
      parseOptions: t,
      errorOnInvalidContent: (l = r.errorOnInvalidContent) !== null && l !== void 0 ? l : i.options.enableContentCheck
    });
  };
  function S0(n, e) {
    const t = mr(e, n.schema), { from: r, to: i, empty: s } = n.selection, o = [];
    s ? (n.storedMarks && o.push(...n.storedMarks), o.push(...n.selection.$head.marks())) : n.doc.nodesBetween(r, i, (u) => {
      o.push(...u.marks);
    });
    const a = o.find((u) => u.type.name === t.name);
    return a ? {
      ...a.attrs
    } : {};
  }
  function o2(n) {
    for (let e = 0; e < n.edgeCount; e += 1) {
      const { type: t } = n.edge(e);
      if (t.isTextblock && !t.hasRequiredAttrs()) return t;
    }
    return null;
  }
  function a2(n, e) {
    for (let t = n.depth; t > 0; t -= 1) {
      const r = n.node(t);
      if (e(r)) return {
        pos: t > 0 ? n.before(t) : 0,
        start: n.start(t),
        depth: t,
        node: r
      };
    }
  }
  function Pl(n) {
    return (e) => a2(e.$from, n);
  }
  function T0(n, e) {
    const t = Or.resolve(n);
    return m0(t, e);
  }
  function u2(n, e) {
    const t = T0(e), r = zn.fromJSON(t, n);
    return Vo(r.content, t);
  }
  function l2(n, e) {
    const t = {
      from: 0,
      to: n.content.size
    };
    return g0(n, t, e);
  }
  function c2(n, e) {
    const t = Tt(e, n.schema), { from: r, to: i } = n.selection, s = [];
    n.doc.nodesBetween(r, i, (a) => {
      s.push(a);
    });
    const o = s.reverse().find((a) => a.type.name === t.name);
    return o ? {
      ...o.attrs
    } : {};
  }
  function d2(n, e) {
    const t = Uo(typeof e == "string" ? e : e.name, n.schema);
    return t === "node" ? c2(n, e) : t === "mark" ? S0(n, e) : {};
  }
  function E0(n, e, t) {
    const r = [];
    return n === e ? t.resolve(n).marks().forEach((i) => {
      const s = t.resolve(n), o = Ml(s, i.type);
      o && r.push({
        mark: i,
        ...o
      });
    }) : t.nodesBetween(n, e, (i, s) => {
      !i || i?.nodeSize === void 0 || r.push(...i.marks.map((o) => ({
        from: s,
        to: s + i.nodeSize,
        mark: o
      })));
    }), r;
  }
  function $s(n, e, t) {
    return Object.fromEntries(Object.entries(t).filter(([r]) => {
      const i = n.find((s) => s.type === e && s.name === r);
      return i ? i.attribute.keepOnSplit : false;
    }));
  }
  function Wu(n, e, t = {}) {
    const { empty: r, ranges: i } = n.selection, s = e ? mr(e, n.schema) : null;
    if (r) return !!(n.storedMarks || n.selection.$from.marks()).filter((h) => s ? s.name === h.type.name : true).find((h) => uo(h.attrs, t, {
      strict: false
    }));
    let o = 0;
    const a = [];
    if (i.forEach(({ $from: h, $to: d }) => {
      const f = h.pos, p = d.pos;
      n.doc.nodesBetween(f, p, (m, b) => {
        if (!m.isText && !m.marks.length) return;
        const g = Math.max(f, b), w = Math.min(p, b + m.nodeSize), v = w - g;
        o += v, a.push(...m.marks.map((y) => ({
          mark: y,
          from: g,
          to: w
        })));
      });
    }), o === 0) return false;
    const u = a.filter((h) => s ? s.name === h.mark.type.name : true).filter((h) => uo(h.mark.attrs, t, {
      strict: false
    })).reduce((h, d) => h + d.to - d.from, 0), l = a.filter((h) => s ? h.mark.type !== s && h.mark.type.excludes(s) : true).reduce((h, d) => h + d.to - d.from, 0);
    return (u > 0 ? u + l : u) >= o;
  }
  function f2(n, e, t = {}) {
    if (!e) return Ki(n, null, t) || Wu(n, null, t);
    const r = Uo(e, n.schema);
    return r === "node" ? Ki(n, e, t) : r === "mark" ? Wu(n, e, t) : false;
  }
  function yd(n, e) {
    const { nodeExtensions: t } = $o(e), r = t.find((o) => o.name === n);
    if (!r) return false;
    const i = {
      name: r.name,
      options: r.options,
      storage: r.storage
    }, s = Fe(oe(r, "group", i));
    return typeof s != "string" ? false : s.split(" ").includes("list");
  }
  function Go(n, { checkChildren: e = true, ignoreWhitespace: t = false } = {}) {
    var r;
    if (t) {
      if (n.type.name === "hardBreak") return true;
      if (n.isText) return /^\s*$/m.test((r = n.text) !== null && r !== void 0 ? r : "");
    }
    if (n.isText) return !n.text;
    if (n.isAtom || n.isLeaf) return false;
    if (n.content.childCount === 0) return true;
    if (e) {
      let i = true;
      return n.content.forEach((s) => {
        i !== false && (Go(s, {
          ignoreWhitespace: t,
          checkChildren: e
        }) || (i = false));
      }), i;
    }
    return false;
  }
  function h2(n) {
    return n instanceof ye;
  }
  function p2(n, e, t) {
    var r;
    const { selection: i } = e;
    let s = null;
    if (v0(i) && (s = i.$cursor), s) {
      const a = (r = n.storedMarks) !== null && r !== void 0 ? r : s.marks();
      return !!t.isInSet(a) || !a.some((u) => u.type.excludes(t));
    }
    const { ranges: o } = i;
    return o.some(({ $from: a, $to: u }) => {
      let l = a.depth === 0 ? n.doc.inlineContent && n.doc.type.allowsMarkType(t) : false;
      return n.doc.nodesBetween(a.pos, u.pos, (c, h, d) => {
        if (l) return false;
        if (c.isInline) {
          const f = !d || d.type.allowsMarkType(t), p = !!t.isInSet(c.marks) || !c.marks.some((m) => m.type.excludes(t));
          l = f && p;
        }
        return !l;
      }), l;
    });
  }
  const m2 = (n, e = {}) => ({ tr: t, state: r, dispatch: i }) => {
    const { selection: s } = t, { empty: o, ranges: a } = s, u = mr(n, r.schema);
    if (i) if (o) {
      const l = S0(r, u);
      t.addStoredMark(u.create({
        ...l,
        ...e
      }));
    } else a.forEach((l) => {
      const c = l.$from.pos, h = l.$to.pos;
      r.doc.nodesBetween(c, h, (d, f) => {
        const p = Math.max(f, c), m = Math.min(f + d.nodeSize, h);
        d.marks.find((g) => g.type === u) ? d.marks.forEach((g) => {
          u === g.type && t.addMark(p, m, u.create({
            ...g.attrs,
            ...e
          }));
        }) : t.addMark(p, m, u.create(e));
      });
    });
    return p2(r, t, u);
  }, g2 = (n, e) => ({ tr: t }) => (t.setMeta(n, e), true), b2 = (n, e = {}) => ({ state: t, dispatch: r, chain: i }) => {
    const s = Tt(n, t.schema);
    let o;
    return t.selection.$anchor.sameParent(t.selection.$head) && (o = t.selection.$anchor.parent.attrs), s.isTextblock ? i().command(({ commands: a }) => fd(s, {
      ...o,
      ...e
    })(t) ? true : a.clearNodes()).command(({ state: a }) => fd(s, {
      ...o,
      ...e
    })(a, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), false);
  }, y2 = (n) => ({ tr: e, dispatch: t }) => {
    if (t) {
      const { doc: r } = e, i = Ar(n, 0, r.content.size), s = ye.create(r, i);
      e.setSelection(s);
    }
    return true;
  }, v2 = (n) => ({ tr: e, dispatch: t }) => {
    if (t) {
      const { doc: r } = e, { from: i, to: s } = typeof n == "number" ? {
        from: n,
        to: n
      } : n, o = Te.atStart(r).from, a = Te.atEnd(r).to, u = Ar(i, o, a), l = Ar(s, o, a), c = Te.create(r, u, l);
      e.setSelection(c);
    }
    return true;
  }, w2 = (n) => ({ state: e, dispatch: t }) => {
    const r = Tt(n, e.schema);
    return ew(r)(e, t);
  };
  function vd(n, e) {
    const t = n.storedMarks || n.selection.$to.parentOffset && n.selection.$from.marks();
    if (t) {
      const r = t.filter((i) => e?.includes(i.type.name));
      n.tr.ensureMarks(r);
    }
  }
  const x2 = ({ keepMarks: n = true } = {}) => ({ tr: e, state: t, dispatch: r, editor: i }) => {
    const { selection: s, doc: o } = e, { $from: a, $to: u } = s, l = i.extensionManager.attributes, c = $s(l, a.node().type.name, a.node().attrs);
    if (s instanceof ye && s.node.isBlock) return !a.parentOffset || !jn(o, a.pos) ? false : (r && (n && vd(t, i.extensionManager.splittableMarks), e.split(a.pos).scrollIntoView()), true);
    if (!a.parent.isBlock) return false;
    const h = u.parentOffset === u.parent.content.size, d = a.depth === 0 ? void 0 : o2(a.node(-1).contentMatchAt(a.indexAfter(-1)));
    let f = h && d ? [
      {
        type: d,
        attrs: c
      }
    ] : void 0, p = jn(e.doc, e.mapping.map(a.pos), 1, f);
    if (!f && !p && jn(e.doc, e.mapping.map(a.pos), 1, d ? [
      {
        type: d
      }
    ] : void 0) && (p = true, f = d ? [
      {
        type: d,
        attrs: c
      }
    ] : void 0), r) {
      if (p && (s instanceof Te && e.deleteSelection(), e.split(e.mapping.map(a.pos), 1, f), d && !h && !a.parentOffset && a.parent.type !== d)) {
        const m = e.mapping.map(a.before()), b = e.doc.resolve(m);
        a.node(-1).canReplaceWith(b.index(), b.index() + 1, d) && e.setNodeMarkup(e.mapping.map(a.before()), d);
      }
      n && vd(t, i.extensionManager.splittableMarks), e.scrollIntoView();
    }
    return p;
  }, k2 = (n, e = {}) => ({ tr: t, state: r, dispatch: i, editor: s }) => {
    var o;
    const a = Tt(n, r.schema), { $from: u, $to: l } = r.selection, c = r.selection.node;
    if (c && c.isBlock || u.depth < 2 || !u.sameParent(l)) return false;
    const h = u.node(-1);
    if (h.type !== a) return false;
    const d = s.extensionManager.attributes;
    if (u.parent.content.size === 0 && u.node(-1).childCount === u.indexAfter(-1)) {
      if (u.depth === 2 || u.node(-3).type !== a || u.index(-2) !== u.node(-2).childCount - 1) return false;
      if (i) {
        let g = G.empty;
        const w = u.index(-1) ? 1 : u.index(-2) ? 2 : 3;
        for (let M = u.depth - w; M >= u.depth - 3; M -= 1) g = G.from(u.node(M).copy(g));
        const v = u.indexAfter(-1) < u.node(-2).childCount ? 1 : u.indexAfter(-2) < u.node(-3).childCount ? 2 : 3, y = {
          ...$s(d, u.node().type.name, u.node().attrs),
          ...e
        }, x = ((o = a.contentMatch.defaultType) === null || o === void 0 ? void 0 : o.createAndFill(y)) || void 0;
        g = g.append(G.from(a.createAndFill(null, x) || void 0));
        const k = u.before(u.depth - (w - 1));
        t.replace(k, u.after(-v), new re(g, 4 - w, 0));
        let T = -1;
        t.doc.nodesBetween(k, t.doc.content.size, (M, D) => {
          if (T > -1) return false;
          M.isTextblock && M.content.size === 0 && (T = D + 1);
        }), T > -1 && t.setSelection(Te.near(t.doc.resolve(T))), t.scrollIntoView();
      }
      return true;
    }
    const f = l.pos === u.end() ? h.contentMatchAt(0).defaultType : null, p = {
      ...$s(d, h.type.name, h.attrs),
      ...e
    }, m = {
      ...$s(d, u.node().type.name, u.node().attrs),
      ...e
    };
    t.delete(u.pos, l.pos);
    const b = f ? [
      {
        type: a,
        attrs: p
      },
      {
        type: f,
        attrs: m
      }
    ] : [
      {
        type: a,
        attrs: p
      }
    ];
    if (!jn(t.doc, u.pos, 2)) return false;
    if (i) {
      const { selection: g, storedMarks: w } = r, { splittableMarks: v } = s.extensionManager, y = w || g.$to.parentOffset && g.$from.marks();
      if (t.split(u.pos, 2, b).scrollIntoView(), !y || !i) return true;
      const x = y.filter((k) => v.includes(k.type.name));
      t.ensureMarks(x);
    }
    return true;
  }, Ea = (n, e) => {
    const t = Pl((o) => o.type === e)(n.selection);
    if (!t) return true;
    const r = n.doc.resolve(Math.max(0, t.pos - 1)).before(t.depth);
    if (r === void 0) return true;
    const i = n.doc.nodeAt(r);
    return t.node.type === i?.type && hr(n.doc, t.pos) && n.join(t.pos), true;
  }, Ca = (n, e) => {
    const t = Pl((o) => o.type === e)(n.selection);
    if (!t) return true;
    const r = n.doc.resolve(t.start).after(t.depth);
    if (r === void 0) return true;
    const i = n.doc.nodeAt(r);
    return t.node.type === i?.type && hr(n.doc, r) && n.join(r), true;
  }, S2 = (n, e, t, r = {}) => ({ editor: i, tr: s, state: o, dispatch: a, chain: u, commands: l, can: c }) => {
    const { extensions: h, splittableMarks: d } = i.extensionManager, f = Tt(n, o.schema), p = Tt(e, o.schema), { selection: m, storedMarks: b } = o, { $from: g, $to: w } = m, v = g.blockRange(w), y = b || m.$to.parentOffset && m.$from.marks();
    if (!v) return false;
    const x = Pl((k) => yd(k.type.name, h))(m);
    if (v.depth >= 1 && x && v.depth - x.depth <= 1) {
      if (x.node.type === f) return l.liftListItem(p);
      if (yd(x.node.type.name, h) && f.validContent(x.node.content) && a) return u().command(() => (s.setNodeMarkup(x.pos, f), true)).command(() => Ea(s, f)).command(() => Ca(s, f)).run();
    }
    return !t || !y || !a ? u().command(() => c().wrapInList(f, r) ? true : l.clearNodes()).wrapInList(f, r).command(() => Ea(s, f)).command(() => Ca(s, f)).run() : u().command(() => {
      const k = c().wrapInList(f, r), T = y.filter((M) => d.includes(M.type.name));
      return s.ensureMarks(T), k ? true : l.clearNodes();
    }).wrapInList(f, r).command(() => Ea(s, f)).command(() => Ca(s, f)).run();
  }, T2 = (n, e = {}, t = {}) => ({ state: r, commands: i }) => {
    const { extendEmptyMarkRange: s = false } = t, o = mr(n, r.schema);
    return Wu(r, o, e) ? i.unsetMark(o, {
      extendEmptyMarkRange: s
    }) : i.setMark(o, e);
  }, E2 = (n, e, t = {}) => ({ state: r, commands: i }) => {
    const s = Tt(n, r.schema), o = Tt(e, r.schema), a = Ki(r, s, t);
    let u;
    return r.selection.$anchor.sameParent(r.selection.$head) && (u = r.selection.$anchor.parent.attrs), a ? i.setNode(o, u) : i.setNode(s, {
      ...u,
      ...t
    });
  }, C2 = (n, e = {}) => ({ state: t, commands: r }) => {
    const i = Tt(n, t.schema);
    return Ki(t, i, e) ? r.lift(i) : r.wrapIn(i, e);
  }, O2 = () => ({ state: n, dispatch: e }) => {
    const t = n.plugins;
    for (let r = 0; r < t.length; r += 1) {
      const i = t[r];
      let s;
      if (i.spec.isInputRules && (s = i.getState(n))) {
        if (e) {
          const o = n.tr, a = s.transform;
          for (let u = a.steps.length - 1; u >= 0; u -= 1) o.step(a.steps[u].invert(a.docs[u]));
          if (s.text) {
            const u = o.doc.resolve(s.from).marks();
            o.replaceWith(s.from, s.to, n.schema.text(s.text, u));
          } else o.delete(s.from, s.to);
        }
        return true;
      }
    }
    return false;
  }, A2 = () => ({ tr: n, dispatch: e }) => {
    const { selection: t } = n, { empty: r, ranges: i } = t;
    return r || e && i.forEach((s) => {
      n.removeMark(s.$from.pos, s.$to.pos);
    }), true;
  }, M2 = (n, e = {}) => ({ tr: t, state: r, dispatch: i }) => {
    var s;
    const { extendEmptyMarkRange: o = false } = e, { selection: a } = t, u = mr(n, r.schema), { $from: l, empty: c, ranges: h } = a;
    if (!i) return true;
    if (c && o) {
      let { from: d, to: f } = a;
      const p = (s = l.marks().find((b) => b.type === u)) === null || s === void 0 ? void 0 : s.attrs, m = Ml(l, u, p);
      m && (d = m.from, f = m.to), t.removeMark(d, f, u);
    } else h.forEach((d) => {
      t.removeMark(d.$from.pos, d.$to.pos, u);
    });
    return t.removeStoredMark(u), true;
  }, N2 = (n, e = {}) => ({ tr: t, state: r, dispatch: i }) => {
    let s = null, o = null;
    const a = Uo(typeof n == "string" ? n : n.name, r.schema);
    return a ? (a === "node" && (s = Tt(n, r.schema)), a === "mark" && (o = mr(n, r.schema)), i && t.selection.ranges.forEach((u) => {
      const l = u.$from.pos, c = u.$to.pos;
      let h, d, f, p;
      t.selection.empty ? r.doc.nodesBetween(l, c, (m, b) => {
        s && s === m.type && (f = Math.max(b, l), p = Math.min(b + m.nodeSize, c), h = b, d = m);
      }) : r.doc.nodesBetween(l, c, (m, b) => {
        b < l && s && s === m.type && (f = Math.max(b, l), p = Math.min(b + m.nodeSize, c), h = b, d = m), b >= l && b <= c && (s && s === m.type && t.setNodeMarkup(b, void 0, {
          ...m.attrs,
          ...e
        }), o && m.marks.length && m.marks.forEach((g) => {
          if (o === g.type) {
            const w = Math.max(b, l), v = Math.min(b + m.nodeSize, c);
            t.addMark(w, v, o.create({
              ...g.attrs,
              ...e
            }));
          }
        }));
      }), d && (h !== void 0 && t.setNodeMarkup(h, void 0, {
        ...d.attrs,
        ...e
      }), o && d.marks.length && d.marks.forEach((m) => {
        o === m.type && t.addMark(f, p, o.create({
          ...m.attrs,
          ...e
        }));
      }));
    }), true) : false;
  }, P2 = (n, e = {}) => ({ state: t, dispatch: r }) => {
    const i = Tt(n, t.schema);
    return Gv(i, e)(t, r);
  }, D2 = (n, e = {}) => ({ state: t, dispatch: r }) => {
    const i = Tt(n, t.schema);
    return Kv(i, e)(t, r);
  };
  var I2 = Object.freeze({
    __proto__: null,
    blur: gw,
    clearContent: bw,
    clearNodes: yw,
    command: vw,
    createParagraphNear: ww,
    cut: xw,
    deleteCurrentNode: kw,
    deleteNode: Sw,
    deleteRange: Tw,
    deleteSelection: Ew,
    enter: Cw,
    exitCode: Ow,
    extendMarkRange: Aw,
    first: Mw,
    focus: Pw,
    forEach: Dw,
    insertContent: Iw,
    insertContentAt: Lw,
    joinBackward: zw,
    joinDown: Fw,
    joinForward: jw,
    joinItemBackward: qw,
    joinItemForward: $w,
    joinTextblockBackward: Vw,
    joinTextblockForward: Hw,
    joinUp: Bw,
    keyboardShortcut: Uw,
    lift: Gw,
    liftEmptyBlock: Kw,
    liftListItem: Jw,
    newlineInCode: Yw,
    resetAttributes: Xw,
    scrollIntoView: Qw,
    selectAll: Zw,
    selectNodeBackward: e2,
    selectNodeForward: t2,
    selectParentNode: n2,
    selectTextblockEnd: r2,
    selectTextblockStart: i2,
    setContent: s2,
    setMark: m2,
    setMeta: g2,
    setNode: b2,
    setNodeSelection: y2,
    setTextSelection: v2,
    sinkListItem: w2,
    splitBlock: x2,
    splitListItem: k2,
    toggleList: S2,
    toggleMark: T2,
    toggleNode: E2,
    toggleWrap: C2,
    undoInputRule: O2,
    unsetAllMarks: A2,
    unsetMark: M2,
    updateAttributes: N2,
    wrapIn: P2,
    wrapInList: D2
  });
  const R2 = At.create({
    name: "commands",
    addCommands() {
      return {
        ...I2
      };
    }
  }), _2 = At.create({
    name: "drop",
    addProseMirrorPlugins() {
      return [
        new Dt({
          key: new Vt("tiptapDrop"),
          props: {
            handleDrop: (n, e, t, r) => {
              this.editor.emit("drop", {
                editor: this.editor,
                event: e,
                slice: t,
                moved: r
              });
            }
          }
        })
      ];
    }
  }), L2 = At.create({
    name: "editable",
    addProseMirrorPlugins() {
      return [
        new Dt({
          key: new Vt("editable"),
          props: {
            editable: () => this.editor.options.editable
          }
        })
      ];
    }
  }), B2 = At.create({
    name: "focusEvents",
    addProseMirrorPlugins() {
      const { editor: n } = this;
      return [
        new Dt({
          key: new Vt("focusEvents"),
          props: {
            handleDOMEvents: {
              focus: (e, t) => {
                n.isFocused = true;
                const r = n.state.tr.setMeta("focus", {
                  event: t
                }).setMeta("addToHistory", false);
                return e.dispatch(r), false;
              },
              blur: (e, t) => {
                n.isFocused = false;
                const r = n.state.tr.setMeta("blur", {
                  event: t
                }).setMeta("addToHistory", false);
                return e.dispatch(r), false;
              }
            }
          }
        })
      ];
    }
  }), F2 = At.create({
    name: "keymap",
    addKeyboardShortcuts() {
      const n = () => this.editor.commands.first(({ commands: o }) => [
        () => o.undoInputRule(),
        () => o.command(({ tr: a }) => {
          const { selection: u, doc: l } = a, { empty: c, $anchor: h } = u, { pos: d, parent: f } = h, p = h.parent.isTextblock && d > 0 ? a.doc.resolve(d - 1) : h, m = p.parent.type.spec.isolating, b = h.pos - h.parentOffset, g = m && p.parent.childCount === 1 ? b === h.pos : Ie.atStart(l).from === d;
          return !c || !f.type.isTextblock || f.textContent.length || !g || g && h.parent.type.name === "paragraph" ? false : o.clearNodes();
        }),
        () => o.deleteSelection(),
        () => o.joinBackward(),
        () => o.selectNodeBackward()
      ]), e = () => this.editor.commands.first(({ commands: o }) => [
        () => o.deleteSelection(),
        () => o.deleteCurrentNode(),
        () => o.joinForward(),
        () => o.selectNodeForward()
      ]), r = {
        Enter: () => this.editor.commands.first(({ commands: o }) => [
          () => o.newlineInCode(),
          () => o.createParagraphNear(),
          () => o.liftEmptyBlock(),
          () => o.splitBlock()
        ]),
        "Mod-Enter": () => this.editor.commands.exitCode(),
        Backspace: n,
        "Mod-Backspace": n,
        "Shift-Backspace": n,
        Delete: e,
        "Mod-Delete": e,
        "Mod-a": () => this.editor.commands.selectAll()
      }, i = {
        ...r
      }, s = {
        ...r,
        "Ctrl-h": n,
        "Alt-Backspace": n,
        "Ctrl-d": e,
        "Ctrl-Alt-Backspace": e,
        "Alt-Delete": e,
        "Alt-d": e,
        "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
        "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
      };
      return Nl() || k0() ? s : i;
    },
    addProseMirrorPlugins() {
      return [
        new Dt({
          key: new Vt("clearDocument"),
          appendTransaction: (n, e, t) => {
            if (n.some((m) => m.getMeta("composition"))) return;
            const r = n.some((m) => m.docChanged) && !e.doc.eq(t.doc), i = n.some((m) => m.getMeta("preventClearDocument"));
            if (!r || i) return;
            const { empty: s, from: o, to: a } = e.selection, u = Ie.atStart(e.doc).from, l = Ie.atEnd(e.doc).to;
            if (s || !(o === u && a === l) || !Go(t.doc)) return;
            const d = t.tr, f = jo({
              state: t,
              transaction: d
            }), { commands: p } = new qo({
              editor: this.editor,
              state: f
            });
            if (p.clearNodes(), !!d.steps.length) return d;
          }
        })
      ];
    }
  }), z2 = At.create({
    name: "paste",
    addProseMirrorPlugins() {
      return [
        new Dt({
          key: new Vt("tiptapPaste"),
          props: {
            handlePaste: (n, e, t) => {
              this.editor.emit("paste", {
                editor: this.editor,
                event: e,
                slice: t
              });
            }
          }
        })
      ];
    }
  }), j2 = At.create({
    name: "tabindex",
    addProseMirrorPlugins() {
      return [
        new Dt({
          key: new Vt("tabindex"),
          props: {
            attributes: () => this.editor.isEditable ? {
              tabindex: "0"
            } : {}
          }
        })
      ];
    }
  });
  class Tr {
    get name() {
      return this.node.type.name;
    }
    constructor(e, t, r = false, i = null) {
      this.currentNode = null, this.actualDepth = null, this.isBlock = r, this.resolvedPos = e, this.editor = t, this.currentNode = i;
    }
    get node() {
      return this.currentNode || this.resolvedPos.node();
    }
    get element() {
      return this.editor.view.domAtPos(this.pos).node;
    }
    get depth() {
      var e;
      return (e = this.actualDepth) !== null && e !== void 0 ? e : this.resolvedPos.depth;
    }
    get pos() {
      return this.resolvedPos.pos;
    }
    get content() {
      return this.node.content;
    }
    set content(e) {
      let t = this.from, r = this.to;
      if (this.isBlock) {
        if (this.content.size === 0) {
          console.error(`You can\u2019t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
          return;
        }
        t = this.from + 1, r = this.to - 1;
      }
      this.editor.commands.insertContentAt({
        from: t,
        to: r
      }, e);
    }
    get attributes() {
      return this.node.attrs;
    }
    get textContent() {
      return this.node.textContent;
    }
    get size() {
      return this.node.nodeSize;
    }
    get from() {
      return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
    }
    get range() {
      return {
        from: this.from,
        to: this.to
      };
    }
    get to() {
      return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
    }
    get parent() {
      if (this.depth === 0) return null;
      const e = this.resolvedPos.start(this.resolvedPos.depth - 1), t = this.resolvedPos.doc.resolve(e);
      return new Tr(t, this.editor);
    }
    get before() {
      let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
      return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)), new Tr(e, this.editor);
    }
    get after() {
      let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
      return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)), new Tr(e, this.editor);
    }
    get children() {
      const e = [];
      return this.node.content.forEach((t, r) => {
        const i = t.isBlock && !t.isTextblock, s = t.isAtom && !t.isText, o = this.pos + r + (s ? 0 : 1), a = this.resolvedPos.doc.resolve(o);
        if (!i && a.depth <= this.depth) return;
        const u = new Tr(a, this.editor, i, i ? t : null);
        i && (u.actualDepth = this.depth + 1), e.push(new Tr(a, this.editor, i, i ? t : null));
      }), e;
    }
    get firstChild() {
      return this.children[0] || null;
    }
    get lastChild() {
      const e = this.children;
      return e[e.length - 1] || null;
    }
    closest(e, t = {}) {
      let r = null, i = this.parent;
      for (; i && !r; ) {
        if (i.node.type.name === e) if (Object.keys(t).length > 0) {
          const s = i.node.attrs, o = Object.keys(t);
          for (let a = 0; a < o.length; a += 1) {
            const u = o[a];
            if (s[u] !== t[u]) break;
          }
        } else r = i;
        i = i.parent;
      }
      return r;
    }
    querySelector(e, t = {}) {
      return this.querySelectorAll(e, t, true)[0] || null;
    }
    querySelectorAll(e, t = {}, r = false) {
      let i = [];
      if (!this.children || this.children.length === 0) return i;
      const s = Object.keys(t);
      return this.children.forEach((o) => {
        r && i.length > 0 || (o.node.type.name === e && s.every((u) => t[u] === o.node.attrs[u]) && i.push(o), !(r && i.length > 0) && (i = i.concat(o.querySelectorAll(e, t, r))));
      }), i;
    }
    setAttribute(e) {
      const { tr: t } = this.editor.state;
      t.setNodeMarkup(this.from, void 0, {
        ...this.node.attrs,
        ...e
      }), this.editor.view.dispatch(t);
    }
  }
  const q2 = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
  function $2(n, e, t) {
    const r = document.querySelector("style[data-tiptap-style]");
    if (r !== null) return r;
    const i = document.createElement("style");
    return e && i.setAttribute("nonce", e), i.setAttribute("data-tiptap-style", ""), i.innerHTML = n, document.getElementsByTagName("head")[0].appendChild(i), i;
  }
  class wd extends tw {
    constructor(e = {}) {
      super(), this.isFocused = false, this.isInitialized = false, this.extensionStorage = {}, this.options = {
        element: document.createElement("div"),
        content: "",
        injectCSS: true,
        injectNonce: void 0,
        extensions: [],
        autofocus: false,
        editable: true,
        editorProps: {},
        parseOptions: {},
        coreExtensionOptions: {},
        enableInputRules: true,
        enablePasteRules: true,
        enableCoreExtensions: true,
        enableContentCheck: false,
        onBeforeCreate: () => null,
        onCreate: () => null,
        onUpdate: () => null,
        onSelectionUpdate: () => null,
        onTransaction: () => null,
        onFocus: () => null,
        onBlur: () => null,
        onDestroy: () => null,
        onContentError: ({ error: t }) => {
          throw t;
        },
        onPaste: () => null,
        onDrop: () => null
      }, this.isCapturingTransaction = false, this.capturedTransaction = null, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", {
        editor: this
      }), this.on("contentError", this.options.onContentError), this.createView(), this.injectCSS(), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: t, slice: r, moved: i }) => this.options.onDrop(t, r, i)), this.on("paste", ({ event: t, slice: r }) => this.options.onPaste(t, r)), window.setTimeout(() => {
        this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", {
          editor: this
        }), this.isInitialized = true);
      }, 0);
    }
    get storage() {
      return this.extensionStorage;
    }
    get commands() {
      return this.commandManager.commands;
    }
    chain() {
      return this.commandManager.chain();
    }
    can() {
      return this.commandManager.can();
    }
    injectCSS() {
      this.options.injectCSS && document && (this.css = $2(q2, this.options.injectNonce));
    }
    setOptions(e = {}) {
      this.options = {
        ...this.options,
        ...e
      }, !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
    }
    setEditable(e, t = true) {
      this.setOptions({
        editable: e
      }), t && this.emit("update", {
        editor: this,
        transaction: this.state.tr
      });
    }
    get isEditable() {
      return this.options.editable && this.view && this.view.editable;
    }
    get state() {
      return this.view.state;
    }
    registerPlugin(e, t) {
      const r = p0(t) ? t(e, [
        ...this.state.plugins
      ]) : [
        ...this.state.plugins,
        e
      ], i = this.state.reconfigure({
        plugins: r
      });
      return this.view.updateState(i), i;
    }
    unregisterPlugin(e) {
      if (this.isDestroyed) return;
      const t = this.state.plugins;
      let r = t;
      if ([].concat(e).forEach((s) => {
        const o = typeof s == "string" ? `${s}$` : s.key;
        r = t.filter((a) => !a.key.startsWith(o));
      }), t.length === r.length) return;
      const i = this.state.reconfigure({
        plugins: r
      });
      return this.view.updateState(i), i;
    }
    createExtensionManager() {
      var e, t;
      const i = [
        ...this.options.enableCoreExtensions ? [
          L2,
          mw.configure({
            blockSeparator: (t = (e = this.options.coreExtensionOptions) === null || e === void 0 ? void 0 : e.clipboardTextSerializer) === null || t === void 0 ? void 0 : t.blockSeparator
          }),
          R2,
          B2,
          F2,
          j2,
          _2,
          z2
        ].filter((s) => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[s.name] !== false : true) : [],
        ...this.options.extensions
      ].filter((s) => [
        "extension",
        "node",
        "mark"
      ].includes(s?.type));
      this.extensionManager = new Or(i, this);
    }
    createCommandManager() {
      this.commandManager = new qo({
        editor: this
      });
    }
    createSchema() {
      this.schema = this.extensionManager.schema;
    }
    createView() {
      var e;
      let t;
      try {
        t = Hu(this.options.content, this.schema, this.options.parseOptions, {
          errorOnInvalidContent: this.options.enableContentCheck
        });
      } catch (o) {
        if (!(o instanceof Error) || ![
          "[tiptap error]: Invalid JSON content",
          "[tiptap error]: Invalid HTML content"
        ].includes(o.message)) throw o;
        this.emit("contentError", {
          editor: this,
          error: o,
          disableCollaboration: () => {
            this.storage.collaboration && (this.storage.collaboration.isDisabled = true), this.options.extensions = this.options.extensions.filter((a) => a.name !== "collaboration"), this.createExtensionManager();
          }
        }), t = Hu(this.options.content, this.schema, this.options.parseOptions, {
          errorOnInvalidContent: false
        });
      }
      const r = w0(t, this.options.autofocus);
      this.view = new Dv(this.options.element, {
        ...this.options.editorProps,
        attributes: {
          role: "textbox",
          ...(e = this.options.editorProps) === null || e === void 0 ? void 0 : e.attributes
        },
        dispatchTransaction: this.dispatchTransaction.bind(this),
        state: ei.create({
          doc: t,
          selection: r || void 0
        })
      });
      const i = this.state.reconfigure({
        plugins: this.extensionManager.plugins
      });
      this.view.updateState(i), this.createNodeViews(), this.prependClass();
      const s = this.view.dom;
      s.editor = this;
    }
    createNodeViews() {
      this.view.isDestroyed || this.view.setProps({
        nodeViews: this.extensionManager.nodeViews
      });
    }
    prependClass() {
      this.view.dom.className = `tiptap ${this.view.dom.className}`;
    }
    captureTransaction(e) {
      this.isCapturingTransaction = true, e(), this.isCapturingTransaction = false;
      const t = this.capturedTransaction;
      return this.capturedTransaction = null, t;
    }
    dispatchTransaction(e) {
      if (this.view.isDestroyed) return;
      if (this.isCapturingTransaction) {
        if (!this.capturedTransaction) {
          this.capturedTransaction = e;
          return;
        }
        e.steps.forEach((o) => {
          var a;
          return (a = this.capturedTransaction) === null || a === void 0 ? void 0 : a.step(o);
        });
        return;
      }
      const t = this.state.apply(e), r = !this.state.selection.eq(t.selection);
      this.emit("beforeTransaction", {
        editor: this,
        transaction: e,
        nextState: t
      }), this.view.updateState(t), this.emit("transaction", {
        editor: this,
        transaction: e
      }), r && this.emit("selectionUpdate", {
        editor: this,
        transaction: e
      });
      const i = e.getMeta("focus"), s = e.getMeta("blur");
      i && this.emit("focus", {
        editor: this,
        event: i.event,
        transaction: e
      }), s && this.emit("blur", {
        editor: this,
        event: s.event,
        transaction: e
      }), !(!e.docChanged || e.getMeta("preventUpdate")) && this.emit("update", {
        editor: this,
        transaction: e
      });
    }
    getAttributes(e) {
      return d2(this.state, e);
    }
    isActive(e, t) {
      const r = typeof e == "string" ? e : null, i = typeof e == "string" ? t : e;
      return f2(this.state, r, i);
    }
    getJSON() {
      return this.state.doc.toJSON();
    }
    getHTML() {
      return Vo(this.state.doc.content, this.schema);
    }
    getText(e) {
      const { blockSeparator: t = `

`, textSerializers: r = {} } = e || {};
      return l2(this.state.doc, {
        blockSeparator: t,
        textSerializers: {
          ...b0(this.schema),
          ...r
        }
      });
    }
    get isEmpty() {
      return Go(this.state.doc);
    }
    getCharacterCount() {
      return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'), this.state.doc.content.size - 2;
    }
    destroy() {
      if (this.emit("destroy"), this.view) {
        const e = this.view.dom;
        e && e.editor && delete e.editor, this.view.destroy();
      }
      this.removeAllListeners();
    }
    get isDestroyed() {
      var e;
      return !(!((e = this.view) === null || e === void 0) && e.docView);
    }
    $node(e, t) {
      var r;
      return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelector(e, t)) || null;
    }
    $nodes(e, t) {
      var r;
      return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelectorAll(e, t)) || null;
    }
    $pos(e) {
      const t = this.state.doc.resolve(e);
      return new Tr(t, this);
    }
    get $doc() {
      return this.$pos(0);
    }
  }
  function fi(n) {
    return new Ho({
      find: n.find,
      handler: ({ state: e, range: t, match: r }) => {
        const i = Fe(n.getAttributes, void 0, r);
        if (i === false || i === null) return null;
        const { tr: s } = e, o = r[r.length - 1], a = r[0];
        if (o) {
          const u = a.search(/\S/), l = t.from + a.indexOf(o), c = l + o.length;
          if (E0(t.from, t.to, e.doc).filter((f) => f.mark.type.excluded.find((m) => m === n.type && m !== f.mark.type)).filter((f) => f.to > l).length) return null;
          c < t.to && s.delete(c, t.to), l > t.from && s.delete(t.from + u, l);
          const d = t.from + u + o.length;
          s.addMark(t.from + u, d, n.type.create(i || {})), s.removeStoredMark(n.type);
        }
      }
    });
  }
  function V2(n) {
    return new Ho({
      find: n.find,
      handler: ({ state: e, range: t, match: r }) => {
        const i = Fe(n.getAttributes, void 0, r) || {}, { tr: s } = e, o = t.from;
        let a = t.to;
        const u = n.type.create(i);
        if (r[1]) {
          const l = r[0].lastIndexOf(r[1]);
          let c = o + l;
          c > a ? c = a : a = c + r[1].length;
          const h = r[0][r[0].length - 1];
          s.insertText(h, o + r[0].length - 1), s.replaceWith(c, a, u);
        } else if (r[0]) {
          const l = n.type.isInline ? o : o - 1;
          s.insert(l, n.type.create(i)).delete(s.mapping.map(o), s.mapping.map(a));
        }
        s.scrollIntoView();
      }
    });
  }
  function Uu(n) {
    return new Ho({
      find: n.find,
      handler: ({ state: e, range: t, match: r }) => {
        const i = e.doc.resolve(t.from), s = Fe(n.getAttributes, void 0, r) || {};
        if (!i.node(-1).canReplaceWith(i.index(-1), i.indexAfter(-1), n.type)) return null;
        e.tr.delete(t.from, t.to).setBlockType(t.from, t.from, n.type, s);
      }
    });
  }
  function Ji(n) {
    return new Ho({
      find: n.find,
      handler: ({ state: e, range: t, match: r, chain: i }) => {
        const s = Fe(n.getAttributes, void 0, r) || {}, o = e.tr.delete(t.from, t.to), u = o.doc.resolve(t.from).blockRange(), l = u && fl(u, n.type, s);
        if (!l) return null;
        if (o.wrap(u, l), n.keepMarks && n.editor) {
          const { selection: h, storedMarks: d } = e, { splittableMarks: f } = n.editor.extensionManager, p = d || h.$to.parentOffset && h.$from.marks();
          if (p) {
            const m = p.filter((b) => f.includes(b.type.name));
            o.ensureMarks(m);
          }
        }
        if (n.keepAttributes) {
          const h = n.type.name === "bulletList" || n.type.name === "orderedList" ? "listItem" : "taskList";
          i().updateAttributes(h, s).run();
        }
        const c = o.doc.resolve(t.from - 1).nodeBefore;
        c && c.type === n.type && hr(o.doc, t.from - 1) && (!n.joinPredicate || n.joinPredicate(r, c)) && o.join(t.from - 1);
      }
    });
  }
  class Bt {
    constructor(e = {}) {
      this.type = "node", this.name = "node", this.parent = null, this.child = null, this.config = {
        name: this.name,
        defaultOptions: {}
      }, this.config = {
        ...this.config,
        ...e
      }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Fe(oe(this, "addOptions", {
        name: this.name
      }))), this.storage = Fe(oe(this, "addStorage", {
        name: this.name,
        options: this.options
      })) || {};
    }
    static create(e = {}) {
      return new Bt(e);
    }
    configure(e = {}) {
      const t = this.extend({
        ...this.config,
        addOptions: () => Wo(this.options, e)
      });
      return t.name = this.name, t.parent = this.parent, t;
    }
    extend(e = {}) {
      const t = new Bt(e);
      return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = Fe(oe(t, "addOptions", {
        name: t.name
      })), t.storage = Fe(oe(t, "addStorage", {
        name: t.name,
        options: t.options
      })), t;
    }
  }
  function hi(n) {
    return new lw({
      find: n.find,
      handler: ({ state: e, range: t, match: r, pasteEvent: i }) => {
        const s = Fe(n.getAttributes, void 0, r, i);
        if (s === false || s === null) return null;
        const { tr: o } = e, a = r[r.length - 1], u = r[0];
        let l = t.to;
        if (a) {
          const c = u.search(/\S/), h = t.from + u.indexOf(a), d = h + a.length;
          if (E0(t.from, t.to, e.doc).filter((p) => p.mark.type.excluded.find((b) => b === n.type && b !== p.mark.type)).filter((p) => p.to > h).length) return null;
          d < t.to && o.delete(d, t.to), h > t.from && o.delete(t.from + c, h), l = t.from + c + a.length, o.addMark(t.from + c, l, n.type.create(s || {})), o.removeStoredMark(n.type);
        }
      }
    });
  }
  function H2(n) {
    return n.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  const W2 = /^\s*>\s$/, U2 = Bt.create({
    name: "blockquote",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    content: "block+",
    group: "block",
    defining: true,
    parseHTML() {
      return [
        {
          tag: "blockquote"
        }
      ];
    },
    renderHTML({ HTMLAttributes: n }) {
      return [
        "blockquote",
        ot(this.options.HTMLAttributes, n),
        0
      ];
    },
    addCommands() {
      return {
        setBlockquote: () => ({ commands: n }) => n.wrapIn(this.name),
        toggleBlockquote: () => ({ commands: n }) => n.toggleWrap(this.name),
        unsetBlockquote: () => ({ commands: n }) => n.lift(this.name)
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
      };
    },
    addInputRules() {
      return [
        Ji({
          find: W2,
          type: this.type
        })
      ];
    }
  }), G2 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, K2 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, J2 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, Y2 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, X2 = cr.create({
    name: "bold",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML() {
      return [
        {
          tag: "strong"
        },
        {
          tag: "b",
          getAttrs: (n) => n.style.fontWeight !== "normal" && null
        },
        {
          style: "font-weight=400",
          clearMark: (n) => n.type.name === this.name
        },
        {
          style: "font-weight",
          getAttrs: (n) => /^(bold(er)?|[5-9]\d{2,})$/.test(n) && null
        }
      ];
    },
    renderHTML({ HTMLAttributes: n }) {
      return [
        "strong",
        ot(this.options.HTMLAttributes, n),
        0
      ];
    },
    addCommands() {
      return {
        setBold: () => ({ commands: n }) => n.setMark(this.name),
        toggleBold: () => ({ commands: n }) => n.toggleMark(this.name),
        unsetBold: () => ({ commands: n }) => n.unsetMark(this.name)
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-b": () => this.editor.commands.toggleBold(),
        "Mod-B": () => this.editor.commands.toggleBold()
      };
    },
    addInputRules() {
      return [
        fi({
          find: G2,
          type: this.type
        }),
        fi({
          find: J2,
          type: this.type
        })
      ];
    },
    addPasteRules() {
      return [
        hi({
          find: K2,
          type: this.type
        }),
        hi({
          find: Y2,
          type: this.type
        })
      ];
    }
  }), Q2 = "listItem", xd = "textStyle", kd = /^\s*([-+*])\s$/, Z2 = Bt.create({
    name: "bulletList",
    addOptions() {
      return {
        itemTypeName: "listItem",
        HTMLAttributes: {},
        keepMarks: false,
        keepAttributes: false
      };
    },
    group: "block list",
    content() {
      return `${this.options.itemTypeName}+`;
    },
    parseHTML() {
      return [
        {
          tag: "ul"
        }
      ];
    },
    renderHTML({ HTMLAttributes: n }) {
      return [
        "ul",
        ot(this.options.HTMLAttributes, n),
        0
      ];
    },
    addCommands() {
      return {
        toggleBulletList: () => ({ commands: n, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(Q2, this.editor.getAttributes(xd)).run() : n.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
      };
    },
    addInputRules() {
      let n = Ji({
        find: kd,
        type: this.type
      });
      return (this.options.keepMarks || this.options.keepAttributes) && (n = Ji({
        find: kd,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: () => this.editor.getAttributes(xd),
        editor: this.editor
      })), [
        n
      ];
    }
  }), ex = /(^|[^`])`([^`]+)`(?!`)/, tx = /(^|[^`])`([^`]+)`(?!`)/g, nx = cr.create({
    name: "code",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    excludes: "_",
    code: true,
    exitable: true,
    parseHTML() {
      return [
        {
          tag: "code"
        }
      ];
    },
    renderHTML({ HTMLAttributes: n }) {
      return [
        "code",
        ot(this.options.HTMLAttributes, n),
        0
      ];
    },
    addCommands() {
      return {
        setCode: () => ({ commands: n }) => n.setMark(this.name),
        toggleCode: () => ({ commands: n }) => n.toggleMark(this.name),
        unsetCode: () => ({ commands: n }) => n.unsetMark(this.name)
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-e": () => this.editor.commands.toggleCode()
      };
    },
    addInputRules() {
      return [
        fi({
          find: ex,
          type: this.type
        })
      ];
    },
    addPasteRules() {
      return [
        hi({
          find: tx,
          type: this.type
        })
      ];
    }
  }), rx = /^```([a-z]+)?[\s\n]$/, ix = /^~~~([a-z]+)?[\s\n]$/, sx = Bt.create({
    name: "codeBlock",
    addOptions() {
      return {
        languageClassPrefix: "language-",
        exitOnTripleEnter: true,
        exitOnArrowDown: true,
        defaultLanguage: null,
        HTMLAttributes: {}
      };
    },
    content: "text*",
    marks: "",
    group: "block",
    code: true,
    defining: true,
    addAttributes() {
      return {
        language: {
          default: this.options.defaultLanguage,
          parseHTML: (n) => {
            var e;
            const { languageClassPrefix: t } = this.options, s = [
              ...((e = n.firstElementChild) === null || e === void 0 ? void 0 : e.classList) || []
            ].filter((o) => o.startsWith(t)).map((o) => o.replace(t, ""))[0];
            return s || null;
          },
          rendered: false
        }
      };
    },
    parseHTML() {
      return [
        {
          tag: "pre",
          preserveWhitespace: "full"
        }
      ];
    },
    renderHTML({ node: n, HTMLAttributes: e }) {
      return [
        "pre",
        ot(this.options.HTMLAttributes, e),
        [
          "code",
          {
            class: n.attrs.language ? this.options.languageClassPrefix + n.attrs.language : null
          },
          0
        ]
      ];
    },
    addCommands() {
      return {
        setCodeBlock: (n) => ({ commands: e }) => e.setNode(this.name, n),
        toggleCodeBlock: (n) => ({ commands: e }) => e.toggleNode(this.name, "paragraph", n)
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
        Backspace: () => {
          const { empty: n, $anchor: e } = this.editor.state.selection, t = e.pos === 1;
          return !n || e.parent.type.name !== this.name ? false : t || !e.parent.textContent.length ? this.editor.commands.clearNodes() : false;
        },
        Enter: ({ editor: n }) => {
          if (!this.options.exitOnTripleEnter) return false;
          const { state: e } = n, { selection: t } = e, { $from: r, empty: i } = t;
          if (!i || r.parent.type !== this.type) return false;
          const s = r.parentOffset === r.parent.nodeSize - 2, o = r.parent.textContent.endsWith(`

`);
          return !s || !o ? false : n.chain().command(({ tr: a }) => (a.delete(r.pos - 2, r.pos), true)).exitCode().run();
        },
        ArrowDown: ({ editor: n }) => {
          if (!this.options.exitOnArrowDown) return false;
          const { state: e } = n, { selection: t, doc: r } = e, { $from: i, empty: s } = t;
          if (!s || i.parent.type !== this.type || !(i.parentOffset === i.parent.nodeSize - 2)) return false;
          const a = i.after();
          return a === void 0 ? false : r.nodeAt(a) ? n.commands.command(({ tr: l }) => (l.setSelection(Ie.near(r.resolve(a))), true)) : n.commands.exitCode();
        }
      };
    },
    addInputRules() {
      return [
        Uu({
          find: rx,
          type: this.type,
          getAttributes: (n) => ({
            language: n[1]
          })
        }),
        Uu({
          find: ix,
          type: this.type,
          getAttributes: (n) => ({
            language: n[1]
          })
        })
      ];
    },
    addProseMirrorPlugins() {
      return [
        new Dt({
          key: new Vt("codeBlockVSCodeHandler"),
          props: {
            handlePaste: (n, e) => {
              if (!e.clipboardData || this.editor.isActive(this.type.name)) return false;
              const t = e.clipboardData.getData("text/plain"), r = e.clipboardData.getData("vscode-editor-data"), i = r ? JSON.parse(r) : void 0, s = i?.mode;
              if (!t || !s) return false;
              const { tr: o, schema: a } = n.state, u = a.text(t.replace(/\r\n?/g, `
`));
              return o.replaceSelectionWith(this.type.create({
                language: s
              }, u)), o.selection.$from.parent.type !== this.type && o.setSelection(Te.near(o.doc.resolve(Math.max(0, o.selection.from - 2)))), o.setMeta("paste", true), n.dispatch(o), true;
            }
          }
        })
      ];
    }
  }), ox = Bt.create({
    name: "doc",
    topNode: true,
    content: "block+"
  });
  function ax(n = {}) {
    return new Dt({
      view(e) {
        return new ux(e, n);
      }
    });
  }
  class ux {
    constructor(e, t) {
      var r;
      this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (r = t.width) !== null && r !== void 0 ? r : 1, this.color = t.color === false ? void 0 : t.color || "black", this.class = t.class, this.handlers = [
        "dragover",
        "dragend",
        "drop",
        "dragleave"
      ].map((i) => {
        let s = (o) => {
          this[i](o);
        };
        return e.dom.addEventListener(i, s), {
          name: i,
          handler: s
        };
      });
    }
    destroy() {
      this.handlers.forEach(({ name: e, handler: t }) => this.editorView.dom.removeEventListener(e, t));
    }
    update(e, t) {
      this.cursorPos != null && t.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
    }
    setCursor(e) {
      e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
    }
    updateOverlay() {
      let e = this.editorView.state.doc.resolve(this.cursorPos), t = !e.parent.inlineContent, r;
      if (t) {
        let a = e.nodeBefore, u = e.nodeAfter;
        if (a || u) {
          let l = this.editorView.nodeDOM(this.cursorPos - (a ? a.nodeSize : 0));
          if (l) {
            let c = l.getBoundingClientRect(), h = a ? c.bottom : c.top;
            a && u && (h = (h + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2), r = {
              left: c.left,
              right: c.right,
              top: h - this.width / 2,
              bottom: h + this.width / 2
            };
          }
        }
      }
      if (!r) {
        let a = this.editorView.coordsAtPos(this.cursorPos);
        r = {
          left: a.left - this.width / 2,
          right: a.left + this.width / 2,
          top: a.top,
          bottom: a.bottom
        };
      }
      let i = this.editorView.dom.offsetParent;
      this.element || (this.element = i.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", t), this.element.classList.toggle("prosemirror-dropcursor-inline", !t);
      let s, o;
      if (!i || i == document.body && getComputedStyle(i).position == "static") s = -pageXOffset, o = -pageYOffset;
      else {
        let a = i.getBoundingClientRect();
        s = a.left - i.scrollLeft, o = a.top - i.scrollTop;
      }
      this.element.style.left = r.left - s + "px", this.element.style.top = r.top - o + "px", this.element.style.width = r.right - r.left + "px", this.element.style.height = r.bottom - r.top + "px";
    }
    scheduleRemoval(e) {
      clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
    }
    dragover(e) {
      if (!this.editorView.editable) return;
      let t = this.editorView.posAtCoords({
        left: e.clientX,
        top: e.clientY
      }), r = t && t.inside >= 0 && this.editorView.state.doc.nodeAt(t.inside), i = r && r.type.spec.disableDropCursor, s = typeof i == "function" ? i(this.editorView, t, e) : i;
      if (t && !s) {
        let o = t.pos;
        if (this.editorView.dragging && this.editorView.dragging.slice) {
          let a = hp(this.editorView.state.doc, o, this.editorView.dragging.slice);
          a != null && (o = a);
        }
        this.setCursor(o), this.scheduleRemoval(5e3);
      }
    }
    dragend() {
      this.scheduleRemoval(20);
    }
    drop() {
      this.scheduleRemoval(20);
    }
    dragleave(e) {
      (e.target == this.editorView.dom || !this.editorView.dom.contains(e.relatedTarget)) && this.setCursor(null);
    }
  }
  const lx = At.create({
    name: "dropCursor",
    addOptions() {
      return {
        color: "currentColor",
        width: 1,
        class: void 0
      };
    },
    addProseMirrorPlugins() {
      return [
        ax(this.options)
      ];
    }
  });
  class st extends Ie {
    constructor(e) {
      super(e, e);
    }
    map(e, t) {
      let r = e.resolve(t.map(this.head));
      return st.valid(r) ? new st(r) : Ie.near(r);
    }
    content() {
      return re.empty;
    }
    eq(e) {
      return e instanceof st && e.head == this.head;
    }
    toJSON() {
      return {
        type: "gapcursor",
        pos: this.head
      };
    }
    static fromJSON(e, t) {
      if (typeof t.pos != "number") throw new RangeError("Invalid input for GapCursor.fromJSON");
      return new st(e.resolve(t.pos));
    }
    getBookmark() {
      return new Dl(this.anchor);
    }
    static valid(e) {
      let t = e.parent;
      if (t.isTextblock || !cx(e) || !dx(e)) return false;
      let r = t.type.spec.allowGapCursor;
      if (r != null) return r;
      let i = t.contentMatchAt(e.index()).defaultType;
      return i && i.isTextblock;
    }
    static findGapCursorFrom(e, t, r = false) {
      e: for (; ; ) {
        if (!r && st.valid(e)) return e;
        let i = e.pos, s = null;
        for (let o = e.depth; ; o--) {
          let a = e.node(o);
          if (t > 0 ? e.indexAfter(o) < a.childCount : e.index(o) > 0) {
            s = a.child(t > 0 ? e.indexAfter(o) : e.index(o) - 1);
            break;
          } else if (o == 0) return null;
          i += t;
          let u = e.doc.resolve(i);
          if (st.valid(u)) return u;
        }
        for (; ; ) {
          let o = t > 0 ? s.firstChild : s.lastChild;
          if (!o) {
            if (s.isAtom && !s.isText && !ye.isSelectable(s)) {
              e = e.doc.resolve(i + s.nodeSize * t), r = false;
              continue e;
            }
            break;
          }
          s = o, i += t;
          let a = e.doc.resolve(i);
          if (st.valid(a)) return a;
        }
        return null;
      }
    }
  }
  st.prototype.visible = false;
  st.findFrom = st.findGapCursorFrom;
  Ie.jsonID("gapcursor", st);
  class Dl {
    constructor(e) {
      this.pos = e;
    }
    map(e) {
      return new Dl(e.map(this.pos));
    }
    resolve(e) {
      let t = e.resolve(this.pos);
      return st.valid(t) ? new st(t) : Ie.near(t);
    }
  }
  function cx(n) {
    for (let e = n.depth; e >= 0; e--) {
      let t = n.index(e), r = n.node(e);
      if (t == 0) {
        if (r.type.spec.isolating) return true;
        continue;
      }
      for (let i = r.child(t - 1); ; i = i.lastChild) {
        if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating) return true;
        if (i.inlineContent) return false;
      }
    }
    return true;
  }
  function dx(n) {
    for (let e = n.depth; e >= 0; e--) {
      let t = n.indexAfter(e), r = n.node(e);
      if (t == r.childCount) {
        if (r.type.spec.isolating) return true;
        continue;
      }
      for (let i = r.child(t); ; i = i.firstChild) {
        if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating) return true;
        if (i.inlineContent) return false;
      }
    }
    return true;
  }
  function fx() {
    return new Dt({
      props: {
        decorations: gx,
        createSelectionBetween(n, e, t) {
          return e.pos == t.pos && st.valid(t) ? new st(t) : null;
        },
        handleClick: px,
        handleKeyDown: hx,
        handleDOMEvents: {
          beforeinput: mx
        }
      }
    });
  }
  const hx = xp({
    ArrowLeft: ys("horiz", -1),
    ArrowRight: ys("horiz", 1),
    ArrowUp: ys("vert", -1),
    ArrowDown: ys("vert", 1)
  });
  function ys(n, e) {
    const t = n == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
    return function(r, i, s) {
      let o = r.selection, a = e > 0 ? o.$to : o.$from, u = o.empty;
      if (o instanceof Te) {
        if (!s.endOfTextblock(t) || a.depth == 0) return false;
        u = false, a = r.doc.resolve(e > 0 ? a.after() : a.before());
      }
      let l = st.findGapCursorFrom(a, e, u);
      return l ? (i && i(r.tr.setSelection(new st(l))), true) : false;
    };
  }
  function px(n, e, t) {
    if (!n || !n.editable) return false;
    let r = n.state.doc.resolve(e);
    if (!st.valid(r)) return false;
    let i = n.posAtCoords({
      left: t.clientX,
      top: t.clientY
    });
    return i && i.inside > -1 && ye.isSelectable(n.state.doc.nodeAt(i.inside)) ? false : (n.dispatch(n.state.tr.setSelection(new st(r))), true);
  }
  function mx(n, e) {
    if (e.inputType != "insertCompositionText" || !(n.state.selection instanceof st)) return false;
    let { $from: t } = n.state.selection, r = t.parent.contentMatchAt(t.index()).findWrapping(n.state.schema.nodes.text);
    if (!r) return false;
    let i = G.empty;
    for (let o = r.length - 1; o >= 0; o--) i = G.from(r[o].createAndFill(null, i));
    let s = n.state.tr.replace(t.pos, t.pos, new re(i, 0, 0));
    return s.setSelection(Te.near(s.doc.resolve(t.pos + 1))), n.dispatch(s), false;
  }
  function gx(n) {
    if (!(n.selection instanceof st)) return null;
    let e = document.createElement("div");
    return e.className = "ProseMirror-gapcursor", ut.create(n.doc, [
      jt.widget(n.selection.head, e, {
        key: "gapcursor"
      })
    ]);
  }
  const bx = At.create({
    name: "gapCursor",
    addProseMirrorPlugins() {
      return [
        fx()
      ];
    },
    extendNodeSchema(n) {
      var e;
      const t = {
        name: n.name,
        options: n.options,
        storage: n.storage
      };
      return {
        allowGapCursor: (e = Fe(oe(n, "allowGapCursor", t))) !== null && e !== void 0 ? e : null
      };
    }
  }), yx = Bt.create({
    name: "hardBreak",
    addOptions() {
      return {
        keepMarks: true,
        HTMLAttributes: {}
      };
    },
    inline: true,
    group: "inline",
    selectable: false,
    linebreakReplacement: true,
    parseHTML() {
      return [
        {
          tag: "br"
        }
      ];
    },
    renderHTML({ HTMLAttributes: n }) {
      return [
        "br",
        ot(this.options.HTMLAttributes, n)
      ];
    },
    renderText() {
      return `
`;
    },
    addCommands() {
      return {
        setHardBreak: () => ({ commands: n, chain: e, state: t, editor: r }) => n.first([
          () => n.exitCode(),
          () => n.command(() => {
            const { selection: i, storedMarks: s } = t;
            if (i.$from.parent.type.spec.isolating) return false;
            const { keepMarks: o } = this.options, { splittableMarks: a } = r.extensionManager, u = s || i.$to.parentOffset && i.$from.marks();
            return e().insertContent({
              type: this.name
            }).command(({ tr: l, dispatch: c }) => {
              if (c && u && o) {
                const h = u.filter((d) => a.includes(d.type.name));
                l.ensureMarks(h);
              }
              return true;
            }).run();
          })
        ])
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Enter": () => this.editor.commands.setHardBreak(),
        "Shift-Enter": () => this.editor.commands.setHardBreak()
      };
    }
  }), vx = Bt.create({
    name: "heading",
    addOptions() {
      return {
        levels: [
          1,
          2,
          3,
          4,
          5,
          6
        ],
        HTMLAttributes: {}
      };
    },
    content: "inline*",
    group: "block",
    defining: true,
    addAttributes() {
      return {
        level: {
          default: 1,
          rendered: false
        }
      };
    },
    parseHTML() {
      return this.options.levels.map((n) => ({
        tag: `h${n}`,
        attrs: {
          level: n
        }
      }));
    },
    renderHTML({ node: n, HTMLAttributes: e }) {
      return [
        `h${this.options.levels.includes(n.attrs.level) ? n.attrs.level : this.options.levels[0]}`,
        ot(this.options.HTMLAttributes, e),
        0
      ];
    },
    addCommands() {
      return {
        setHeading: (n) => ({ commands: e }) => this.options.levels.includes(n.level) ? e.setNode(this.name, n) : false,
        toggleHeading: (n) => ({ commands: e }) => this.options.levels.includes(n.level) ? e.toggleNode(this.name, "paragraph", n) : false
      };
    },
    addKeyboardShortcuts() {
      return this.options.levels.reduce((n, e) => ({
        ...n,
        [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({
          level: e
        })
      }), {});
    },
    addInputRules() {
      return this.options.levels.map((n) => Uu({
        find: new RegExp(`^(#{${Math.min(...this.options.levels)},${n}})\\s$`),
        type: this.type,
        getAttributes: {
          level: n
        }
      }));
    }
  });
  var co = 200, St = function() {
  };
  St.prototype.append = function(e) {
    return e.length ? (e = St.from(e), !this.length && e || e.length < co && this.leafAppend(e) || this.length < co && e.leafPrepend(this) || this.appendInner(e)) : this;
  };
  St.prototype.prepend = function(e) {
    return e.length ? St.from(e).append(this) : this;
  };
  St.prototype.appendInner = function(e) {
    return new wx(this, e);
  };
  St.prototype.slice = function(e, t) {
    return e === void 0 && (e = 0), t === void 0 && (t = this.length), e >= t ? St.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, t));
  };
  St.prototype.get = function(e) {
    if (!(e < 0 || e >= this.length)) return this.getInner(e);
  };
  St.prototype.forEach = function(e, t, r) {
    t === void 0 && (t = 0), r === void 0 && (r = this.length), t <= r ? this.forEachInner(e, t, r, 0) : this.forEachInvertedInner(e, t, r, 0);
  };
  St.prototype.map = function(e, t, r) {
    t === void 0 && (t = 0), r === void 0 && (r = this.length);
    var i = [];
    return this.forEach(function(s, o) {
      return i.push(e(s, o));
    }, t, r), i;
  };
  St.from = function(e) {
    return e instanceof St ? e : e && e.length ? new C0(e) : St.empty;
  };
  var C0 = function(n) {
    function e(r) {
      n.call(this), this.values = r;
    }
    n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e;
    var t = {
      length: {
        configurable: true
      },
      depth: {
        configurable: true
      }
    };
    return e.prototype.flatten = function() {
      return this.values;
    }, e.prototype.sliceInner = function(i, s) {
      return i == 0 && s == this.length ? this : new e(this.values.slice(i, s));
    }, e.prototype.getInner = function(i) {
      return this.values[i];
    }, e.prototype.forEachInner = function(i, s, o, a) {
      for (var u = s; u < o; u++) if (i(this.values[u], a + u) === false) return false;
    }, e.prototype.forEachInvertedInner = function(i, s, o, a) {
      for (var u = s - 1; u >= o; u--) if (i(this.values[u], a + u) === false) return false;
    }, e.prototype.leafAppend = function(i) {
      if (this.length + i.length <= co) return new e(this.values.concat(i.flatten()));
    }, e.prototype.leafPrepend = function(i) {
      if (this.length + i.length <= co) return new e(i.flatten().concat(this.values));
    }, t.length.get = function() {
      return this.values.length;
    }, t.depth.get = function() {
      return 0;
    }, Object.defineProperties(e.prototype, t), e;
  }(St);
  St.empty = new C0([]);
  var wx = function(n) {
    function e(t, r) {
      n.call(this), this.left = t, this.right = r, this.length = t.length + r.length, this.depth = Math.max(t.depth, r.depth) + 1;
    }
    return n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
      return this.left.flatten().concat(this.right.flatten());
    }, e.prototype.getInner = function(r) {
      return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
    }, e.prototype.forEachInner = function(r, i, s, o) {
      var a = this.left.length;
      if (i < a && this.left.forEachInner(r, i, Math.min(s, a), o) === false || s > a && this.right.forEachInner(r, Math.max(i - a, 0), Math.min(this.length, s) - a, o + a) === false) return false;
    }, e.prototype.forEachInvertedInner = function(r, i, s, o) {
      var a = this.left.length;
      if (i > a && this.right.forEachInvertedInner(r, i - a, Math.max(s, a) - a, o + a) === false || s < a && this.left.forEachInvertedInner(r, Math.min(i, a), s, o) === false) return false;
    }, e.prototype.sliceInner = function(r, i) {
      if (r == 0 && i == this.length) return this;
      var s = this.left.length;
      return i <= s ? this.left.slice(r, i) : r >= s ? this.right.slice(r - s, i - s) : this.left.slice(r, s).append(this.right.slice(0, i - s));
    }, e.prototype.leafAppend = function(r) {
      var i = this.right.leafAppend(r);
      if (i) return new e(this.left, i);
    }, e.prototype.leafPrepend = function(r) {
      var i = this.left.leafPrepend(r);
      if (i) return new e(i, this.right);
    }, e.prototype.appendInner = function(r) {
      return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left, new e(this.right, r)) : new e(this, r);
    }, e;
  }(St);
  const xx = 500;
  class un {
    constructor(e, t) {
      this.items = e, this.eventCount = t;
    }
    popEvent(e, t) {
      if (this.eventCount == 0) return null;
      let r = this.items.length;
      for (; ; r--) if (this.items.get(r - 1).selection) {
        --r;
        break;
      }
      let i, s;
      t && (i = this.remapping(r, this.items.length), s = i.maps.length);
      let o = e.tr, a, u, l = [], c = [];
      return this.items.forEach((h, d) => {
        if (!h.step) {
          i || (i = this.remapping(r, d + 1), s = i.maps.length), s--, c.push(h);
          return;
        }
        if (i) {
          c.push(new wn(h.map));
          let f = h.step.map(i.slice(s)), p;
          f && o.maybeStep(f).doc && (p = o.mapping.maps[o.mapping.maps.length - 1], l.push(new wn(p, void 0, void 0, l.length + c.length))), s--, p && i.appendMap(p, s);
        } else o.maybeStep(h.step);
        if (h.selection) return a = i ? h.selection.map(i.slice(s)) : h.selection, u = new un(this.items.slice(0, r).append(c.reverse().concat(l)), this.eventCount - 1), false;
      }, this.items.length, 0), {
        remaining: u,
        transform: o,
        selection: a
      };
    }
    addTransform(e, t, r, i) {
      let s = [], o = this.eventCount, a = this.items, u = !i && a.length ? a.get(a.length - 1) : null;
      for (let c = 0; c < e.steps.length; c++) {
        let h = e.steps[c].invert(e.docs[c]), d = new wn(e.mapping.maps[c], h, t), f;
        (f = u && u.merge(d)) && (d = f, c ? s.pop() : a = a.slice(0, a.length - 1)), s.push(d), t && (o++, t = void 0), i || (u = d);
      }
      let l = o - r.depth;
      return l > Sx && (a = kx(a, l), o -= l), new un(a.append(s), o);
    }
    remapping(e, t) {
      let r = new Vi();
      return this.items.forEach((i, s) => {
        let o = i.mirrorOffset != null && s - i.mirrorOffset >= e ? r.maps.length - i.mirrorOffset : void 0;
        r.appendMap(i.map, o);
      }, e, t), r;
    }
    addMaps(e) {
      return this.eventCount == 0 ? this : new un(this.items.append(e.map((t) => new wn(t))), this.eventCount);
    }
    rebased(e, t) {
      if (!this.eventCount) return this;
      let r = [], i = Math.max(0, this.items.length - t), s = e.mapping, o = e.steps.length, a = this.eventCount;
      this.items.forEach((d) => {
        d.selection && a--;
      }, i);
      let u = t;
      this.items.forEach((d) => {
        let f = s.getMirror(--u);
        if (f == null) return;
        o = Math.min(o, f);
        let p = s.maps[f];
        if (d.step) {
          let m = e.steps[f].invert(e.docs[f]), b = d.selection && d.selection.map(s.slice(u + 1, f));
          b && a++, r.push(new wn(p, m, b));
        } else r.push(new wn(p));
      }, i);
      let l = [];
      for (let d = t; d < o; d++) l.push(new wn(s.maps[d]));
      let c = this.items.slice(0, i).append(l).append(r), h = new un(c, a);
      return h.emptyItemCount() > xx && (h = h.compress(this.items.length - r.length)), h;
    }
    emptyItemCount() {
      let e = 0;
      return this.items.forEach((t) => {
        t.step || e++;
      }), e;
    }
    compress(e = this.items.length) {
      let t = this.remapping(0, e), r = t.maps.length, i = [], s = 0;
      return this.items.forEach((o, a) => {
        if (a >= e) i.push(o), o.selection && s++;
        else if (o.step) {
          let u = o.step.map(t.slice(r)), l = u && u.getMap();
          if (r--, l && t.appendMap(l, r), u) {
            let c = o.selection && o.selection.map(t.slice(r));
            c && s++;
            let h = new wn(l.invert(), u, c), d, f = i.length - 1;
            (d = i.length && i[f].merge(h)) ? i[f] = d : i.push(h);
          }
        } else o.map && r--;
      }, this.items.length, 0), new un(St.from(i.reverse()), s);
    }
  }
  un.empty = new un(St.empty, 0);
  function kx(n, e) {
    let t;
    return n.forEach((r, i) => {
      if (r.selection && e-- == 0) return t = i, false;
    }), n.slice(t);
  }
  class wn {
    constructor(e, t, r, i) {
      this.map = e, this.step = t, this.selection = r, this.mirrorOffset = i;
    }
    merge(e) {
      if (this.step && e.step && !e.selection) {
        let t = e.step.merge(this.step);
        if (t) return new wn(t.getMap().invert(), t, this.selection);
      }
    }
  }
  class Xn {
    constructor(e, t, r, i, s) {
      this.done = e, this.undone = t, this.prevRanges = r, this.prevTime = i, this.prevComposition = s;
    }
  }
  const Sx = 20;
  function Tx(n, e, t, r) {
    let i = t.getMeta(_r), s;
    if (i) return i.historyState;
    t.getMeta(Ox) && (n = new Xn(n.done, n.undone, null, 0, -1));
    let o = t.getMeta("appendedTransaction");
    if (t.steps.length == 0) return n;
    if (o && o.getMeta(_r)) return o.getMeta(_r).redo ? new Xn(n.done.addTransform(t, void 0, r, Vs(e)), n.undone, Sd(t.mapping.maps), n.prevTime, n.prevComposition) : new Xn(n.done, n.undone.addTransform(t, void 0, r, Vs(e)), null, n.prevTime, n.prevComposition);
    if (t.getMeta("addToHistory") !== false && !(o && o.getMeta("addToHistory") === false)) {
      let a = t.getMeta("composition"), u = n.prevTime == 0 || !o && n.prevComposition != a && (n.prevTime < (t.time || 0) - r.newGroupDelay || !Ex(t, n.prevRanges)), l = o ? Oa(n.prevRanges, t.mapping) : Sd(t.mapping.maps);
      return new Xn(n.done.addTransform(t, u ? e.selection.getBookmark() : void 0, r, Vs(e)), un.empty, l, t.time, a ?? n.prevComposition);
    } else return (s = t.getMeta("rebased")) ? new Xn(n.done.rebased(t, s), n.undone.rebased(t, s), Oa(n.prevRanges, t.mapping), n.prevTime, n.prevComposition) : new Xn(n.done.addMaps(t.mapping.maps), n.undone.addMaps(t.mapping.maps), Oa(n.prevRanges, t.mapping), n.prevTime, n.prevComposition);
  }
  function Ex(n, e) {
    if (!e) return false;
    if (!n.docChanged) return true;
    let t = false;
    return n.mapping.maps[0].forEach((r, i) => {
      for (let s = 0; s < e.length; s += 2) r <= e[s + 1] && i >= e[s] && (t = true);
    }), t;
  }
  function Sd(n) {
    let e = [];
    for (let t = n.length - 1; t >= 0 && e.length == 0; t--) n[t].forEach((r, i, s, o) => e.push(s, o));
    return e;
  }
  function Oa(n, e) {
    if (!n) return null;
    let t = [];
    for (let r = 0; r < n.length; r += 2) {
      let i = e.map(n[r], 1), s = e.map(n[r + 1], -1);
      i <= s && t.push(i, s);
    }
    return t;
  }
  function Cx(n, e, t) {
    let r = Vs(e), i = _r.get(e).spec.config, s = (t ? n.undone : n.done).popEvent(e, r);
    if (!s) return null;
    let o = s.selection.resolve(s.transform.doc), a = (t ? n.done : n.undone).addTransform(s.transform, e.selection.getBookmark(), i, r), u = new Xn(t ? a : s.remaining, t ? s.remaining : a, null, 0, -1);
    return s.transform.setSelection(o).setMeta(_r, {
      redo: t,
      historyState: u
    });
  }
  let Aa = false, Td = null;
  function Vs(n) {
    let e = n.plugins;
    if (Td != e) {
      Aa = false, Td = e;
      for (let t = 0; t < e.length; t++) if (e[t].spec.historyPreserveItems) {
        Aa = true;
        break;
      }
    }
    return Aa;
  }
  const _r = new Vt("history"), Ox = new Vt("closeHistory");
  function Ax(n = {}) {
    return n = {
      depth: n.depth || 100,
      newGroupDelay: n.newGroupDelay || 500
    }, new Dt({
      key: _r,
      state: {
        init() {
          return new Xn(un.empty, un.empty, null, 0, -1);
        },
        apply(e, t, r) {
          return Tx(t, r, e, n);
        }
      },
      config: n,
      props: {
        handleDOMEvents: {
          beforeinput(e, t) {
            let r = t.inputType, i = r == "historyUndo" ? A0 : r == "historyRedo" ? M0 : null;
            return i ? (t.preventDefault(), i(e.state, e.dispatch)) : false;
          }
        }
      }
    });
  }
  function O0(n, e) {
    return (t, r) => {
      let i = _r.getState(t);
      if (!i || (n ? i.undone : i.done).eventCount == 0) return false;
      if (r) {
        let s = Cx(i, t, n);
        s && r(e ? s.scrollIntoView() : s);
      }
      return true;
    };
  }
  const A0 = O0(false, true), M0 = O0(true, true), Mx = At.create({
    name: "history",
    addOptions() {
      return {
        depth: 100,
        newGroupDelay: 500
      };
    },
    addCommands() {
      return {
        undo: () => ({ state: n, dispatch: e }) => A0(n, e),
        redo: () => ({ state: n, dispatch: e }) => M0(n, e)
      };
    },
    addProseMirrorPlugins() {
      return [
        Ax(this.options)
      ];
    },
    addKeyboardShortcuts() {
      return {
        "Mod-z": () => this.editor.commands.undo(),
        "Shift-Mod-z": () => this.editor.commands.redo(),
        "Mod-y": () => this.editor.commands.redo(),
        "Mod-\u044F": () => this.editor.commands.undo(),
        "Shift-Mod-\u044F": () => this.editor.commands.redo()
      };
    }
  }), Nx = Bt.create({
    name: "horizontalRule",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    group: "block",
    parseHTML() {
      return [
        {
          tag: "hr"
        }
      ];
    },
    renderHTML({ HTMLAttributes: n }) {
      return [
        "hr",
        ot(this.options.HTMLAttributes, n)
      ];
    },
    addCommands() {
      return {
        setHorizontalRule: () => ({ chain: n, state: e }) => {
          const { selection: t } = e, { $from: r, $to: i } = t, s = n();
          return r.parentOffset === 0 ? s.insertContentAt({
            from: Math.max(r.pos - 1, 0),
            to: i.pos
          }, {
            type: this.name
          }) : h2(t) ? s.insertContentAt(i.pos, {
            type: this.name
          }) : s.insertContent({
            type: this.name
          }), s.command(({ tr: o, dispatch: a }) => {
            var u;
            if (a) {
              const { $to: l } = o.selection, c = l.end();
              if (l.nodeAfter) l.nodeAfter.isTextblock ? o.setSelection(Te.create(o.doc, l.pos + 1)) : l.nodeAfter.isBlock ? o.setSelection(ye.create(o.doc, l.pos)) : o.setSelection(Te.create(o.doc, l.pos));
              else {
                const h = (u = l.parent.type.contentMatch.defaultType) === null || u === void 0 ? void 0 : u.create();
                h && (o.insert(c, h), o.setSelection(Te.create(o.doc, c + 1)));
              }
              o.scrollIntoView();
            }
            return true;
          }).run();
        }
      };
    },
    addInputRules() {
      return [
        V2({
          find: /^(?:---|-|___\s|\*\*\*\s)$/,
          type: this.type
        })
      ];
    }
  }), Px = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, Dx = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, Ix = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, Rx = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, _x = cr.create({
    name: "italic",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML() {
      return [
        {
          tag: "em"
        },
        {
          tag: "i",
          getAttrs: (n) => n.style.fontStyle !== "normal" && null
        },
        {
          style: "font-style=normal",
          clearMark: (n) => n.type.name === this.name
        },
        {
          style: "font-style=italic"
        }
      ];
    },
    renderHTML({ HTMLAttributes: n }) {
      return [
        "em",
        ot(this.options.HTMLAttributes, n),
        0
      ];
    },
    addCommands() {
      return {
        setItalic: () => ({ commands: n }) => n.setMark(this.name),
        toggleItalic: () => ({ commands: n }) => n.toggleMark(this.name),
        unsetItalic: () => ({ commands: n }) => n.unsetMark(this.name)
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-i": () => this.editor.commands.toggleItalic(),
        "Mod-I": () => this.editor.commands.toggleItalic()
      };
    },
    addInputRules() {
      return [
        fi({
          find: Px,
          type: this.type
        }),
        fi({
          find: Ix,
          type: this.type
        })
      ];
    },
    addPasteRules() {
      return [
        hi({
          find: Dx,
          type: this.type
        }),
        hi({
          find: Rx,
          type: this.type
        })
      ];
    }
  }), Lx = Bt.create({
    name: "listItem",
    addOptions() {
      return {
        HTMLAttributes: {},
        bulletListTypeName: "bulletList",
        orderedListTypeName: "orderedList"
      };
    },
    content: "paragraph block*",
    defining: true,
    parseHTML() {
      return [
        {
          tag: "li"
        }
      ];
    },
    renderHTML({ HTMLAttributes: n }) {
      return [
        "li",
        ot(this.options.HTMLAttributes, n),
        0
      ];
    },
    addKeyboardShortcuts() {
      return {
        Enter: () => this.editor.commands.splitListItem(this.name),
        Tab: () => this.editor.commands.sinkListItem(this.name),
        "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
      };
    }
  }), Bx = "listItem", Ed = "textStyle", Cd = /^(\d+)\.\s$/, Fx = Bt.create({
    name: "orderedList",
    addOptions() {
      return {
        itemTypeName: "listItem",
        HTMLAttributes: {},
        keepMarks: false,
        keepAttributes: false
      };
    },
    group: "block list",
    content() {
      return `${this.options.itemTypeName}+`;
    },
    addAttributes() {
      return {
        start: {
          default: 1,
          parseHTML: (n) => n.hasAttribute("start") ? parseInt(n.getAttribute("start") || "", 10) : 1
        },
        type: {
          default: void 0,
          parseHTML: (n) => n.getAttribute("type")
        }
      };
    },
    parseHTML() {
      return [
        {
          tag: "ol"
        }
      ];
    },
    renderHTML({ HTMLAttributes: n }) {
      const { start: e, ...t } = n;
      return e === 1 ? [
        "ol",
        ot(this.options.HTMLAttributes, t),
        0
      ] : [
        "ol",
        ot(this.options.HTMLAttributes, n),
        0
      ];
    },
    addCommands() {
      return {
        toggleOrderedList: () => ({ commands: n, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(Bx, this.editor.getAttributes(Ed)).run() : n.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
      };
    },
    addInputRules() {
      let n = Ji({
        find: Cd,
        type: this.type,
        getAttributes: (e) => ({
          start: +e[1]
        }),
        joinPredicate: (e, t) => t.childCount + t.attrs.start === +e[1]
      });
      return (this.options.keepMarks || this.options.keepAttributes) && (n = Ji({
        find: Cd,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: (e) => ({
          start: +e[1],
          ...this.editor.getAttributes(Ed)
        }),
        joinPredicate: (e, t) => t.childCount + t.attrs.start === +e[1],
        editor: this.editor
      })), [
        n
      ];
    }
  }), zx = Bt.create({
    name: "paragraph",
    priority: 1e3,
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    group: "block",
    content: "inline*",
    parseHTML() {
      return [
        {
          tag: "p"
        }
      ];
    },
    renderHTML({ HTMLAttributes: n }) {
      return [
        "p",
        ot(this.options.HTMLAttributes, n),
        0
      ];
    },
    addCommands() {
      return {
        setParagraph: () => ({ commands: n }) => n.setNode(this.name)
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Alt-0": () => this.editor.commands.setParagraph()
      };
    }
  }), jx = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, qx = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, $x = cr.create({
    name: "strike",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML() {
      return [
        {
          tag: "s"
        },
        {
          tag: "del"
        },
        {
          tag: "strike"
        },
        {
          style: "text-decoration",
          consuming: false,
          getAttrs: (n) => n.includes("line-through") ? {} : false
        }
      ];
    },
    renderHTML({ HTMLAttributes: n }) {
      return [
        "s",
        ot(this.options.HTMLAttributes, n),
        0
      ];
    },
    addCommands() {
      return {
        setStrike: () => ({ commands: n }) => n.setMark(this.name),
        toggleStrike: () => ({ commands: n }) => n.toggleMark(this.name),
        unsetStrike: () => ({ commands: n }) => n.unsetMark(this.name)
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Shift-s": () => this.editor.commands.toggleStrike()
      };
    },
    addInputRules() {
      return [
        fi({
          find: jx,
          type: this.type
        })
      ];
    },
    addPasteRules() {
      return [
        hi({
          find: qx,
          type: this.type
        })
      ];
    }
  }), Vx = Bt.create({
    name: "text",
    group: "inline"
  }), N0 = At.create({
    name: "starterKit",
    addExtensions() {
      var n, e, t, r, i, s, o, a, u, l, c, h, d, f, p, m, b, g;
      const w = [];
      return this.options.bold !== false && w.push(X2.configure((n = this.options) === null || n === void 0 ? void 0 : n.bold)), this.options.blockquote !== false && w.push(U2.configure((e = this.options) === null || e === void 0 ? void 0 : e.blockquote)), this.options.bulletList !== false && w.push(Z2.configure((t = this.options) === null || t === void 0 ? void 0 : t.bulletList)), this.options.code !== false && w.push(nx.configure((r = this.options) === null || r === void 0 ? void 0 : r.code)), this.options.codeBlock !== false && w.push(sx.configure((i = this.options) === null || i === void 0 ? void 0 : i.codeBlock)), this.options.document !== false && w.push(ox.configure((s = this.options) === null || s === void 0 ? void 0 : s.document)), this.options.dropcursor !== false && w.push(lx.configure((o = this.options) === null || o === void 0 ? void 0 : o.dropcursor)), this.options.gapcursor !== false && w.push(bx.configure((a = this.options) === null || a === void 0 ? void 0 : a.gapcursor)), this.options.hardBreak !== false && w.push(yx.configure((u = this.options) === null || u === void 0 ? void 0 : u.hardBreak)), this.options.heading !== false && w.push(vx.configure((l = this.options) === null || l === void 0 ? void 0 : l.heading)), this.options.history !== false && w.push(Mx.configure((c = this.options) === null || c === void 0 ? void 0 : c.history)), this.options.horizontalRule !== false && w.push(Nx.configure((h = this.options) === null || h === void 0 ? void 0 : h.horizontalRule)), this.options.italic !== false && w.push(_x.configure((d = this.options) === null || d === void 0 ? void 0 : d.italic)), this.options.listItem !== false && w.push(Lx.configure((f = this.options) === null || f === void 0 ? void 0 : f.listItem)), this.options.orderedList !== false && w.push(Fx.configure((p = this.options) === null || p === void 0 ? void 0 : p.orderedList)), this.options.paragraph !== false && w.push(zx.configure((m = this.options) === null || m === void 0 ? void 0 : m.paragraph)), this.options.strike !== false && w.push($x.configure((b = this.options) === null || b === void 0 ? void 0 : b.strike)), this.options.text !== false && w.push(Vx.configure((g = this.options) === null || g === void 0 ? void 0 : g.text)), w;
    }
  });
  function Hx(n) {
    var e;
    const { char: t, allowSpaces: r, allowToIncludeChar: i, allowedPrefixes: s, startOfLine: o, $position: a } = n, u = r && !i, l = H2(t), c = new RegExp(`\\s${l}$`), h = o ? "^" : "", d = i ? "" : l, f = u ? new RegExp(`${h}${l}.*?(?=\\s${d}|$)`, "gm") : new RegExp(`${h}(?:^)?${l}[^\\s${d}]*`, "gm"), p = ((e = a.nodeBefore) === null || e === void 0 ? void 0 : e.isText) && a.nodeBefore.text;
    if (!p) return null;
    const m = a.pos - p.length, b = Array.from(p.matchAll(f)).pop();
    if (!b || b.input === void 0 || b.index === void 0) return null;
    const g = b.input.slice(Math.max(0, b.index - 1), b.index), w = new RegExp(`^[${s?.join("")}\0]?$`).test(g);
    if (s !== null && !w) return null;
    const v = m + b.index;
    let y = v + b[0].length;
    return u && c.test(p.slice(y - 1, y + 1)) && (b[0] += " ", y += 1), v < a.pos && y >= a.pos ? {
      range: {
        from: v,
        to: y
      },
      query: b[0].slice(t.length),
      text: b[0]
    } : null;
  }
  const Wx = new Vt("suggestion");
  function Ux({ pluginKey: n = Wx, editor: e, char: t = "@", allowSpaces: r = false, allowToIncludeChar: i = false, allowedPrefixes: s = [
    " "
  ], startOfLine: o = false, decorationTag: a = "span", decorationClass: u = "suggestion", command: l = () => null, items: c = () => [], render: h = () => ({}), allow: d = () => true, findSuggestionMatch: f = Hx }) {
    let p;
    const m = h?.(), b = new Dt({
      key: n,
      view() {
        return {
          update: async (g, w) => {
            var v, y, x, k, T, M, D;
            const I = (v = this.key) === null || v === void 0 ? void 0 : v.getState(w), C = (y = this.key) === null || y === void 0 ? void 0 : y.getState(g.state), O = I.active && C.active && I.range.from !== C.range.from, E = !I.active && C.active, N = I.active && !C.active, A = !E && !N && I.query !== C.query, R = E || O && A, B = A || O, z = N || O && A;
            if (!R && !B && !z) return;
            const L = z && !R ? I : C, V = g.dom.querySelector(`[data-decoration-id="${L.decorationId}"]`);
            p = {
              editor: e,
              range: L.range,
              query: L.query,
              text: L.text,
              items: [],
              command: (K) => l({
                editor: e,
                range: L.range,
                props: K
              }),
              decorationNode: V,
              clientRect: V ? () => {
                var K;
                const { decorationId: pe } = (K = this.key) === null || K === void 0 ? void 0 : K.getState(e.state), H = g.dom.querySelector(`[data-decoration-id="${pe}"]`);
                return H?.getBoundingClientRect() || null;
              } : null
            }, R && ((x = m?.onBeforeStart) === null || x === void 0 || x.call(m, p)), B && ((k = m?.onBeforeUpdate) === null || k === void 0 || k.call(m, p)), (B || R) && (p.items = await c({
              editor: e,
              query: L.query
            })), z && ((T = m?.onExit) === null || T === void 0 || T.call(m, p)), B && ((M = m?.onUpdate) === null || M === void 0 || M.call(m, p)), R && ((D = m?.onStart) === null || D === void 0 || D.call(m, p));
          },
          destroy: () => {
            var g;
            p && ((g = m?.onExit) === null || g === void 0 || g.call(m, p));
          }
        };
      },
      state: {
        init() {
          return {
            active: false,
            range: {
              from: 0,
              to: 0
            },
            query: null,
            text: null,
            composing: false
          };
        },
        apply(g, w, v, y) {
          const { isEditable: x } = e, { composing: k } = e.view, { selection: T } = g, { empty: M, from: D } = T, I = {
            ...w
          };
          if (I.composing = k, x && (M || e.view.composing)) {
            (D < w.range.from || D > w.range.to) && !k && !w.composing && (I.active = false);
            const C = f({
              char: t,
              allowSpaces: r,
              allowToIncludeChar: i,
              allowedPrefixes: s,
              startOfLine: o,
              $position: T.$from
            }), O = `id_${Math.floor(Math.random() * 4294967295)}`;
            C && d({
              editor: e,
              state: y,
              range: C.range,
              isActive: w.active
            }) ? (I.active = true, I.decorationId = w.decorationId ? w.decorationId : O, I.range = C.range, I.query = C.query, I.text = C.text) : I.active = false;
          } else I.active = false;
          return I.active || (I.decorationId = null, I.range = {
            from: 0,
            to: 0
          }, I.query = null, I.text = null), I;
        }
      },
      props: {
        handleKeyDown(g, w) {
          var v;
          const { active: y, range: x } = b.getState(g.state);
          return y && ((v = m?.onKeyDown) === null || v === void 0 ? void 0 : v.call(m, {
            view: g,
            event: w,
            range: x
          })) || false;
        },
        decorations(g) {
          const { active: w, range: v, decorationId: y } = b.getState(g);
          return w ? ut.create(g.doc, [
            jt.inline(v.from, v.to, {
              nodeName: a,
              class: u,
              "data-decoration-id": y
            })
          ]) : null;
        }
      }
    });
    return b;
  }
  const Gx = new Vt("mention"), P0 = Bt.create({
    name: "mention",
    priority: 101,
    addOptions() {
      return {
        HTMLAttributes: {},
        renderText({ options: n, node: e }) {
          var t;
          return `${n.suggestion.char}${(t = e.attrs.label) !== null && t !== void 0 ? t : e.attrs.id}`;
        },
        deleteTriggerWithBackspace: false,
        renderHTML({ options: n, node: e }) {
          var t;
          return [
            "span",
            ot(this.HTMLAttributes, n.HTMLAttributes),
            `${n.suggestion.char}${(t = e.attrs.label) !== null && t !== void 0 ? t : e.attrs.id}`
          ];
        },
        suggestion: {
          char: "@",
          pluginKey: Gx,
          command: ({ editor: n, range: e, props: t }) => {
            var r, i, s;
            const o = n.view.state.selection.$to.nodeAfter;
            ((r = o?.text) === null || r === void 0 ? void 0 : r.startsWith(" ")) && (e.to += 1), n.chain().focus().insertContentAt(e, [
              {
                type: this.name,
                attrs: t
              },
              {
                type: "text",
                text: " "
              }
            ]).run(), (s = (i = n.view.dom.ownerDocument.defaultView) === null || i === void 0 ? void 0 : i.getSelection()) === null || s === void 0 || s.collapseToEnd();
          },
          allow: ({ state: n, range: e }) => {
            const t = n.doc.resolve(e.from), r = n.schema.nodes[this.name];
            return !!t.parent.type.contentMatch.matchType(r);
          }
        }
      };
    },
    group: "inline",
    inline: true,
    selectable: false,
    atom: true,
    addAttributes() {
      return {
        id: {
          default: null,
          parseHTML: (n) => n.getAttribute("data-id"),
          renderHTML: (n) => n.id ? {
            "data-id": n.id
          } : {}
        },
        label: {
          default: null,
          parseHTML: (n) => n.getAttribute("data-label"),
          renderHTML: (n) => n.label ? {
            "data-label": n.label
          } : {}
        }
      };
    },
    parseHTML() {
      return [
        {
          tag: `span[data-type="${this.name}"]`
        }
      ];
    },
    renderHTML({ node: n, HTMLAttributes: e }) {
      if (this.options.renderLabel !== void 0) return console.warn("renderLabel is deprecated use renderText and renderHTML instead"), [
        "span",
        ot({
          "data-type": this.name
        }, this.options.HTMLAttributes, e),
        this.options.renderLabel({
          options: this.options,
          node: n
        })
      ];
      const t = {
        ...this.options
      };
      t.HTMLAttributes = ot({
        "data-type": this.name
      }, this.options.HTMLAttributes, e);
      const r = this.options.renderHTML({
        options: t,
        node: n
      });
      return typeof r == "string" ? [
        "span",
        ot({
          "data-type": this.name
        }, this.options.HTMLAttributes, e),
        r
      ] : r;
    },
    renderText({ node: n }) {
      return this.options.renderLabel !== void 0 ? (console.warn("renderLabel is deprecated use renderText and renderHTML instead"), this.options.renderLabel({
        options: this.options,
        node: n
      })) : this.options.renderText({
        options: this.options,
        node: n
      });
    },
    addKeyboardShortcuts() {
      return {
        Backspace: () => this.editor.commands.command(({ tr: n, state: e }) => {
          let t = false;
          const { selection: r } = e, { empty: i, anchor: s } = r;
          return i ? (e.doc.nodesBetween(s - 1, s, (o, a) => {
            if (o.type.name === this.name) return t = true, n.insertText(this.options.deleteTriggerWithBackspace ? "" : this.options.suggestion.char || "", a, a + o.nodeSize), false;
          }), t) : false;
        })
      };
    },
    addProseMirrorPlugins() {
      return [
        Ux({
          editor: this.editor,
          ...this.options.suggestion
        })
      ];
    }
  });
  function Il() {
    return {
      async: false,
      breaks: false,
      extensions: null,
      gfm: true,
      hooks: null,
      pedantic: false,
      renderer: null,
      silent: false,
      tokenizer: null,
      walkTokens: null
    };
  }
  let Hr = Il();
  function D0(n) {
    Hr = n;
  }
  const Bi = {
    exec: () => null
  };
  function Ke(n, e = "") {
    let t = typeof n == "string" ? n : n.source;
    const r = {
      replace: (i, s) => {
        let o = typeof s == "string" ? s : s.source;
        return o = o.replace(It.caret, "$1"), t = t.replace(i, o), r;
      },
      getRegex: () => new RegExp(t, e)
    };
    return r;
  }
  const It = {
    codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm,
    outputLinkReplace: /\\([\[\]])/g,
    indentCodeCompensation: /^(\s+)(?:```)/,
    beginningSpace: /^\s+/,
    endingHash: /#$/,
    startingSpaceChar: /^ /,
    endingSpaceChar: / $/,
    nonSpaceChar: /[^ ]/,
    newLineCharGlobal: /\n/g,
    tabCharGlobal: /\t/g,
    multipleSpaceGlobal: /\s+/g,
    blankLine: /^[ \t]*$/,
    doubleBlankLine: /\n[ \t]*\n[ \t]*$/,
    blockquoteStart: /^ {0,3}>/,
    blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
    blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm,
    listReplaceTabs: /^\t+/,
    listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,
    listIsTask: /^\[[ xX]\] /,
    listReplaceTask: /^\[[ xX]\] +/,
    anyLine: /\n.*\n/,
    hrefBrackets: /^<(.*)>$/,
    tableDelimiter: /[:|]/,
    tableAlignChars: /^\||\| *$/g,
    tableRowBlankLine: /\n[ \t]*$/,
    tableAlignRight: /^ *-+: *$/,
    tableAlignCenter: /^ *:-+: *$/,
    tableAlignLeft: /^ *:-+ *$/,
    startATag: /^<a /i,
    endATag: /^<\/a>/i,
    startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i,
    endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i,
    startAngleBracket: /^</,
    endAngleBracket: />$/,
    pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/,
    unicodeAlphaNumeric: /[\p{L}\p{N}]/u,
    escapeTest: /[&<>"']/,
    escapeReplace: /[&<>"']/g,
    escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
    escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,
    unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,
    caret: /(^|[^\[])\^/g,
    percentDecode: /%25/g,
    findPipe: /\|/g,
    splitPipe: / \|/,
    slashPipe: /\\\|/g,
    carriageReturn: /\r\n|\r/g,
    spaceLine: /^ +$/gm,
    notSpaceStart: /^\S*/,
    endingNewline: /\n$/,
    listItemRegex: (n) => new RegExp(`^( {0,3}${n})((?:[	 ][^\\n]*)?(?:\\n|$))`),
    nextBulletRegex: (n) => new RegExp(`^ {0,${Math.min(3, n - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),
    hrRegex: (n) => new RegExp(`^ {0,${Math.min(3, n - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),
    fencesBeginRegex: (n) => new RegExp(`^ {0,${Math.min(3, n - 1)}}(?:\`\`\`|~~~)`),
    headingBeginRegex: (n) => new RegExp(`^ {0,${Math.min(3, n - 1)}}#`),
    htmlBeginRegex: (n) => new RegExp(`^ {0,${Math.min(3, n - 1)}}<(?:[a-z].*>|!--)`, "i")
  }, Kx = /^(?:[ \t]*(?:\n|$))+/, Jx = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/, Yx = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, rs = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, Xx = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, Rl = /(?:[*+-]|\d{1,9}[.)])/, I0 = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/, R0 = Ke(I0).replace(/bull/g, Rl).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex(), Qx = Ke(I0).replace(/bull/g, Rl).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(), _l = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, Zx = /^[^\n]+/, Ll = /(?!\s*\])(?:\\.|[^\[\]\\])+/, ek = Ke(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", Ll).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), tk = Ke(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, Rl).getRegex(), Ko = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", Bl = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, nk = Ke("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", Bl).replace("tag", Ko).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), _0 = Ke(_l).replace("hr", rs).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Ko).getRegex(), rk = Ke(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", _0).getRegex(), Fl = {
    blockquote: rk,
    code: Jx,
    def: ek,
    fences: Yx,
    heading: Xx,
    hr: rs,
    html: nk,
    lheading: R0,
    list: tk,
    newline: Kx,
    paragraph: _0,
    table: Bi,
    text: Zx
  }, Od = Ke("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", rs).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Ko).getRegex(), ik = {
    ...Fl,
    lheading: Qx,
    table: Od,
    paragraph: Ke(_l).replace("hr", rs).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", Od).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Ko).getRegex()
  }, sk = {
    ...Fl,
    html: Ke(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", Bl).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: Bi,
    lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
    paragraph: Ke(_l).replace("hr", rs).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", R0).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
  }, ok = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, ak = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, L0 = /^( {2,}|\\)\n(?!\s*$)/, uk = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, Jo = /[\p{P}\p{S}]/u, zl = /[\s\p{P}\p{S}]/u, B0 = /[^\s\p{P}\p{S}]/u, lk = Ke(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, zl).getRegex(), F0 = /(?!~)[\p{P}\p{S}]/u, ck = /(?!~)[\s\p{P}\p{S}]/u, dk = /(?:[^\s\p{P}\p{S}]|~)/u, fk = /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g, z0 = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/, hk = Ke(z0, "u").replace(/punct/g, Jo).getRegex(), pk = Ke(z0, "u").replace(/punct/g, F0).getRegex(), j0 = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)", mk = Ke(j0, "gu").replace(/notPunctSpace/g, B0).replace(/punctSpace/g, zl).replace(/punct/g, Jo).getRegex(), gk = Ke(j0, "gu").replace(/notPunctSpace/g, dk).replace(/punctSpace/g, ck).replace(/punct/g, F0).getRegex(), bk = Ke("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, B0).replace(/punctSpace/g, zl).replace(/punct/g, Jo).getRegex(), yk = Ke(/\\(punct)/, "gu").replace(/punct/g, Jo).getRegex(), vk = Ke(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), wk = Ke(Bl).replace("(?:-->|$)", "-->").getRegex(), xk = Ke("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", wk).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), fo = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, kk = Ke(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", fo).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), q0 = Ke(/^!?\[(label)\]\[(ref)\]/).replace("label", fo).replace("ref", Ll).getRegex(), $0 = Ke(/^!?\[(ref)\](?:\[\])?/).replace("ref", Ll).getRegex(), Sk = Ke("reflink|nolink(?!\\()", "g").replace("reflink", q0).replace("nolink", $0).getRegex(), jl = {
    _backpedal: Bi,
    anyPunctuation: yk,
    autolink: vk,
    blockSkip: fk,
    br: L0,
    code: ak,
    del: Bi,
    emStrongLDelim: hk,
    emStrongRDelimAst: mk,
    emStrongRDelimUnd: bk,
    escape: ok,
    link: kk,
    nolink: $0,
    punctuation: lk,
    reflink: q0,
    reflinkSearch: Sk,
    tag: xk,
    text: uk,
    url: Bi
  }, Tk = {
    ...jl,
    link: Ke(/^!?\[(label)\]\((.*?)\)/).replace("label", fo).getRegex(),
    reflink: Ke(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", fo).getRegex()
  }, Gu = {
    ...jl,
    emStrongRDelimAst: gk,
    emStrongLDelim: pk,
    url: Ke(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
    _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/,
    text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
  }, Ek = {
    ...Gu,
    br: Ke(L0).replace("{2,}", "*").getRegex(),
    text: Ke(Gu.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
  }, vs = {
    normal: Fl,
    gfm: ik,
    pedantic: sk
  }, Si = {
    normal: jl,
    gfm: Gu,
    breaks: Ek,
    pedantic: Tk
  }, Ck = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  }, Ad = (n) => Ck[n];
  function vn(n, e) {
    if (e) {
      if (It.escapeTest.test(n)) return n.replace(It.escapeReplace, Ad);
    } else if (It.escapeTestNoEncode.test(n)) return n.replace(It.escapeReplaceNoEncode, Ad);
    return n;
  }
  function Md(n) {
    try {
      n = encodeURI(n).replace(It.percentDecode, "%");
    } catch {
      return null;
    }
    return n;
  }
  function Nd(n, e) {
    const t = n.replace(It.findPipe, (s, o, a) => {
      let u = false, l = o;
      for (; --l >= 0 && a[l] === "\\"; ) u = !u;
      return u ? "|" : " |";
    }), r = t.split(It.splitPipe);
    let i = 0;
    if (r[0].trim() || r.shift(), r.length > 0 && !r.at(-1)?.trim() && r.pop(), e) if (r.length > e) r.splice(e);
    else for (; r.length < e; ) r.push("");
    for (; i < r.length; i++) r[i] = r[i].trim().replace(It.slashPipe, "|");
    return r;
  }
  function Ti(n, e, t) {
    const r = n.length;
    if (r === 0) return "";
    let i = 0;
    for (; i < r && n.charAt(r - i - 1) === e; ) i++;
    return n.slice(0, r - i);
  }
  function Ok(n, e) {
    if (n.indexOf(e[1]) === -1) return -1;
    let t = 0;
    for (let r = 0; r < n.length; r++) if (n[r] === "\\") r++;
    else if (n[r] === e[0]) t++;
    else if (n[r] === e[1] && (t--, t < 0)) return r;
    return -1;
  }
  function Pd(n, e, t, r, i) {
    const s = e.href, o = e.title || null, a = n[1].replace(i.other.outputLinkReplace, "$1");
    if (n[0].charAt(0) !== "!") {
      r.state.inLink = true;
      const u = {
        type: "link",
        raw: t,
        href: s,
        title: o,
        text: a,
        tokens: r.inlineTokens(a)
      };
      return r.state.inLink = false, u;
    }
    return {
      type: "image",
      raw: t,
      href: s,
      title: o,
      text: a
    };
  }
  function Ak(n, e, t) {
    const r = n.match(t.other.indentCodeCompensation);
    if (r === null) return e;
    const i = r[1];
    return e.split(`
`).map((s) => {
      const o = s.match(t.other.beginningSpace);
      if (o === null) return s;
      const [a] = o;
      return a.length >= i.length ? s.slice(i.length) : s;
    }).join(`
`);
  }
  class ho {
    options;
    rules;
    lexer;
    constructor(e) {
      this.options = e || Hr;
    }
    space(e) {
      const t = this.rules.block.newline.exec(e);
      if (t && t[0].length > 0) return {
        type: "space",
        raw: t[0]
      };
    }
    code(e) {
      const t = this.rules.block.code.exec(e);
      if (t) {
        const r = t[0].replace(this.rules.other.codeRemoveIndent, "");
        return {
          type: "code",
          raw: t[0],
          codeBlockStyle: "indented",
          text: this.options.pedantic ? r : Ti(r, `
`)
        };
      }
    }
    fences(e) {
      const t = this.rules.block.fences.exec(e);
      if (t) {
        const r = t[0], i = Ak(r, t[3] || "", this.rules);
        return {
          type: "code",
          raw: r,
          lang: t[2] ? t[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : t[2],
          text: i
        };
      }
    }
    heading(e) {
      const t = this.rules.block.heading.exec(e);
      if (t) {
        let r = t[2].trim();
        if (this.rules.other.endingHash.test(r)) {
          const i = Ti(r, "#");
          (this.options.pedantic || !i || this.rules.other.endingSpaceChar.test(i)) && (r = i.trim());
        }
        return {
          type: "heading",
          raw: t[0],
          depth: t[1].length,
          text: r,
          tokens: this.lexer.inline(r)
        };
      }
    }
    hr(e) {
      const t = this.rules.block.hr.exec(e);
      if (t) return {
        type: "hr",
        raw: Ti(t[0], `
`)
      };
    }
    blockquote(e) {
      const t = this.rules.block.blockquote.exec(e);
      if (t) {
        let r = Ti(t[0], `
`).split(`
`), i = "", s = "";
        const o = [];
        for (; r.length > 0; ) {
          let a = false;
          const u = [];
          let l;
          for (l = 0; l < r.length; l++) if (this.rules.other.blockquoteStart.test(r[l])) u.push(r[l]), a = true;
          else if (!a) u.push(r[l]);
          else break;
          r = r.slice(l);
          const c = u.join(`
`), h = c.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
          i = i ? `${i}
${c}` : c, s = s ? `${s}
${h}` : h;
          const d = this.lexer.state.top;
          if (this.lexer.state.top = true, this.lexer.blockTokens(h, o, true), this.lexer.state.top = d, r.length === 0) break;
          const f = o.at(-1);
          if (f?.type === "code") break;
          if (f?.type === "blockquote") {
            const p = f, m = p.raw + `
` + r.join(`
`), b = this.blockquote(m);
            o[o.length - 1] = b, i = i.substring(0, i.length - p.raw.length) + b.raw, s = s.substring(0, s.length - p.text.length) + b.text;
            break;
          } else if (f?.type === "list") {
            const p = f, m = p.raw + `
` + r.join(`
`), b = this.list(m);
            o[o.length - 1] = b, i = i.substring(0, i.length - f.raw.length) + b.raw, s = s.substring(0, s.length - p.raw.length) + b.raw, r = m.substring(o.at(-1).raw.length).split(`
`);
            continue;
          }
        }
        return {
          type: "blockquote",
          raw: i,
          tokens: o,
          text: s
        };
      }
    }
    list(e) {
      let t = this.rules.block.list.exec(e);
      if (t) {
        let r = t[1].trim();
        const i = r.length > 1, s = {
          type: "list",
          raw: "",
          ordered: i,
          start: i ? +r.slice(0, -1) : "",
          loose: false,
          items: []
        };
        r = i ? `\\d{1,9}\\${r.slice(-1)}` : `\\${r}`, this.options.pedantic && (r = i ? r : "[*+-]");
        const o = this.rules.other.listItemRegex(r);
        let a = false;
        for (; e; ) {
          let l = false, c = "", h = "";
          if (!(t = o.exec(e)) || this.rules.block.hr.test(e)) break;
          c = t[0], e = e.substring(c.length);
          let d = t[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, (w) => " ".repeat(3 * w.length)), f = e.split(`
`, 1)[0], p = !d.trim(), m = 0;
          if (this.options.pedantic ? (m = 2, h = d.trimStart()) : p ? m = t[1].length + 1 : (m = t[2].search(this.rules.other.nonSpaceChar), m = m > 4 ? 1 : m, h = d.slice(m), m += t[1].length), p && this.rules.other.blankLine.test(f) && (c += f + `
`, e = e.substring(f.length + 1), l = true), !l) {
            const w = this.rules.other.nextBulletRegex(m), v = this.rules.other.hrRegex(m), y = this.rules.other.fencesBeginRegex(m), x = this.rules.other.headingBeginRegex(m), k = this.rules.other.htmlBeginRegex(m);
            for (; e; ) {
              const T = e.split(`
`, 1)[0];
              let M;
              if (f = T, this.options.pedantic ? (f = f.replace(this.rules.other.listReplaceNesting, "  "), M = f) : M = f.replace(this.rules.other.tabCharGlobal, "    "), y.test(f) || x.test(f) || k.test(f) || w.test(f) || v.test(f)) break;
              if (M.search(this.rules.other.nonSpaceChar) >= m || !f.trim()) h += `
` + M.slice(m);
              else {
                if (p || d.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || y.test(d) || x.test(d) || v.test(d)) break;
                h += `
` + f;
              }
              !p && !f.trim() && (p = true), c += T + `
`, e = e.substring(T.length + 1), d = M.slice(m);
            }
          }
          s.loose || (a ? s.loose = true : this.rules.other.doubleBlankLine.test(c) && (a = true));
          let b = null, g;
          this.options.gfm && (b = this.rules.other.listIsTask.exec(h), b && (g = b[0] !== "[ ] ", h = h.replace(this.rules.other.listReplaceTask, ""))), s.items.push({
            type: "list_item",
            raw: c,
            task: !!b,
            checked: g,
            loose: false,
            text: h,
            tokens: []
          }), s.raw += c;
        }
        const u = s.items.at(-1);
        if (u) u.raw = u.raw.trimEnd(), u.text = u.text.trimEnd();
        else return;
        s.raw = s.raw.trimEnd();
        for (let l = 0; l < s.items.length; l++) if (this.lexer.state.top = false, s.items[l].tokens = this.lexer.blockTokens(s.items[l].text, []), !s.loose) {
          const c = s.items[l].tokens.filter((d) => d.type === "space"), h = c.length > 0 && c.some((d) => this.rules.other.anyLine.test(d.raw));
          s.loose = h;
        }
        if (s.loose) for (let l = 0; l < s.items.length; l++) s.items[l].loose = true;
        return s;
      }
    }
    html(e) {
      const t = this.rules.block.html.exec(e);
      if (t) return {
        type: "html",
        block: true,
        raw: t[0],
        pre: t[1] === "pre" || t[1] === "script" || t[1] === "style",
        text: t[0]
      };
    }
    def(e) {
      const t = this.rules.block.def.exec(e);
      if (t) {
        const r = t[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), i = t[2] ? t[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", s = t[3] ? t[3].substring(1, t[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : t[3];
        return {
          type: "def",
          tag: r,
          raw: t[0],
          href: i,
          title: s
        };
      }
    }
    table(e) {
      const t = this.rules.block.table.exec(e);
      if (!t || !this.rules.other.tableDelimiter.test(t[2])) return;
      const r = Nd(t[1]), i = t[2].replace(this.rules.other.tableAlignChars, "").split("|"), s = t[3]?.trim() ? t[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], o = {
        type: "table",
        raw: t[0],
        header: [],
        align: [],
        rows: []
      };
      if (r.length === i.length) {
        for (const a of i) this.rules.other.tableAlignRight.test(a) ? o.align.push("right") : this.rules.other.tableAlignCenter.test(a) ? o.align.push("center") : this.rules.other.tableAlignLeft.test(a) ? o.align.push("left") : o.align.push(null);
        for (let a = 0; a < r.length; a++) o.header.push({
          text: r[a],
          tokens: this.lexer.inline(r[a]),
          header: true,
          align: o.align[a]
        });
        for (const a of s) o.rows.push(Nd(a, o.header.length).map((u, l) => ({
          text: u,
          tokens: this.lexer.inline(u),
          header: false,
          align: o.align[l]
        })));
        return o;
      }
    }
    lheading(e) {
      const t = this.rules.block.lheading.exec(e);
      if (t) return {
        type: "heading",
        raw: t[0],
        depth: t[2].charAt(0) === "=" ? 1 : 2,
        text: t[1],
        tokens: this.lexer.inline(t[1])
      };
    }
    paragraph(e) {
      const t = this.rules.block.paragraph.exec(e);
      if (t) {
        const r = t[1].charAt(t[1].length - 1) === `
` ? t[1].slice(0, -1) : t[1];
        return {
          type: "paragraph",
          raw: t[0],
          text: r,
          tokens: this.lexer.inline(r)
        };
      }
    }
    text(e) {
      const t = this.rules.block.text.exec(e);
      if (t) return {
        type: "text",
        raw: t[0],
        text: t[0],
        tokens: this.lexer.inline(t[0])
      };
    }
    escape(e) {
      const t = this.rules.inline.escape.exec(e);
      if (t) return {
        type: "escape",
        raw: t[0],
        text: t[1]
      };
    }
    tag(e) {
      const t = this.rules.inline.tag.exec(e);
      if (t) return !this.lexer.state.inLink && this.rules.other.startATag.test(t[0]) ? this.lexer.state.inLink = true : this.lexer.state.inLink && this.rules.other.endATag.test(t[0]) && (this.lexer.state.inLink = false), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(t[0]) ? this.lexer.state.inRawBlock = true : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(t[0]) && (this.lexer.state.inRawBlock = false), {
        type: "html",
        raw: t[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        block: false,
        text: t[0]
      };
    }
    link(e) {
      const t = this.rules.inline.link.exec(e);
      if (t) {
        const r = t[2].trim();
        if (!this.options.pedantic && this.rules.other.startAngleBracket.test(r)) {
          if (!this.rules.other.endAngleBracket.test(r)) return;
          const o = Ti(r.slice(0, -1), "\\");
          if ((r.length - o.length) % 2 === 0) return;
        } else {
          const o = Ok(t[2], "()");
          if (o > -1) {
            const u = (t[0].indexOf("!") === 0 ? 5 : 4) + t[1].length + o;
            t[2] = t[2].substring(0, o), t[0] = t[0].substring(0, u).trim(), t[3] = "";
          }
        }
        let i = t[2], s = "";
        if (this.options.pedantic) {
          const o = this.rules.other.pedanticHrefTitle.exec(i);
          o && (i = o[1], s = o[3]);
        } else s = t[3] ? t[3].slice(1, -1) : "";
        return i = i.trim(), this.rules.other.startAngleBracket.test(i) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(r) ? i = i.slice(1) : i = i.slice(1, -1)), Pd(t, {
          href: i && i.replace(this.rules.inline.anyPunctuation, "$1"),
          title: s && s.replace(this.rules.inline.anyPunctuation, "$1")
        }, t[0], this.lexer, this.rules);
      }
    }
    reflink(e, t) {
      let r;
      if ((r = this.rules.inline.reflink.exec(e)) || (r = this.rules.inline.nolink.exec(e))) {
        const i = (r[2] || r[1]).replace(this.rules.other.multipleSpaceGlobal, " "), s = t[i.toLowerCase()];
        if (!s) {
          const o = r[0].charAt(0);
          return {
            type: "text",
            raw: o,
            text: o
          };
        }
        return Pd(r, s, r[0], this.lexer, this.rules);
      }
    }
    emStrong(e, t, r = "") {
      let i = this.rules.inline.emStrongLDelim.exec(e);
      if (!i || i[3] && r.match(this.rules.other.unicodeAlphaNumeric)) return;
      if (!(i[1] || i[2] || "") || !r || this.rules.inline.punctuation.exec(r)) {
        const o = [
          ...i[0]
        ].length - 1;
        let a, u, l = o, c = 0;
        const h = i[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
        for (h.lastIndex = 0, t = t.slice(-1 * e.length + o); (i = h.exec(t)) != null; ) {
          if (a = i[1] || i[2] || i[3] || i[4] || i[5] || i[6], !a) continue;
          if (u = [
            ...a
          ].length, i[3] || i[4]) {
            l += u;
            continue;
          } else if ((i[5] || i[6]) && o % 3 && !((o + u) % 3)) {
            c += u;
            continue;
          }
          if (l -= u, l > 0) continue;
          u = Math.min(u, u + l + c);
          const d = [
            ...i[0]
          ][0].length, f = e.slice(0, o + i.index + d + u);
          if (Math.min(o, u) % 2) {
            const m = f.slice(1, -1);
            return {
              type: "em",
              raw: f,
              text: m,
              tokens: this.lexer.inlineTokens(m)
            };
          }
          const p = f.slice(2, -2);
          return {
            type: "strong",
            raw: f,
            text: p,
            tokens: this.lexer.inlineTokens(p)
          };
        }
      }
    }
    codespan(e) {
      const t = this.rules.inline.code.exec(e);
      if (t) {
        let r = t[2].replace(this.rules.other.newLineCharGlobal, " ");
        const i = this.rules.other.nonSpaceChar.test(r), s = this.rules.other.startingSpaceChar.test(r) && this.rules.other.endingSpaceChar.test(r);
        return i && s && (r = r.substring(1, r.length - 1)), {
          type: "codespan",
          raw: t[0],
          text: r
        };
      }
    }
    br(e) {
      const t = this.rules.inline.br.exec(e);
      if (t) return {
        type: "br",
        raw: t[0]
      };
    }
    del(e) {
      const t = this.rules.inline.del.exec(e);
      if (t) return {
        type: "del",
        raw: t[0],
        text: t[2],
        tokens: this.lexer.inlineTokens(t[2])
      };
    }
    autolink(e) {
      const t = this.rules.inline.autolink.exec(e);
      if (t) {
        let r, i;
        return t[2] === "@" ? (r = t[1], i = "mailto:" + r) : (r = t[1], i = r), {
          type: "link",
          raw: t[0],
          text: r,
          href: i,
          tokens: [
            {
              type: "text",
              raw: r,
              text: r
            }
          ]
        };
      }
    }
    url(e) {
      let t;
      if (t = this.rules.inline.url.exec(e)) {
        let r, i;
        if (t[2] === "@") r = t[0], i = "mailto:" + r;
        else {
          let s;
          do
            s = t[0], t[0] = this.rules.inline._backpedal.exec(t[0])?.[0] ?? "";
          while (s !== t[0]);
          r = t[0], t[1] === "www." ? i = "http://" + t[0] : i = t[0];
        }
        return {
          type: "link",
          raw: t[0],
          text: r,
          href: i,
          tokens: [
            {
              type: "text",
              raw: r,
              text: r
            }
          ]
        };
      }
    }
    inlineText(e) {
      const t = this.rules.inline.text.exec(e);
      if (t) {
        const r = this.lexer.state.inRawBlock;
        return {
          type: "text",
          raw: t[0],
          text: t[0],
          escaped: r
        };
      }
    }
  }
  class Kt {
    tokens;
    options;
    state;
    tokenizer;
    inlineQueue;
    constructor(e) {
      this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e || Hr, this.options.tokenizer = this.options.tokenizer || new ho(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = {
        inLink: false,
        inRawBlock: false,
        top: true
      };
      const t = {
        other: It,
        block: vs.normal,
        inline: Si.normal
      };
      this.options.pedantic ? (t.block = vs.pedantic, t.inline = Si.pedantic) : this.options.gfm && (t.block = vs.gfm, this.options.breaks ? t.inline = Si.breaks : t.inline = Si.gfm), this.tokenizer.rules = t;
    }
    static get rules() {
      return {
        block: vs,
        inline: Si
      };
    }
    static lex(e, t) {
      return new Kt(t).lex(e);
    }
    static lexInline(e, t) {
      return new Kt(t).inlineTokens(e);
    }
    lex(e) {
      e = e.replace(It.carriageReturn, `
`), this.blockTokens(e, this.tokens);
      for (let t = 0; t < this.inlineQueue.length; t++) {
        const r = this.inlineQueue[t];
        this.inlineTokens(r.src, r.tokens);
      }
      return this.inlineQueue = [], this.tokens;
    }
    blockTokens(e, t = [], r = false) {
      for (this.options.pedantic && (e = e.replace(It.tabCharGlobal, "    ").replace(It.spaceLine, "")); e; ) {
        let i;
        if (this.options.extensions?.block?.some((o) => (i = o.call({
          lexer: this
        }, e, t)) ? (e = e.substring(i.raw.length), t.push(i), true) : false)) continue;
        if (i = this.tokenizer.space(e)) {
          e = e.substring(i.raw.length);
          const o = t.at(-1);
          i.raw.length === 1 && o !== void 0 ? o.raw += `
` : t.push(i);
          continue;
        }
        if (i = this.tokenizer.code(e)) {
          e = e.substring(i.raw.length);
          const o = t.at(-1);
          o?.type === "paragraph" || o?.type === "text" ? (o.raw += `
` + i.raw, o.text += `
` + i.text, this.inlineQueue.at(-1).src = o.text) : t.push(i);
          continue;
        }
        if (i = this.tokenizer.fences(e)) {
          e = e.substring(i.raw.length), t.push(i);
          continue;
        }
        if (i = this.tokenizer.heading(e)) {
          e = e.substring(i.raw.length), t.push(i);
          continue;
        }
        if (i = this.tokenizer.hr(e)) {
          e = e.substring(i.raw.length), t.push(i);
          continue;
        }
        if (i = this.tokenizer.blockquote(e)) {
          e = e.substring(i.raw.length), t.push(i);
          continue;
        }
        if (i = this.tokenizer.list(e)) {
          e = e.substring(i.raw.length), t.push(i);
          continue;
        }
        if (i = this.tokenizer.html(e)) {
          e = e.substring(i.raw.length), t.push(i);
          continue;
        }
        if (i = this.tokenizer.def(e)) {
          e = e.substring(i.raw.length);
          const o = t.at(-1);
          o?.type === "paragraph" || o?.type === "text" ? (o.raw += `
` + i.raw, o.text += `
` + i.raw, this.inlineQueue.at(-1).src = o.text) : this.tokens.links[i.tag] || (this.tokens.links[i.tag] = {
            href: i.href,
            title: i.title
          });
          continue;
        }
        if (i = this.tokenizer.table(e)) {
          e = e.substring(i.raw.length), t.push(i);
          continue;
        }
        if (i = this.tokenizer.lheading(e)) {
          e = e.substring(i.raw.length), t.push(i);
          continue;
        }
        let s = e;
        if (this.options.extensions?.startBlock) {
          let o = 1 / 0;
          const a = e.slice(1);
          let u;
          this.options.extensions.startBlock.forEach((l) => {
            u = l.call({
              lexer: this
            }, a), typeof u == "number" && u >= 0 && (o = Math.min(o, u));
          }), o < 1 / 0 && o >= 0 && (s = e.substring(0, o + 1));
        }
        if (this.state.top && (i = this.tokenizer.paragraph(s))) {
          const o = t.at(-1);
          r && o?.type === "paragraph" ? (o.raw += `
` + i.raw, o.text += `
` + i.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = o.text) : t.push(i), r = s.length !== e.length, e = e.substring(i.raw.length);
          continue;
        }
        if (i = this.tokenizer.text(e)) {
          e = e.substring(i.raw.length);
          const o = t.at(-1);
          o?.type === "text" ? (o.raw += `
` + i.raw, o.text += `
` + i.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = o.text) : t.push(i);
          continue;
        }
        if (e) {
          const o = "Infinite loop on byte: " + e.charCodeAt(0);
          if (this.options.silent) {
            console.error(o);
            break;
          } else throw new Error(o);
        }
      }
      return this.state.top = true, t;
    }
    inline(e, t = []) {
      return this.inlineQueue.push({
        src: e,
        tokens: t
      }), t;
    }
    inlineTokens(e, t = []) {
      let r = e, i = null;
      if (this.tokens.links) {
        const a = Object.keys(this.tokens.links);
        if (a.length > 0) for (; (i = this.tokenizer.rules.inline.reflinkSearch.exec(r)) != null; ) a.includes(i[0].slice(i[0].lastIndexOf("[") + 1, -1)) && (r = r.slice(0, i.index) + "[" + "a".repeat(i[0].length - 2) + "]" + r.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
      }
      for (; (i = this.tokenizer.rules.inline.blockSkip.exec(r)) != null; ) r = r.slice(0, i.index) + "[" + "a".repeat(i[0].length - 2) + "]" + r.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
      for (; (i = this.tokenizer.rules.inline.anyPunctuation.exec(r)) != null; ) r = r.slice(0, i.index) + "++" + r.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
      let s = false, o = "";
      for (; e; ) {
        s || (o = ""), s = false;
        let a;
        if (this.options.extensions?.inline?.some((l) => (a = l.call({
          lexer: this
        }, e, t)) ? (e = e.substring(a.raw.length), t.push(a), true) : false)) continue;
        if (a = this.tokenizer.escape(e)) {
          e = e.substring(a.raw.length), t.push(a);
          continue;
        }
        if (a = this.tokenizer.tag(e)) {
          e = e.substring(a.raw.length), t.push(a);
          continue;
        }
        if (a = this.tokenizer.link(e)) {
          e = e.substring(a.raw.length), t.push(a);
          continue;
        }
        if (a = this.tokenizer.reflink(e, this.tokens.links)) {
          e = e.substring(a.raw.length);
          const l = t.at(-1);
          a.type === "text" && l?.type === "text" ? (l.raw += a.raw, l.text += a.text) : t.push(a);
          continue;
        }
        if (a = this.tokenizer.emStrong(e, r, o)) {
          e = e.substring(a.raw.length), t.push(a);
          continue;
        }
        if (a = this.tokenizer.codespan(e)) {
          e = e.substring(a.raw.length), t.push(a);
          continue;
        }
        if (a = this.tokenizer.br(e)) {
          e = e.substring(a.raw.length), t.push(a);
          continue;
        }
        if (a = this.tokenizer.del(e)) {
          e = e.substring(a.raw.length), t.push(a);
          continue;
        }
        if (a = this.tokenizer.autolink(e)) {
          e = e.substring(a.raw.length), t.push(a);
          continue;
        }
        if (!this.state.inLink && (a = this.tokenizer.url(e))) {
          e = e.substring(a.raw.length), t.push(a);
          continue;
        }
        let u = e;
        if (this.options.extensions?.startInline) {
          let l = 1 / 0;
          const c = e.slice(1);
          let h;
          this.options.extensions.startInline.forEach((d) => {
            h = d.call({
              lexer: this
            }, c), typeof h == "number" && h >= 0 && (l = Math.min(l, h));
          }), l < 1 / 0 && l >= 0 && (u = e.substring(0, l + 1));
        }
        if (a = this.tokenizer.inlineText(u)) {
          e = e.substring(a.raw.length), a.raw.slice(-1) !== "_" && (o = a.raw.slice(-1)), s = true;
          const l = t.at(-1);
          l?.type === "text" ? (l.raw += a.raw, l.text += a.text) : t.push(a);
          continue;
        }
        if (e) {
          const l = "Infinite loop on byte: " + e.charCodeAt(0);
          if (this.options.silent) {
            console.error(l);
            break;
          } else throw new Error(l);
        }
      }
      return t;
    }
  }
  class po {
    options;
    parser;
    constructor(e) {
      this.options = e || Hr;
    }
    space(e) {
      return "";
    }
    code({ text: e, lang: t, escaped: r }) {
      const i = (t || "").match(It.notSpaceStart)?.[0], s = e.replace(It.endingNewline, "") + `
`;
      return i ? '<pre><code class="language-' + vn(i) + '">' + (r ? s : vn(s, true)) + `</code></pre>
` : "<pre><code>" + (r ? s : vn(s, true)) + `</code></pre>
`;
    }
    blockquote({ tokens: e }) {
      return `<blockquote>
${this.parser.parse(e)}</blockquote>
`;
    }
    html({ text: e }) {
      return e;
    }
    heading({ tokens: e, depth: t }) {
      return `<h${t}>${this.parser.parseInline(e)}</h${t}>
`;
    }
    hr(e) {
      return `<hr>
`;
    }
    list(e) {
      const t = e.ordered, r = e.start;
      let i = "";
      for (let a = 0; a < e.items.length; a++) {
        const u = e.items[a];
        i += this.listitem(u);
      }
      const s = t ? "ol" : "ul", o = t && r !== 1 ? ' start="' + r + '"' : "";
      return "<" + s + o + `>
` + i + "</" + s + `>
`;
    }
    listitem(e) {
      let t = "";
      if (e.task) {
        const r = this.checkbox({
          checked: !!e.checked
        });
        e.loose ? e.tokens[0]?.type === "paragraph" ? (e.tokens[0].text = r + " " + e.tokens[0].text, e.tokens[0].tokens && e.tokens[0].tokens.length > 0 && e.tokens[0].tokens[0].type === "text" && (e.tokens[0].tokens[0].text = r + " " + vn(e.tokens[0].tokens[0].text), e.tokens[0].tokens[0].escaped = true)) : e.tokens.unshift({
          type: "text",
          raw: r + " ",
          text: r + " ",
          escaped: true
        }) : t += r + " ";
      }
      return t += this.parser.parse(e.tokens, !!e.loose), `<li>${t}</li>
`;
    }
    checkbox({ checked: e }) {
      return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
    }
    paragraph({ tokens: e }) {
      return `<p>${this.parser.parseInline(e)}</p>
`;
    }
    table(e) {
      let t = "", r = "";
      for (let s = 0; s < e.header.length; s++) r += this.tablecell(e.header[s]);
      t += this.tablerow({
        text: r
      });
      let i = "";
      for (let s = 0; s < e.rows.length; s++) {
        const o = e.rows[s];
        r = "";
        for (let a = 0; a < o.length; a++) r += this.tablecell(o[a]);
        i += this.tablerow({
          text: r
        });
      }
      return i && (i = `<tbody>${i}</tbody>`), `<table>
<thead>
` + t + `</thead>
` + i + `</table>
`;
    }
    tablerow({ text: e }) {
      return `<tr>
${e}</tr>
`;
    }
    tablecell(e) {
      const t = this.parser.parseInline(e.tokens), r = e.header ? "th" : "td";
      return (e.align ? `<${r} align="${e.align}">` : `<${r}>`) + t + `</${r}>
`;
    }
    strong({ tokens: e }) {
      return `<strong>${this.parser.parseInline(e)}</strong>`;
    }
    em({ tokens: e }) {
      return `<em>${this.parser.parseInline(e)}</em>`;
    }
    codespan({ text: e }) {
      return `<code>${vn(e, true)}</code>`;
    }
    br(e) {
      return "<br>";
    }
    del({ tokens: e }) {
      return `<del>${this.parser.parseInline(e)}</del>`;
    }
    link({ href: e, title: t, tokens: r }) {
      const i = this.parser.parseInline(r), s = Md(e);
      if (s === null) return i;
      e = s;
      let o = '<a href="' + e + '"';
      return t && (o += ' title="' + vn(t) + '"'), o += ">" + i + "</a>", o;
    }
    image({ href: e, title: t, text: r }) {
      const i = Md(e);
      if (i === null) return vn(r);
      e = i;
      let s = `<img src="${e}" alt="${r}"`;
      return t && (s += ` title="${vn(t)}"`), s += ">", s;
    }
    text(e) {
      return "tokens" in e && e.tokens ? this.parser.parseInline(e.tokens) : "escaped" in e && e.escaped ? e.text : vn(e.text);
    }
  }
  class ql {
    strong({ text: e }) {
      return e;
    }
    em({ text: e }) {
      return e;
    }
    codespan({ text: e }) {
      return e;
    }
    del({ text: e }) {
      return e;
    }
    html({ text: e }) {
      return e;
    }
    text({ text: e }) {
      return e;
    }
    link({ text: e }) {
      return "" + e;
    }
    image({ text: e }) {
      return "" + e;
    }
    br() {
      return "";
    }
  }
  class Jt {
    options;
    renderer;
    textRenderer;
    constructor(e) {
      this.options = e || Hr, this.options.renderer = this.options.renderer || new po(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new ql();
    }
    static parse(e, t) {
      return new Jt(t).parse(e);
    }
    static parseInline(e, t) {
      return new Jt(t).parseInline(e);
    }
    parse(e, t = true) {
      let r = "";
      for (let i = 0; i < e.length; i++) {
        const s = e[i];
        if (this.options.extensions?.renderers?.[s.type]) {
          const a = s, u = this.options.extensions.renderers[a.type].call({
            parser: this
          }, a);
          if (u !== false || ![
            "space",
            "hr",
            "heading",
            "code",
            "table",
            "blockquote",
            "list",
            "html",
            "paragraph",
            "text"
          ].includes(a.type)) {
            r += u || "";
            continue;
          }
        }
        const o = s;
        switch (o.type) {
          case "space": {
            r += this.renderer.space(o);
            continue;
          }
          case "hr": {
            r += this.renderer.hr(o);
            continue;
          }
          case "heading": {
            r += this.renderer.heading(o);
            continue;
          }
          case "code": {
            r += this.renderer.code(o);
            continue;
          }
          case "table": {
            r += this.renderer.table(o);
            continue;
          }
          case "blockquote": {
            r += this.renderer.blockquote(o);
            continue;
          }
          case "list": {
            r += this.renderer.list(o);
            continue;
          }
          case "html": {
            r += this.renderer.html(o);
            continue;
          }
          case "paragraph": {
            r += this.renderer.paragraph(o);
            continue;
          }
          case "text": {
            let a = o, u = this.renderer.text(a);
            for (; i + 1 < e.length && e[i + 1].type === "text"; ) a = e[++i], u += `
` + this.renderer.text(a);
            t ? r += this.renderer.paragraph({
              type: "paragraph",
              raw: u,
              text: u,
              tokens: [
                {
                  type: "text",
                  raw: u,
                  text: u,
                  escaped: true
                }
              ]
            }) : r += u;
            continue;
          }
          default: {
            const a = 'Token with "' + o.type + '" type was not found.';
            if (this.options.silent) return console.error(a), "";
            throw new Error(a);
          }
        }
      }
      return r;
    }
    parseInline(e, t = this.renderer) {
      let r = "";
      for (let i = 0; i < e.length; i++) {
        const s = e[i];
        if (this.options.extensions?.renderers?.[s.type]) {
          const a = this.options.extensions.renderers[s.type].call({
            parser: this
          }, s);
          if (a !== false || ![
            "escape",
            "html",
            "link",
            "image",
            "strong",
            "em",
            "codespan",
            "br",
            "del",
            "text"
          ].includes(s.type)) {
            r += a || "";
            continue;
          }
        }
        const o = s;
        switch (o.type) {
          case "escape": {
            r += t.text(o);
            break;
          }
          case "html": {
            r += t.html(o);
            break;
          }
          case "link": {
            r += t.link(o);
            break;
          }
          case "image": {
            r += t.image(o);
            break;
          }
          case "strong": {
            r += t.strong(o);
            break;
          }
          case "em": {
            r += t.em(o);
            break;
          }
          case "codespan": {
            r += t.codespan(o);
            break;
          }
          case "br": {
            r += t.br(o);
            break;
          }
          case "del": {
            r += t.del(o);
            break;
          }
          case "text": {
            r += t.text(o);
            break;
          }
          default: {
            const a = 'Token with "' + o.type + '" type was not found.';
            if (this.options.silent) return console.error(a), "";
            throw new Error(a);
          }
        }
      }
      return r;
    }
  }
  class Hs {
    options;
    block;
    constructor(e) {
      this.options = e || Hr;
    }
    static passThroughHooks = /* @__PURE__ */ new Set([
      "preprocess",
      "postprocess",
      "processAllTokens"
    ]);
    preprocess(e) {
      return e;
    }
    postprocess(e) {
      return e;
    }
    processAllTokens(e) {
      return e;
    }
    provideLexer() {
      return this.block ? Kt.lex : Kt.lexInline;
    }
    provideParser() {
      return this.block ? Jt.parse : Jt.parseInline;
    }
  }
  class Mk {
    defaults = Il();
    options = this.setOptions;
    parse = this.parseMarkdown(true);
    parseInline = this.parseMarkdown(false);
    Parser = Jt;
    Renderer = po;
    TextRenderer = ql;
    Lexer = Kt;
    Tokenizer = ho;
    Hooks = Hs;
    constructor(...e) {
      this.use(...e);
    }
    walkTokens(e, t) {
      let r = [];
      for (const i of e) switch (r = r.concat(t.call(this, i)), i.type) {
        case "table": {
          const s = i;
          for (const o of s.header) r = r.concat(this.walkTokens(o.tokens, t));
          for (const o of s.rows) for (const a of o) r = r.concat(this.walkTokens(a.tokens, t));
          break;
        }
        case "list": {
          const s = i;
          r = r.concat(this.walkTokens(s.items, t));
          break;
        }
        default: {
          const s = i;
          this.defaults.extensions?.childTokens?.[s.type] ? this.defaults.extensions.childTokens[s.type].forEach((o) => {
            const a = s[o].flat(1 / 0);
            r = r.concat(this.walkTokens(a, t));
          }) : s.tokens && (r = r.concat(this.walkTokens(s.tokens, t)));
        }
      }
      return r;
    }
    use(...e) {
      const t = this.defaults.extensions || {
        renderers: {},
        childTokens: {}
      };
      return e.forEach((r) => {
        const i = {
          ...r
        };
        if (i.async = this.defaults.async || i.async || false, r.extensions && (r.extensions.forEach((s) => {
          if (!s.name) throw new Error("extension name required");
          if ("renderer" in s) {
            const o = t.renderers[s.name];
            o ? t.renderers[s.name] = function(...a) {
              let u = s.renderer.apply(this, a);
              return u === false && (u = o.apply(this, a)), u;
            } : t.renderers[s.name] = s.renderer;
          }
          if ("tokenizer" in s) {
            if (!s.level || s.level !== "block" && s.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
            const o = t[s.level];
            o ? o.unshift(s.tokenizer) : t[s.level] = [
              s.tokenizer
            ], s.start && (s.level === "block" ? t.startBlock ? t.startBlock.push(s.start) : t.startBlock = [
              s.start
            ] : s.level === "inline" && (t.startInline ? t.startInline.push(s.start) : t.startInline = [
              s.start
            ]));
          }
          "childTokens" in s && s.childTokens && (t.childTokens[s.name] = s.childTokens);
        }), i.extensions = t), r.renderer) {
          const s = this.defaults.renderer || new po(this.defaults);
          for (const o in r.renderer) {
            if (!(o in s)) throw new Error(`renderer '${o}' does not exist`);
            if ([
              "options",
              "parser"
            ].includes(o)) continue;
            const a = o, u = r.renderer[a], l = s[a];
            s[a] = (...c) => {
              let h = u.apply(s, c);
              return h === false && (h = l.apply(s, c)), h || "";
            };
          }
          i.renderer = s;
        }
        if (r.tokenizer) {
          const s = this.defaults.tokenizer || new ho(this.defaults);
          for (const o in r.tokenizer) {
            if (!(o in s)) throw new Error(`tokenizer '${o}' does not exist`);
            if ([
              "options",
              "rules",
              "lexer"
            ].includes(o)) continue;
            const a = o, u = r.tokenizer[a], l = s[a];
            s[a] = (...c) => {
              let h = u.apply(s, c);
              return h === false && (h = l.apply(s, c)), h;
            };
          }
          i.tokenizer = s;
        }
        if (r.hooks) {
          const s = this.defaults.hooks || new Hs();
          for (const o in r.hooks) {
            if (!(o in s)) throw new Error(`hook '${o}' does not exist`);
            if ([
              "options",
              "block"
            ].includes(o)) continue;
            const a = o, u = r.hooks[a], l = s[a];
            Hs.passThroughHooks.has(o) ? s[a] = (c) => {
              if (this.defaults.async) return Promise.resolve(u.call(s, c)).then((d) => l.call(s, d));
              const h = u.call(s, c);
              return l.call(s, h);
            } : s[a] = (...c) => {
              let h = u.apply(s, c);
              return h === false && (h = l.apply(s, c)), h;
            };
          }
          i.hooks = s;
        }
        if (r.walkTokens) {
          const s = this.defaults.walkTokens, o = r.walkTokens;
          i.walkTokens = function(a) {
            let u = [];
            return u.push(o.call(this, a)), s && (u = u.concat(s.call(this, a))), u;
          };
        }
        this.defaults = {
          ...this.defaults,
          ...i
        };
      }), this;
    }
    setOptions(e) {
      return this.defaults = {
        ...this.defaults,
        ...e
      }, this;
    }
    lexer(e, t) {
      return Kt.lex(e, t ?? this.defaults);
    }
    parser(e, t) {
      return Jt.parse(e, t ?? this.defaults);
    }
    parseMarkdown(e) {
      return (r, i) => {
        const s = {
          ...i
        }, o = {
          ...this.defaults,
          ...s
        }, a = this.onError(!!o.silent, !!o.async);
        if (this.defaults.async === true && s.async === false) return a(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
        if (typeof r > "u" || r === null) return a(new Error("marked(): input parameter is undefined or null"));
        if (typeof r != "string") return a(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(r) + ", string expected"));
        o.hooks && (o.hooks.options = o, o.hooks.block = e);
        const u = o.hooks ? o.hooks.provideLexer() : e ? Kt.lex : Kt.lexInline, l = o.hooks ? o.hooks.provideParser() : e ? Jt.parse : Jt.parseInline;
        if (o.async) return Promise.resolve(o.hooks ? o.hooks.preprocess(r) : r).then((c) => u(c, o)).then((c) => o.hooks ? o.hooks.processAllTokens(c) : c).then((c) => o.walkTokens ? Promise.all(this.walkTokens(c, o.walkTokens)).then(() => c) : c).then((c) => l(c, o)).then((c) => o.hooks ? o.hooks.postprocess(c) : c).catch(a);
        try {
          o.hooks && (r = o.hooks.preprocess(r));
          let c = u(r, o);
          o.hooks && (c = o.hooks.processAllTokens(c)), o.walkTokens && this.walkTokens(c, o.walkTokens);
          let h = l(c, o);
          return o.hooks && (h = o.hooks.postprocess(h)), h;
        } catch (c) {
          return a(c);
        }
      };
    }
    onError(e, t) {
      return (r) => {
        if (r.message += `
Please report this to https://github.com/markedjs/marked.`, e) {
          const i = "<p>An error occurred:</p><pre>" + vn(r.message + "", true) + "</pre>";
          return t ? Promise.resolve(i) : i;
        }
        if (t) return Promise.reject(r);
        throw r;
      };
    }
  }
  const qr = new Mk();
  function Ye(n, e) {
    return qr.parse(n, e);
  }
  Ye.options = Ye.setOptions = function(n) {
    return qr.setOptions(n), Ye.defaults = qr.defaults, D0(Ye.defaults), Ye;
  };
  Ye.getDefaults = Il;
  Ye.defaults = Hr;
  Ye.use = function(...n) {
    return qr.use(...n), Ye.defaults = qr.defaults, D0(Ye.defaults), Ye;
  };
  Ye.walkTokens = function(n, e) {
    return qr.walkTokens(n, e);
  };
  Ye.parseInline = qr.parseInline;
  Ye.Parser = Jt;
  Ye.parser = Jt.parse;
  Ye.Renderer = po;
  Ye.TextRenderer = ql;
  Ye.Lexer = Kt;
  Ye.lexer = Kt.lex;
  Ye.Tokenizer = ho;
  Ye.Hooks = Hs;
  Ye.parse = Ye;
  Ye.options;
  Ye.setOptions;
  Ye.use;
  Ye.walkTokens;
  Ye.parseInline;
  Jt.parse;
  Kt.lex;
  var en = {}, tn = {}, Ma = {}, nn = {}, ws = {}, Dd;
  function Nk() {
    return Dd || (Dd = 1, Object.defineProperty(ws, "__esModule", {
      value: true
    }), ws.default = new Uint16Array('\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map(function(n) {
      return n.charCodeAt(0);
    }))), ws;
  }
  var xs = {}, Id;
  function Pk() {
    return Id || (Id = 1, Object.defineProperty(xs, "__esModule", {
      value: true
    }), xs.default = new Uint16Array("\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map(function(n) {
      return n.charCodeAt(0);
    }))), xs;
  }
  var Na = {}, Rd;
  function _d() {
    return Rd || (Rd = 1, function(n) {
      var e;
      Object.defineProperty(n, "__esModule", {
        value: true
      }), n.replaceCodePoint = n.fromCodePoint = void 0;
      var t = /* @__PURE__ */ new Map([
        [
          0,
          65533
        ],
        [
          128,
          8364
        ],
        [
          130,
          8218
        ],
        [
          131,
          402
        ],
        [
          132,
          8222
        ],
        [
          133,
          8230
        ],
        [
          134,
          8224
        ],
        [
          135,
          8225
        ],
        [
          136,
          710
        ],
        [
          137,
          8240
        ],
        [
          138,
          352
        ],
        [
          139,
          8249
        ],
        [
          140,
          338
        ],
        [
          142,
          381
        ],
        [
          145,
          8216
        ],
        [
          146,
          8217
        ],
        [
          147,
          8220
        ],
        [
          148,
          8221
        ],
        [
          149,
          8226
        ],
        [
          150,
          8211
        ],
        [
          151,
          8212
        ],
        [
          152,
          732
        ],
        [
          153,
          8482
        ],
        [
          154,
          353
        ],
        [
          155,
          8250
        ],
        [
          156,
          339
        ],
        [
          158,
          382
        ],
        [
          159,
          376
        ]
      ]);
      n.fromCodePoint = (e = String.fromCodePoint) !== null && e !== void 0 ? e : function(s) {
        var o = "";
        return s > 65535 && (s -= 65536, o += String.fromCharCode(s >>> 10 & 1023 | 55296), s = 56320 | s & 1023), o += String.fromCharCode(s), o;
      };
      function r(s) {
        var o;
        return s >= 55296 && s <= 57343 || s > 1114111 ? 65533 : (o = t.get(s)) !== null && o !== void 0 ? o : s;
      }
      n.replaceCodePoint = r;
      function i(s) {
        return (0, n.fromCodePoint)(r(s));
      }
      n.default = i;
    }(Na)), Na;
  }
  var Ld;
  function mo() {
    return Ld || (Ld = 1, function(n) {
      var e = nn && nn.__createBinding || (Object.create ? function(C, O, E, N) {
        N === void 0 && (N = E);
        var A = Object.getOwnPropertyDescriptor(O, E);
        (!A || ("get" in A ? !O.__esModule : A.writable || A.configurable)) && (A = {
          enumerable: true,
          get: function() {
            return O[E];
          }
        }), Object.defineProperty(C, N, A);
      } : function(C, O, E, N) {
        N === void 0 && (N = E), C[N] = O[E];
      }), t = nn && nn.__setModuleDefault || (Object.create ? function(C, O) {
        Object.defineProperty(C, "default", {
          enumerable: true,
          value: O
        });
      } : function(C, O) {
        C.default = O;
      }), r = nn && nn.__importStar || function(C) {
        if (C && C.__esModule) return C;
        var O = {};
        if (C != null) for (var E in C) E !== "default" && Object.prototype.hasOwnProperty.call(C, E) && e(O, C, E);
        return t(O, C), O;
      }, i = nn && nn.__importDefault || function(C) {
        return C && C.__esModule ? C : {
          default: C
        };
      };
      Object.defineProperty(n, "__esModule", {
        value: true
      }), n.decodeXML = n.decodeHTMLStrict = n.decodeHTMLAttribute = n.decodeHTML = n.determineBranch = n.EntityDecoder = n.DecodingMode = n.BinTrieFlags = n.fromCodePoint = n.replaceCodePoint = n.decodeCodePoint = n.xmlDecodeTree = n.htmlDecodeTree = void 0;
      var s = i(Nk());
      n.htmlDecodeTree = s.default;
      var o = i(Pk());
      n.xmlDecodeTree = o.default;
      var a = r(_d());
      n.decodeCodePoint = a.default;
      var u = _d();
      Object.defineProperty(n, "replaceCodePoint", {
        enumerable: true,
        get: function() {
          return u.replaceCodePoint;
        }
      }), Object.defineProperty(n, "fromCodePoint", {
        enumerable: true,
        get: function() {
          return u.fromCodePoint;
        }
      });
      var l;
      (function(C) {
        C[C.NUM = 35] = "NUM", C[C.SEMI = 59] = "SEMI", C[C.EQUALS = 61] = "EQUALS", C[C.ZERO = 48] = "ZERO", C[C.NINE = 57] = "NINE", C[C.LOWER_A = 97] = "LOWER_A", C[C.LOWER_F = 102] = "LOWER_F", C[C.LOWER_X = 120] = "LOWER_X", C[C.LOWER_Z = 122] = "LOWER_Z", C[C.UPPER_A = 65] = "UPPER_A", C[C.UPPER_F = 70] = "UPPER_F", C[C.UPPER_Z = 90] = "UPPER_Z";
      })(l || (l = {}));
      var c = 32, h;
      (function(C) {
        C[C.VALUE_LENGTH = 49152] = "VALUE_LENGTH", C[C.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", C[C.JUMP_TABLE = 127] = "JUMP_TABLE";
      })(h = n.BinTrieFlags || (n.BinTrieFlags = {}));
      function d(C) {
        return C >= l.ZERO && C <= l.NINE;
      }
      function f(C) {
        return C >= l.UPPER_A && C <= l.UPPER_F || C >= l.LOWER_A && C <= l.LOWER_F;
      }
      function p(C) {
        return C >= l.UPPER_A && C <= l.UPPER_Z || C >= l.LOWER_A && C <= l.LOWER_Z || d(C);
      }
      function m(C) {
        return C === l.EQUALS || p(C);
      }
      var b;
      (function(C) {
        C[C.EntityStart = 0] = "EntityStart", C[C.NumericStart = 1] = "NumericStart", C[C.NumericDecimal = 2] = "NumericDecimal", C[C.NumericHex = 3] = "NumericHex", C[C.NamedEntity = 4] = "NamedEntity";
      })(b || (b = {}));
      var g;
      (function(C) {
        C[C.Legacy = 0] = "Legacy", C[C.Strict = 1] = "Strict", C[C.Attribute = 2] = "Attribute";
      })(g = n.DecodingMode || (n.DecodingMode = {}));
      var w = function() {
        function C(O, E, N) {
          this.decodeTree = O, this.emitCodePoint = E, this.errors = N, this.state = b.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = g.Strict;
        }
        return C.prototype.startEntity = function(O) {
          this.decodeMode = O, this.state = b.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
        }, C.prototype.write = function(O, E) {
          switch (this.state) {
            case b.EntityStart:
              return O.charCodeAt(E) === l.NUM ? (this.state = b.NumericStart, this.consumed += 1, this.stateNumericStart(O, E + 1)) : (this.state = b.NamedEntity, this.stateNamedEntity(O, E));
            case b.NumericStart:
              return this.stateNumericStart(O, E);
            case b.NumericDecimal:
              return this.stateNumericDecimal(O, E);
            case b.NumericHex:
              return this.stateNumericHex(O, E);
            case b.NamedEntity:
              return this.stateNamedEntity(O, E);
          }
        }, C.prototype.stateNumericStart = function(O, E) {
          return E >= O.length ? -1 : (O.charCodeAt(E) | c) === l.LOWER_X ? (this.state = b.NumericHex, this.consumed += 1, this.stateNumericHex(O, E + 1)) : (this.state = b.NumericDecimal, this.stateNumericDecimal(O, E));
        }, C.prototype.addToNumericResult = function(O, E, N, A) {
          if (E !== N) {
            var R = N - E;
            this.result = this.result * Math.pow(A, R) + parseInt(O.substr(E, R), A), this.consumed += R;
          }
        }, C.prototype.stateNumericHex = function(O, E) {
          for (var N = E; E < O.length; ) {
            var A = O.charCodeAt(E);
            if (d(A) || f(A)) E += 1;
            else return this.addToNumericResult(O, N, E, 16), this.emitNumericEntity(A, 3);
          }
          return this.addToNumericResult(O, N, E, 16), -1;
        }, C.prototype.stateNumericDecimal = function(O, E) {
          for (var N = E; E < O.length; ) {
            var A = O.charCodeAt(E);
            if (d(A)) E += 1;
            else return this.addToNumericResult(O, N, E, 10), this.emitNumericEntity(A, 2);
          }
          return this.addToNumericResult(O, N, E, 10), -1;
        }, C.prototype.emitNumericEntity = function(O, E) {
          var N;
          if (this.consumed <= E) return (N = this.errors) === null || N === void 0 || N.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
          if (O === l.SEMI) this.consumed += 1;
          else if (this.decodeMode === g.Strict) return 0;
          return this.emitCodePoint((0, a.replaceCodePoint)(this.result), this.consumed), this.errors && (O !== l.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
        }, C.prototype.stateNamedEntity = function(O, E) {
          for (var N = this.decodeTree, A = N[this.treeIndex], R = (A & h.VALUE_LENGTH) >> 14; E < O.length; E++, this.excess++) {
            var B = O.charCodeAt(E);
            if (this.treeIndex = y(N, A, this.treeIndex + Math.max(1, R), B), this.treeIndex < 0) return this.result === 0 || this.decodeMode === g.Attribute && (R === 0 || m(B)) ? 0 : this.emitNotTerminatedNamedEntity();
            if (A = N[this.treeIndex], R = (A & h.VALUE_LENGTH) >> 14, R !== 0) {
              if (B === l.SEMI) return this.emitNamedEntityData(this.treeIndex, R, this.consumed + this.excess);
              this.decodeMode !== g.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
            }
          }
          return -1;
        }, C.prototype.emitNotTerminatedNamedEntity = function() {
          var O, E = this, N = E.result, A = E.decodeTree, R = (A[N] & h.VALUE_LENGTH) >> 14;
          return this.emitNamedEntityData(N, R, this.consumed), (O = this.errors) === null || O === void 0 || O.missingSemicolonAfterCharacterReference(), this.consumed;
        }, C.prototype.emitNamedEntityData = function(O, E, N) {
          var A = this.decodeTree;
          return this.emitCodePoint(E === 1 ? A[O] & ~h.VALUE_LENGTH : A[O + 1], N), E === 3 && this.emitCodePoint(A[O + 2], N), N;
        }, C.prototype.end = function() {
          var O;
          switch (this.state) {
            case b.NamedEntity:
              return this.result !== 0 && (this.decodeMode !== g.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
            case b.NumericDecimal:
              return this.emitNumericEntity(0, 2);
            case b.NumericHex:
              return this.emitNumericEntity(0, 3);
            case b.NumericStart:
              return (O = this.errors) === null || O === void 0 || O.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
            case b.EntityStart:
              return 0;
          }
        }, C;
      }();
      n.EntityDecoder = w;
      function v(C) {
        var O = "", E = new w(C, function(N) {
          return O += (0, a.fromCodePoint)(N);
        });
        return function(A, R) {
          for (var B = 0, z = 0; (z = A.indexOf("&", z)) >= 0; ) {
            O += A.slice(B, z), E.startEntity(R);
            var L = E.write(A, z + 1);
            if (L < 0) {
              B = z + E.end();
              break;
            }
            B = z + L, z = L === 0 ? B + 1 : B;
          }
          var V = O + A.slice(B);
          return O = "", V;
        };
      }
      function y(C, O, E, N) {
        var A = (O & h.BRANCH_LENGTH) >> 7, R = O & h.JUMP_TABLE;
        if (A === 0) return R !== 0 && N === R ? E : -1;
        if (R) {
          var B = N - R;
          return B < 0 || B >= A ? -1 : C[E + B] - 1;
        }
        for (var z = E, L = z + A - 1; z <= L; ) {
          var V = z + L >>> 1, K = C[V];
          if (K < N) z = V + 1;
          else if (K > N) L = V - 1;
          else return C[V + A];
        }
        return -1;
      }
      n.determineBranch = y;
      var x = v(s.default), k = v(o.default);
      function T(C, O) {
        return O === void 0 && (O = g.Legacy), x(C, O);
      }
      n.decodeHTML = T;
      function M(C) {
        return x(C, g.Attribute);
      }
      n.decodeHTMLAttribute = M;
      function D(C) {
        return x(C, g.Strict);
      }
      n.decodeHTMLStrict = D;
      function I(C) {
        return k(C, g.Strict);
      }
      n.decodeXML = I;
    }(nn)), nn;
  }
  var Bd;
  function V0() {
    return Bd || (Bd = 1, function(n) {
      Object.defineProperty(n, "__esModule", {
        value: true
      }), n.QuoteType = void 0;
      var e = mo(), t;
      (function(d) {
        d[d.Tab = 9] = "Tab", d[d.NewLine = 10] = "NewLine", d[d.FormFeed = 12] = "FormFeed", d[d.CarriageReturn = 13] = "CarriageReturn", d[d.Space = 32] = "Space", d[d.ExclamationMark = 33] = "ExclamationMark", d[d.Number = 35] = "Number", d[d.Amp = 38] = "Amp", d[d.SingleQuote = 39] = "SingleQuote", d[d.DoubleQuote = 34] = "DoubleQuote", d[d.Dash = 45] = "Dash", d[d.Slash = 47] = "Slash", d[d.Zero = 48] = "Zero", d[d.Nine = 57] = "Nine", d[d.Semi = 59] = "Semi", d[d.Lt = 60] = "Lt", d[d.Eq = 61] = "Eq", d[d.Gt = 62] = "Gt", d[d.Questionmark = 63] = "Questionmark", d[d.UpperA = 65] = "UpperA", d[d.LowerA = 97] = "LowerA", d[d.UpperF = 70] = "UpperF", d[d.LowerF = 102] = "LowerF", d[d.UpperZ = 90] = "UpperZ", d[d.LowerZ = 122] = "LowerZ", d[d.LowerX = 120] = "LowerX", d[d.OpeningSquareBracket = 91] = "OpeningSquareBracket";
      })(t || (t = {}));
      var r;
      (function(d) {
        d[d.Text = 1] = "Text", d[d.BeforeTagName = 2] = "BeforeTagName", d[d.InTagName = 3] = "InTagName", d[d.InSelfClosingTag = 4] = "InSelfClosingTag", d[d.BeforeClosingTagName = 5] = "BeforeClosingTagName", d[d.InClosingTagName = 6] = "InClosingTagName", d[d.AfterClosingTagName = 7] = "AfterClosingTagName", d[d.BeforeAttributeName = 8] = "BeforeAttributeName", d[d.InAttributeName = 9] = "InAttributeName", d[d.AfterAttributeName = 10] = "AfterAttributeName", d[d.BeforeAttributeValue = 11] = "BeforeAttributeValue", d[d.InAttributeValueDq = 12] = "InAttributeValueDq", d[d.InAttributeValueSq = 13] = "InAttributeValueSq", d[d.InAttributeValueNq = 14] = "InAttributeValueNq", d[d.BeforeDeclaration = 15] = "BeforeDeclaration", d[d.InDeclaration = 16] = "InDeclaration", d[d.InProcessingInstruction = 17] = "InProcessingInstruction", d[d.BeforeComment = 18] = "BeforeComment", d[d.CDATASequence = 19] = "CDATASequence", d[d.InSpecialComment = 20] = "InSpecialComment", d[d.InCommentLike = 21] = "InCommentLike", d[d.BeforeSpecialS = 22] = "BeforeSpecialS", d[d.SpecialStartSequence = 23] = "SpecialStartSequence", d[d.InSpecialTag = 24] = "InSpecialTag", d[d.BeforeEntity = 25] = "BeforeEntity", d[d.BeforeNumericEntity = 26] = "BeforeNumericEntity", d[d.InNamedEntity = 27] = "InNamedEntity", d[d.InNumericEntity = 28] = "InNumericEntity", d[d.InHexEntity = 29] = "InHexEntity";
      })(r || (r = {}));
      function i(d) {
        return d === t.Space || d === t.NewLine || d === t.Tab || d === t.FormFeed || d === t.CarriageReturn;
      }
      function s(d) {
        return d === t.Slash || d === t.Gt || i(d);
      }
      function o(d) {
        return d >= t.Zero && d <= t.Nine;
      }
      function a(d) {
        return d >= t.LowerA && d <= t.LowerZ || d >= t.UpperA && d <= t.UpperZ;
      }
      function u(d) {
        return d >= t.UpperA && d <= t.UpperF || d >= t.LowerA && d <= t.LowerF;
      }
      var l;
      (function(d) {
        d[d.NoValue = 0] = "NoValue", d[d.Unquoted = 1] = "Unquoted", d[d.Single = 2] = "Single", d[d.Double = 3] = "Double";
      })(l = n.QuoteType || (n.QuoteType = {}));
      var c = {
        Cdata: new Uint8Array([
          67,
          68,
          65,
          84,
          65,
          91
        ]),
        CdataEnd: new Uint8Array([
          93,
          93,
          62
        ]),
        CommentEnd: new Uint8Array([
          45,
          45,
          62
        ]),
        ScriptEnd: new Uint8Array([
          60,
          47,
          115,
          99,
          114,
          105,
          112,
          116
        ]),
        StyleEnd: new Uint8Array([
          60,
          47,
          115,
          116,
          121,
          108,
          101
        ]),
        TitleEnd: new Uint8Array([
          60,
          47,
          116,
          105,
          116,
          108,
          101
        ])
      }, h = function() {
        function d(f, p) {
          var m = f.xmlMode, b = m === void 0 ? false : m, g = f.decodeEntities, w = g === void 0 ? true : g;
          this.cbs = p, this.state = r.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = r.Text, this.isSpecial = false, this.running = true, this.offset = 0, this.currentSequence = void 0, this.sequenceIndex = 0, this.trieIndex = 0, this.trieCurrent = 0, this.entityResult = 0, this.entityExcess = 0, this.xmlMode = b, this.decodeEntities = w, this.entityTrie = b ? e.xmlDecodeTree : e.htmlDecodeTree;
        }
        return d.prototype.reset = function() {
          this.state = r.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = r.Text, this.currentSequence = void 0, this.running = true, this.offset = 0;
        }, d.prototype.write = function(f) {
          this.offset += this.buffer.length, this.buffer = f, this.parse();
        }, d.prototype.end = function() {
          this.running && this.finish();
        }, d.prototype.pause = function() {
          this.running = false;
        }, d.prototype.resume = function() {
          this.running = true, this.index < this.buffer.length + this.offset && this.parse();
        }, d.prototype.getIndex = function() {
          return this.index;
        }, d.prototype.getSectionStart = function() {
          return this.sectionStart;
        }, d.prototype.stateText = function(f) {
          f === t.Lt || !this.decodeEntities && this.fastForwardTo(t.Lt) ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = r.BeforeTagName, this.sectionStart = this.index) : this.decodeEntities && f === t.Amp && (this.state = r.BeforeEntity);
        }, d.prototype.stateSpecialStartSequence = function(f) {
          var p = this.sequenceIndex === this.currentSequence.length, m = p ? s(f) : (f | 32) === this.currentSequence[this.sequenceIndex];
          if (!m) this.isSpecial = false;
          else if (!p) {
            this.sequenceIndex++;
            return;
          }
          this.sequenceIndex = 0, this.state = r.InTagName, this.stateInTagName(f);
        }, d.prototype.stateInSpecialTag = function(f) {
          if (this.sequenceIndex === this.currentSequence.length) {
            if (f === t.Gt || i(f)) {
              var p = this.index - this.currentSequence.length;
              if (this.sectionStart < p) {
                var m = this.index;
                this.index = p, this.cbs.ontext(this.sectionStart, p), this.index = m;
              }
              this.isSpecial = false, this.sectionStart = p + 2, this.stateInClosingTagName(f);
              return;
            }
            this.sequenceIndex = 0;
          }
          (f | 32) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : this.sequenceIndex === 0 ? this.currentSequence === c.TitleEnd ? this.decodeEntities && f === t.Amp && (this.state = r.BeforeEntity) : this.fastForwardTo(t.Lt) && (this.sequenceIndex = 1) : this.sequenceIndex = +(f === t.Lt);
        }, d.prototype.stateCDATASequence = function(f) {
          f === c.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === c.Cdata.length && (this.state = r.InCommentLike, this.currentSequence = c.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = r.InDeclaration, this.stateInDeclaration(f));
        }, d.prototype.fastForwardTo = function(f) {
          for (; ++this.index < this.buffer.length + this.offset; ) if (this.buffer.charCodeAt(this.index - this.offset) === f) return true;
          return this.index = this.buffer.length + this.offset - 1, false;
        }, d.prototype.stateInCommentLike = function(f) {
          f === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === c.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index, 2) : this.cbs.oncomment(this.sectionStart, this.index, 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = r.Text) : this.sequenceIndex === 0 ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : f !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
        }, d.prototype.isTagStartChar = function(f) {
          return this.xmlMode ? !s(f) : a(f);
        }, d.prototype.startSpecial = function(f, p) {
          this.isSpecial = true, this.currentSequence = f, this.sequenceIndex = p, this.state = r.SpecialStartSequence;
        }, d.prototype.stateBeforeTagName = function(f) {
          if (f === t.ExclamationMark) this.state = r.BeforeDeclaration, this.sectionStart = this.index + 1;
          else if (f === t.Questionmark) this.state = r.InProcessingInstruction, this.sectionStart = this.index + 1;
          else if (this.isTagStartChar(f)) {
            var p = f | 32;
            this.sectionStart = this.index, !this.xmlMode && p === c.TitleEnd[2] ? this.startSpecial(c.TitleEnd, 3) : this.state = !this.xmlMode && p === c.ScriptEnd[2] ? r.BeforeSpecialS : r.InTagName;
          } else f === t.Slash ? this.state = r.BeforeClosingTagName : (this.state = r.Text, this.stateText(f));
        }, d.prototype.stateInTagName = function(f) {
          s(f) && (this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = r.BeforeAttributeName, this.stateBeforeAttributeName(f));
        }, d.prototype.stateBeforeClosingTagName = function(f) {
          i(f) || (f === t.Gt ? this.state = r.Text : (this.state = this.isTagStartChar(f) ? r.InClosingTagName : r.InSpecialComment, this.sectionStart = this.index));
        }, d.prototype.stateInClosingTagName = function(f) {
          (f === t.Gt || i(f)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = r.AfterClosingTagName, this.stateAfterClosingTagName(f));
        }, d.prototype.stateAfterClosingTagName = function(f) {
          (f === t.Gt || this.fastForwardTo(t.Gt)) && (this.state = r.Text, this.baseState = r.Text, this.sectionStart = this.index + 1);
        }, d.prototype.stateBeforeAttributeName = function(f) {
          f === t.Gt ? (this.cbs.onopentagend(this.index), this.isSpecial ? (this.state = r.InSpecialTag, this.sequenceIndex = 0) : this.state = r.Text, this.baseState = this.state, this.sectionStart = this.index + 1) : f === t.Slash ? this.state = r.InSelfClosingTag : i(f) || (this.state = r.InAttributeName, this.sectionStart = this.index);
        }, d.prototype.stateInSelfClosingTag = function(f) {
          f === t.Gt ? (this.cbs.onselfclosingtag(this.index), this.state = r.Text, this.baseState = r.Text, this.sectionStart = this.index + 1, this.isSpecial = false) : i(f) || (this.state = r.BeforeAttributeName, this.stateBeforeAttributeName(f));
        }, d.prototype.stateInAttributeName = function(f) {
          (f === t.Eq || s(f)) && (this.cbs.onattribname(this.sectionStart, this.index), this.sectionStart = -1, this.state = r.AfterAttributeName, this.stateAfterAttributeName(f));
        }, d.prototype.stateAfterAttributeName = function(f) {
          f === t.Eq ? this.state = r.BeforeAttributeValue : f === t.Slash || f === t.Gt ? (this.cbs.onattribend(l.NoValue, this.index), this.state = r.BeforeAttributeName, this.stateBeforeAttributeName(f)) : i(f) || (this.cbs.onattribend(l.NoValue, this.index), this.state = r.InAttributeName, this.sectionStart = this.index);
        }, d.prototype.stateBeforeAttributeValue = function(f) {
          f === t.DoubleQuote ? (this.state = r.InAttributeValueDq, this.sectionStart = this.index + 1) : f === t.SingleQuote ? (this.state = r.InAttributeValueSq, this.sectionStart = this.index + 1) : i(f) || (this.sectionStart = this.index, this.state = r.InAttributeValueNq, this.stateInAttributeValueNoQuotes(f));
        }, d.prototype.handleInAttributeValue = function(f, p) {
          f === p || !this.decodeEntities && this.fastForwardTo(p) ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(p === t.DoubleQuote ? l.Double : l.Single, this.index), this.state = r.BeforeAttributeName) : this.decodeEntities && f === t.Amp && (this.baseState = this.state, this.state = r.BeforeEntity);
        }, d.prototype.stateInAttributeValueDoubleQuotes = function(f) {
          this.handleInAttributeValue(f, t.DoubleQuote);
        }, d.prototype.stateInAttributeValueSingleQuotes = function(f) {
          this.handleInAttributeValue(f, t.SingleQuote);
        }, d.prototype.stateInAttributeValueNoQuotes = function(f) {
          i(f) || f === t.Gt ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(l.Unquoted, this.index), this.state = r.BeforeAttributeName, this.stateBeforeAttributeName(f)) : this.decodeEntities && f === t.Amp && (this.baseState = this.state, this.state = r.BeforeEntity);
        }, d.prototype.stateBeforeDeclaration = function(f) {
          f === t.OpeningSquareBracket ? (this.state = r.CDATASequence, this.sequenceIndex = 0) : this.state = f === t.Dash ? r.BeforeComment : r.InDeclaration;
        }, d.prototype.stateInDeclaration = function(f) {
          (f === t.Gt || this.fastForwardTo(t.Gt)) && (this.cbs.ondeclaration(this.sectionStart, this.index), this.state = r.Text, this.sectionStart = this.index + 1);
        }, d.prototype.stateInProcessingInstruction = function(f) {
          (f === t.Gt || this.fastForwardTo(t.Gt)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = r.Text, this.sectionStart = this.index + 1);
        }, d.prototype.stateBeforeComment = function(f) {
          f === t.Dash ? (this.state = r.InCommentLike, this.currentSequence = c.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = r.InDeclaration;
        }, d.prototype.stateInSpecialComment = function(f) {
          (f === t.Gt || this.fastForwardTo(t.Gt)) && (this.cbs.oncomment(this.sectionStart, this.index, 0), this.state = r.Text, this.sectionStart = this.index + 1);
        }, d.prototype.stateBeforeSpecialS = function(f) {
          var p = f | 32;
          p === c.ScriptEnd[3] ? this.startSpecial(c.ScriptEnd, 4) : p === c.StyleEnd[3] ? this.startSpecial(c.StyleEnd, 4) : (this.state = r.InTagName, this.stateInTagName(f));
        }, d.prototype.stateBeforeEntity = function(f) {
          this.entityExcess = 1, this.entityResult = 0, f === t.Number ? this.state = r.BeforeNumericEntity : f === t.Amp || (this.trieIndex = 0, this.trieCurrent = this.entityTrie[0], this.state = r.InNamedEntity, this.stateInNamedEntity(f));
        }, d.prototype.stateInNamedEntity = function(f) {
          if (this.entityExcess += 1, this.trieIndex = (0, e.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, f), this.trieIndex < 0) {
            this.emitNamedEntity(), this.index--;
            return;
          }
          this.trieCurrent = this.entityTrie[this.trieIndex];
          var p = this.trieCurrent & e.BinTrieFlags.VALUE_LENGTH;
          if (p) {
            var m = (p >> 14) - 1;
            if (!this.allowLegacyEntity() && f !== t.Semi) this.trieIndex += m;
            else {
              var b = this.index - this.entityExcess + 1;
              b > this.sectionStart && this.emitPartial(this.sectionStart, b), this.entityResult = this.trieIndex, this.trieIndex += m, this.entityExcess = 0, this.sectionStart = this.index + 1, m === 0 && this.emitNamedEntity();
            }
          }
        }, d.prototype.emitNamedEntity = function() {
          if (this.state = this.baseState, this.entityResult !== 0) {
            var f = (this.entityTrie[this.entityResult] & e.BinTrieFlags.VALUE_LENGTH) >> 14;
            switch (f) {
              case 1: {
                this.emitCodePoint(this.entityTrie[this.entityResult] & ~e.BinTrieFlags.VALUE_LENGTH);
                break;
              }
              case 2: {
                this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
                break;
              }
              case 3:
                this.emitCodePoint(this.entityTrie[this.entityResult + 1]), this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
            }
          }
        }, d.prototype.stateBeforeNumericEntity = function(f) {
          (f | 32) === t.LowerX ? (this.entityExcess++, this.state = r.InHexEntity) : (this.state = r.InNumericEntity, this.stateInNumericEntity(f));
        }, d.prototype.emitNumericEntity = function(f) {
          var p = this.index - this.entityExcess - 1, m = p + 2 + +(this.state === r.InHexEntity);
          m !== this.index && (p > this.sectionStart && this.emitPartial(this.sectionStart, p), this.sectionStart = this.index + Number(f), this.emitCodePoint((0, e.replaceCodePoint)(this.entityResult))), this.state = this.baseState;
        }, d.prototype.stateInNumericEntity = function(f) {
          f === t.Semi ? this.emitNumericEntity(true) : o(f) ? (this.entityResult = this.entityResult * 10 + (f - t.Zero), this.entityExcess++) : (this.allowLegacyEntity() ? this.emitNumericEntity(false) : this.state = this.baseState, this.index--);
        }, d.prototype.stateInHexEntity = function(f) {
          f === t.Semi ? this.emitNumericEntity(true) : o(f) ? (this.entityResult = this.entityResult * 16 + (f - t.Zero), this.entityExcess++) : u(f) ? (this.entityResult = this.entityResult * 16 + ((f | 32) - t.LowerA + 10), this.entityExcess++) : (this.allowLegacyEntity() ? this.emitNumericEntity(false) : this.state = this.baseState, this.index--);
        }, d.prototype.allowLegacyEntity = function() {
          return !this.xmlMode && (this.baseState === r.Text || this.baseState === r.InSpecialTag);
        }, d.prototype.cleanup = function() {
          this.running && this.sectionStart !== this.index && (this.state === r.Text || this.state === r.InSpecialTag && this.sequenceIndex === 0 ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : (this.state === r.InAttributeValueDq || this.state === r.InAttributeValueSq || this.state === r.InAttributeValueNq) && (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index));
        }, d.prototype.shouldContinue = function() {
          return this.index < this.buffer.length + this.offset && this.running;
        }, d.prototype.parse = function() {
          for (; this.shouldContinue(); ) {
            var f = this.buffer.charCodeAt(this.index - this.offset);
            switch (this.state) {
              case r.Text: {
                this.stateText(f);
                break;
              }
              case r.SpecialStartSequence: {
                this.stateSpecialStartSequence(f);
                break;
              }
              case r.InSpecialTag: {
                this.stateInSpecialTag(f);
                break;
              }
              case r.CDATASequence: {
                this.stateCDATASequence(f);
                break;
              }
              case r.InAttributeValueDq: {
                this.stateInAttributeValueDoubleQuotes(f);
                break;
              }
              case r.InAttributeName: {
                this.stateInAttributeName(f);
                break;
              }
              case r.InCommentLike: {
                this.stateInCommentLike(f);
                break;
              }
              case r.InSpecialComment: {
                this.stateInSpecialComment(f);
                break;
              }
              case r.BeforeAttributeName: {
                this.stateBeforeAttributeName(f);
                break;
              }
              case r.InTagName: {
                this.stateInTagName(f);
                break;
              }
              case r.InClosingTagName: {
                this.stateInClosingTagName(f);
                break;
              }
              case r.BeforeTagName: {
                this.stateBeforeTagName(f);
                break;
              }
              case r.AfterAttributeName: {
                this.stateAfterAttributeName(f);
                break;
              }
              case r.InAttributeValueSq: {
                this.stateInAttributeValueSingleQuotes(f);
                break;
              }
              case r.BeforeAttributeValue: {
                this.stateBeforeAttributeValue(f);
                break;
              }
              case r.BeforeClosingTagName: {
                this.stateBeforeClosingTagName(f);
                break;
              }
              case r.AfterClosingTagName: {
                this.stateAfterClosingTagName(f);
                break;
              }
              case r.BeforeSpecialS: {
                this.stateBeforeSpecialS(f);
                break;
              }
              case r.InAttributeValueNq: {
                this.stateInAttributeValueNoQuotes(f);
                break;
              }
              case r.InSelfClosingTag: {
                this.stateInSelfClosingTag(f);
                break;
              }
              case r.InDeclaration: {
                this.stateInDeclaration(f);
                break;
              }
              case r.BeforeDeclaration: {
                this.stateBeforeDeclaration(f);
                break;
              }
              case r.BeforeComment: {
                this.stateBeforeComment(f);
                break;
              }
              case r.InProcessingInstruction: {
                this.stateInProcessingInstruction(f);
                break;
              }
              case r.InNamedEntity: {
                this.stateInNamedEntity(f);
                break;
              }
              case r.BeforeEntity: {
                this.stateBeforeEntity(f);
                break;
              }
              case r.InHexEntity: {
                this.stateInHexEntity(f);
                break;
              }
              case r.InNumericEntity: {
                this.stateInNumericEntity(f);
                break;
              }
              default:
                this.stateBeforeNumericEntity(f);
            }
            this.index++;
          }
          this.cleanup();
        }, d.prototype.finish = function() {
          this.state === r.InNamedEntity && this.emitNamedEntity(), this.sectionStart < this.index && this.handleTrailingData(), this.cbs.onend();
        }, d.prototype.handleTrailingData = function() {
          var f = this.buffer.length + this.offset;
          this.state === r.InCommentLike ? this.currentSequence === c.CdataEnd ? this.cbs.oncdata(this.sectionStart, f, 0) : this.cbs.oncomment(this.sectionStart, f, 0) : this.state === r.InNumericEntity && this.allowLegacyEntity() ? this.emitNumericEntity(false) : this.state === r.InHexEntity && this.allowLegacyEntity() ? this.emitNumericEntity(false) : this.state === r.InTagName || this.state === r.BeforeAttributeName || this.state === r.BeforeAttributeValue || this.state === r.AfterAttributeName || this.state === r.InAttributeName || this.state === r.InAttributeValueSq || this.state === r.InAttributeValueDq || this.state === r.InAttributeValueNq || this.state === r.InClosingTagName || this.cbs.ontext(this.sectionStart, f);
        }, d.prototype.emitPartial = function(f, p) {
          this.baseState !== r.Text && this.baseState !== r.InSpecialTag ? this.cbs.onattribdata(f, p) : this.cbs.ontext(f, p);
        }, d.prototype.emitCodePoint = function(f) {
          this.baseState !== r.Text && this.baseState !== r.InSpecialTag ? this.cbs.onattribentity(f) : this.cbs.ontextentity(f);
        }, d;
      }();
      n.default = h;
    }(Ma)), Ma;
  }
  var Fd;
  function zd() {
    if (Fd) return tn;
    Fd = 1;
    var n = tn && tn.__createBinding || (Object.create ? function(b, g, w, v) {
      v === void 0 && (v = w);
      var y = Object.getOwnPropertyDescriptor(g, w);
      (!y || ("get" in y ? !g.__esModule : y.writable || y.configurable)) && (y = {
        enumerable: true,
        get: function() {
          return g[w];
        }
      }), Object.defineProperty(b, v, y);
    } : function(b, g, w, v) {
      v === void 0 && (v = w), b[v] = g[w];
    }), e = tn && tn.__setModuleDefault || (Object.create ? function(b, g) {
      Object.defineProperty(b, "default", {
        enumerable: true,
        value: g
      });
    } : function(b, g) {
      b.default = g;
    }), t = tn && tn.__importStar || function(b) {
      if (b && b.__esModule) return b;
      var g = {};
      if (b != null) for (var w in b) w !== "default" && Object.prototype.hasOwnProperty.call(b, w) && n(g, b, w);
      return e(g, b), g;
    };
    Object.defineProperty(tn, "__esModule", {
      value: true
    }), tn.Parser = void 0;
    var r = t(V0()), i = mo(), s = /* @__PURE__ */ new Set([
      "input",
      "option",
      "optgroup",
      "select",
      "button",
      "datalist",
      "textarea"
    ]), o = /* @__PURE__ */ new Set([
      "p"
    ]), a = /* @__PURE__ */ new Set([
      "thead",
      "tbody"
    ]), u = /* @__PURE__ */ new Set([
      "dd",
      "dt"
    ]), l = /* @__PURE__ */ new Set([
      "rt",
      "rp"
    ]), c = /* @__PURE__ */ new Map([
      [
        "tr",
        /* @__PURE__ */ new Set([
          "tr",
          "th",
          "td"
        ])
      ],
      [
        "th",
        /* @__PURE__ */ new Set([
          "th"
        ])
      ],
      [
        "td",
        /* @__PURE__ */ new Set([
          "thead",
          "th",
          "td"
        ])
      ],
      [
        "body",
        /* @__PURE__ */ new Set([
          "head",
          "link",
          "script"
        ])
      ],
      [
        "li",
        /* @__PURE__ */ new Set([
          "li"
        ])
      ],
      [
        "p",
        o
      ],
      [
        "h1",
        o
      ],
      [
        "h2",
        o
      ],
      [
        "h3",
        o
      ],
      [
        "h4",
        o
      ],
      [
        "h5",
        o
      ],
      [
        "h6",
        o
      ],
      [
        "select",
        s
      ],
      [
        "input",
        s
      ],
      [
        "output",
        s
      ],
      [
        "button",
        s
      ],
      [
        "datalist",
        s
      ],
      [
        "textarea",
        s
      ],
      [
        "option",
        /* @__PURE__ */ new Set([
          "option"
        ])
      ],
      [
        "optgroup",
        /* @__PURE__ */ new Set([
          "optgroup",
          "option"
        ])
      ],
      [
        "dd",
        u
      ],
      [
        "dt",
        u
      ],
      [
        "address",
        o
      ],
      [
        "article",
        o
      ],
      [
        "aside",
        o
      ],
      [
        "blockquote",
        o
      ],
      [
        "details",
        o
      ],
      [
        "div",
        o
      ],
      [
        "dl",
        o
      ],
      [
        "fieldset",
        o
      ],
      [
        "figcaption",
        o
      ],
      [
        "figure",
        o
      ],
      [
        "footer",
        o
      ],
      [
        "form",
        o
      ],
      [
        "header",
        o
      ],
      [
        "hr",
        o
      ],
      [
        "main",
        o
      ],
      [
        "nav",
        o
      ],
      [
        "ol",
        o
      ],
      [
        "pre",
        o
      ],
      [
        "section",
        o
      ],
      [
        "table",
        o
      ],
      [
        "ul",
        o
      ],
      [
        "rt",
        l
      ],
      [
        "rp",
        l
      ],
      [
        "tbody",
        a
      ],
      [
        "tfoot",
        a
      ]
    ]), h = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]), d = /* @__PURE__ */ new Set([
      "math",
      "svg"
    ]), f = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignobject",
      "desc",
      "title"
    ]), p = /\s|\//, m = function() {
      function b(g, w) {
        w === void 0 && (w = {});
        var v, y, x, k, T;
        this.options = w, this.startIndex = 0, this.endIndex = 0, this.openTagStart = 0, this.tagname = "", this.attribname = "", this.attribvalue = "", this.attribs = null, this.stack = [], this.foreignContext = [], this.buffers = [], this.bufferOffset = 0, this.writeIndex = 0, this.ended = false, this.cbs = g ?? {}, this.lowerCaseTagNames = (v = w.lowerCaseTags) !== null && v !== void 0 ? v : !w.xmlMode, this.lowerCaseAttributeNames = (y = w.lowerCaseAttributeNames) !== null && y !== void 0 ? y : !w.xmlMode, this.tokenizer = new ((x = w.Tokenizer) !== null && x !== void 0 ? x : r.default)(this.options, this), (T = (k = this.cbs).onparserinit) === null || T === void 0 || T.call(k, this);
      }
      return b.prototype.ontext = function(g, w) {
        var v, y, x = this.getSlice(g, w);
        this.endIndex = w - 1, (y = (v = this.cbs).ontext) === null || y === void 0 || y.call(v, x), this.startIndex = w;
      }, b.prototype.ontextentity = function(g) {
        var w, v, y = this.tokenizer.getSectionStart();
        this.endIndex = y - 1, (v = (w = this.cbs).ontext) === null || v === void 0 || v.call(w, (0, i.fromCodePoint)(g)), this.startIndex = y;
      }, b.prototype.isVoidElement = function(g) {
        return !this.options.xmlMode && h.has(g);
      }, b.prototype.onopentagname = function(g, w) {
        this.endIndex = w;
        var v = this.getSlice(g, w);
        this.lowerCaseTagNames && (v = v.toLowerCase()), this.emitOpenTag(v);
      }, b.prototype.emitOpenTag = function(g) {
        var w, v, y, x;
        this.openTagStart = this.startIndex, this.tagname = g;
        var k = !this.options.xmlMode && c.get(g);
        if (k) for (; this.stack.length > 0 && k.has(this.stack[this.stack.length - 1]); ) {
          var T = this.stack.pop();
          (v = (w = this.cbs).onclosetag) === null || v === void 0 || v.call(w, T, true);
        }
        this.isVoidElement(g) || (this.stack.push(g), d.has(g) ? this.foreignContext.push(true) : f.has(g) && this.foreignContext.push(false)), (x = (y = this.cbs).onopentagname) === null || x === void 0 || x.call(y, g), this.cbs.onopentag && (this.attribs = {});
      }, b.prototype.endOpenTag = function(g) {
        var w, v;
        this.startIndex = this.openTagStart, this.attribs && ((v = (w = this.cbs).onopentag) === null || v === void 0 || v.call(w, this.tagname, this.attribs, g), this.attribs = null), this.cbs.onclosetag && this.isVoidElement(this.tagname) && this.cbs.onclosetag(this.tagname, true), this.tagname = "";
      }, b.prototype.onopentagend = function(g) {
        this.endIndex = g, this.endOpenTag(false), this.startIndex = g + 1;
      }, b.prototype.onclosetag = function(g, w) {
        var v, y, x, k, T, M;
        this.endIndex = w;
        var D = this.getSlice(g, w);
        if (this.lowerCaseTagNames && (D = D.toLowerCase()), (d.has(D) || f.has(D)) && this.foreignContext.pop(), this.isVoidElement(D)) !this.options.xmlMode && D === "br" && ((y = (v = this.cbs).onopentagname) === null || y === void 0 || y.call(v, "br"), (k = (x = this.cbs).onopentag) === null || k === void 0 || k.call(x, "br", {}, true), (M = (T = this.cbs).onclosetag) === null || M === void 0 || M.call(T, "br", false));
        else {
          var I = this.stack.lastIndexOf(D);
          if (I !== -1) if (this.cbs.onclosetag) for (var C = this.stack.length - I; C--; ) this.cbs.onclosetag(this.stack.pop(), C !== 0);
          else this.stack.length = I;
          else !this.options.xmlMode && D === "p" && (this.emitOpenTag("p"), this.closeCurrentTag(true));
        }
        this.startIndex = w + 1;
      }, b.prototype.onselfclosingtag = function(g) {
        this.endIndex = g, this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1] ? (this.closeCurrentTag(false), this.startIndex = g + 1) : this.onopentagend(g);
      }, b.prototype.closeCurrentTag = function(g) {
        var w, v, y = this.tagname;
        this.endOpenTag(g), this.stack[this.stack.length - 1] === y && ((v = (w = this.cbs).onclosetag) === null || v === void 0 || v.call(w, y, !g), this.stack.pop());
      }, b.prototype.onattribname = function(g, w) {
        this.startIndex = g;
        var v = this.getSlice(g, w);
        this.attribname = this.lowerCaseAttributeNames ? v.toLowerCase() : v;
      }, b.prototype.onattribdata = function(g, w) {
        this.attribvalue += this.getSlice(g, w);
      }, b.prototype.onattribentity = function(g) {
        this.attribvalue += (0, i.fromCodePoint)(g);
      }, b.prototype.onattribend = function(g, w) {
        var v, y;
        this.endIndex = w, (y = (v = this.cbs).onattribute) === null || y === void 0 || y.call(v, this.attribname, this.attribvalue, g === r.QuoteType.Double ? '"' : g === r.QuoteType.Single ? "'" : g === r.QuoteType.NoValue ? void 0 : null), this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname) && (this.attribs[this.attribname] = this.attribvalue), this.attribvalue = "";
      }, b.prototype.getInstructionName = function(g) {
        var w = g.search(p), v = w < 0 ? g : g.substr(0, w);
        return this.lowerCaseTagNames && (v = v.toLowerCase()), v;
      }, b.prototype.ondeclaration = function(g, w) {
        this.endIndex = w;
        var v = this.getSlice(g, w);
        if (this.cbs.onprocessinginstruction) {
          var y = this.getInstructionName(v);
          this.cbs.onprocessinginstruction("!".concat(y), "!".concat(v));
        }
        this.startIndex = w + 1;
      }, b.prototype.onprocessinginstruction = function(g, w) {
        this.endIndex = w;
        var v = this.getSlice(g, w);
        if (this.cbs.onprocessinginstruction) {
          var y = this.getInstructionName(v);
          this.cbs.onprocessinginstruction("?".concat(y), "?".concat(v));
        }
        this.startIndex = w + 1;
      }, b.prototype.oncomment = function(g, w, v) {
        var y, x, k, T;
        this.endIndex = w, (x = (y = this.cbs).oncomment) === null || x === void 0 || x.call(y, this.getSlice(g, w - v)), (T = (k = this.cbs).oncommentend) === null || T === void 0 || T.call(k), this.startIndex = w + 1;
      }, b.prototype.oncdata = function(g, w, v) {
        var y, x, k, T, M, D, I, C, O, E;
        this.endIndex = w;
        var N = this.getSlice(g, w - v);
        this.options.xmlMode || this.options.recognizeCDATA ? ((x = (y = this.cbs).oncdatastart) === null || x === void 0 || x.call(y), (T = (k = this.cbs).ontext) === null || T === void 0 || T.call(k, N), (D = (M = this.cbs).oncdataend) === null || D === void 0 || D.call(M)) : ((C = (I = this.cbs).oncomment) === null || C === void 0 || C.call(I, "[CDATA[".concat(N, "]]")), (E = (O = this.cbs).oncommentend) === null || E === void 0 || E.call(O)), this.startIndex = w + 1;
      }, b.prototype.onend = function() {
        var g, w;
        if (this.cbs.onclosetag) {
          this.endIndex = this.startIndex;
          for (var v = this.stack.length; v > 0; this.cbs.onclosetag(this.stack[--v], true)) ;
        }
        (w = (g = this.cbs).onend) === null || w === void 0 || w.call(g);
      }, b.prototype.reset = function() {
        var g, w, v, y;
        (w = (g = this.cbs).onreset) === null || w === void 0 || w.call(g), this.tokenizer.reset(), this.tagname = "", this.attribname = "", this.attribs = null, this.stack.length = 0, this.startIndex = 0, this.endIndex = 0, (y = (v = this.cbs).onparserinit) === null || y === void 0 || y.call(v, this), this.buffers.length = 0, this.bufferOffset = 0, this.writeIndex = 0, this.ended = false;
      }, b.prototype.parseComplete = function(g) {
        this.reset(), this.end(g);
      }, b.prototype.getSlice = function(g, w) {
        for (; g - this.bufferOffset >= this.buffers[0].length; ) this.shiftBuffer();
        for (var v = this.buffers[0].slice(g - this.bufferOffset, w - this.bufferOffset); w - this.bufferOffset > this.buffers[0].length; ) this.shiftBuffer(), v += this.buffers[0].slice(0, w - this.bufferOffset);
        return v;
      }, b.prototype.shiftBuffer = function() {
        this.bufferOffset += this.buffers[0].length, this.writeIndex--, this.buffers.shift();
      }, b.prototype.write = function(g) {
        var w, v;
        if (this.ended) {
          (v = (w = this.cbs).onerror) === null || v === void 0 || v.call(w, new Error(".write() after done!"));
          return;
        }
        this.buffers.push(g), this.tokenizer.running && (this.tokenizer.write(g), this.writeIndex++);
      }, b.prototype.end = function(g) {
        var w, v;
        if (this.ended) {
          (v = (w = this.cbs).onerror) === null || v === void 0 || v.call(w, new Error(".end() after done!"));
          return;
        }
        g && this.write(g), this.ended = true, this.tokenizer.end();
      }, b.prototype.pause = function() {
        this.tokenizer.pause();
      }, b.prototype.resume = function() {
        for (this.tokenizer.resume(); this.tokenizer.running && this.writeIndex < this.buffers.length; ) this.tokenizer.write(this.buffers[this.writeIndex++]);
        this.ended && this.tokenizer.end();
      }, b.prototype.parseChunk = function(g) {
        this.write(g);
      }, b.prototype.done = function(g) {
        this.end(g);
      }, b;
    }();
    return tn.Parser = m, tn;
  }
  var gr = {}, Pa = {}, jd;
  function is() {
    return jd || (jd = 1, function(n) {
      Object.defineProperty(n, "__esModule", {
        value: true
      }), n.Doctype = n.CDATA = n.Tag = n.Style = n.Script = n.Comment = n.Directive = n.Text = n.Root = n.isTag = n.ElementType = void 0;
      var e;
      (function(r) {
        r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
      })(e = n.ElementType || (n.ElementType = {}));
      function t(r) {
        return r.type === e.Tag || r.type === e.Script || r.type === e.Style;
      }
      n.isTag = t, n.Root = e.Root, n.Text = e.Text, n.Directive = e.Directive, n.Comment = e.Comment, n.Script = e.Script, n.Style = e.Style, n.Tag = e.Tag, n.CDATA = e.CDATA, n.Doctype = e.Doctype;
    }(Pa)), Pa;
  }
  var De = {}, qd;
  function $d() {
    if (qd) return De;
    qd = 1;
    var n = De && De.__extends || /* @__PURE__ */ function() {
      var x = function(k, T) {
        return x = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(M, D) {
          M.__proto__ = D;
        } || function(M, D) {
          for (var I in D) Object.prototype.hasOwnProperty.call(D, I) && (M[I] = D[I]);
        }, x(k, T);
      };
      return function(k, T) {
        if (typeof T != "function" && T !== null) throw new TypeError("Class extends value " + String(T) + " is not a constructor or null");
        x(k, T);
        function M() {
          this.constructor = k;
        }
        k.prototype = T === null ? Object.create(T) : (M.prototype = T.prototype, new M());
      };
    }(), e = De && De.__assign || function() {
      return e = Object.assign || function(x) {
        for (var k, T = 1, M = arguments.length; T < M; T++) {
          k = arguments[T];
          for (var D in k) Object.prototype.hasOwnProperty.call(k, D) && (x[D] = k[D]);
        }
        return x;
      }, e.apply(this, arguments);
    };
    Object.defineProperty(De, "__esModule", {
      value: true
    }), De.cloneNode = De.hasChildren = De.isDocument = De.isDirective = De.isComment = De.isText = De.isCDATA = De.isTag = De.Element = De.Document = De.CDATA = De.NodeWithChildren = De.ProcessingInstruction = De.Comment = De.Text = De.DataNode = De.Node = void 0;
    var t = is(), r = function() {
      function x() {
        this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
      }
      return Object.defineProperty(x.prototype, "parentNode", {
        get: function() {
          return this.parent;
        },
        set: function(k) {
          this.parent = k;
        },
        enumerable: false,
        configurable: true
      }), Object.defineProperty(x.prototype, "previousSibling", {
        get: function() {
          return this.prev;
        },
        set: function(k) {
          this.prev = k;
        },
        enumerable: false,
        configurable: true
      }), Object.defineProperty(x.prototype, "nextSibling", {
        get: function() {
          return this.next;
        },
        set: function(k) {
          this.next = k;
        },
        enumerable: false,
        configurable: true
      }), x.prototype.cloneNode = function(k) {
        return k === void 0 && (k = false), v(this, k);
      }, x;
    }();
    De.Node = r;
    var i = function(x) {
      n(k, x);
      function k(T) {
        var M = x.call(this) || this;
        return M.data = T, M;
      }
      return Object.defineProperty(k.prototype, "nodeValue", {
        get: function() {
          return this.data;
        },
        set: function(T) {
          this.data = T;
        },
        enumerable: false,
        configurable: true
      }), k;
    }(r);
    De.DataNode = i;
    var s = function(x) {
      n(k, x);
      function k() {
        var T = x !== null && x.apply(this, arguments) || this;
        return T.type = t.ElementType.Text, T;
      }
      return Object.defineProperty(k.prototype, "nodeType", {
        get: function() {
          return 3;
        },
        enumerable: false,
        configurable: true
      }), k;
    }(i);
    De.Text = s;
    var o = function(x) {
      n(k, x);
      function k() {
        var T = x !== null && x.apply(this, arguments) || this;
        return T.type = t.ElementType.Comment, T;
      }
      return Object.defineProperty(k.prototype, "nodeType", {
        get: function() {
          return 8;
        },
        enumerable: false,
        configurable: true
      }), k;
    }(i);
    De.Comment = o;
    var a = function(x) {
      n(k, x);
      function k(T, M) {
        var D = x.call(this, M) || this;
        return D.name = T, D.type = t.ElementType.Directive, D;
      }
      return Object.defineProperty(k.prototype, "nodeType", {
        get: function() {
          return 1;
        },
        enumerable: false,
        configurable: true
      }), k;
    }(i);
    De.ProcessingInstruction = a;
    var u = function(x) {
      n(k, x);
      function k(T) {
        var M = x.call(this) || this;
        return M.children = T, M;
      }
      return Object.defineProperty(k.prototype, "firstChild", {
        get: function() {
          var T;
          return (T = this.children[0]) !== null && T !== void 0 ? T : null;
        },
        enumerable: false,
        configurable: true
      }), Object.defineProperty(k.prototype, "lastChild", {
        get: function() {
          return this.children.length > 0 ? this.children[this.children.length - 1] : null;
        },
        enumerable: false,
        configurable: true
      }), Object.defineProperty(k.prototype, "childNodes", {
        get: function() {
          return this.children;
        },
        set: function(T) {
          this.children = T;
        },
        enumerable: false,
        configurable: true
      }), k;
    }(r);
    De.NodeWithChildren = u;
    var l = function(x) {
      n(k, x);
      function k() {
        var T = x !== null && x.apply(this, arguments) || this;
        return T.type = t.ElementType.CDATA, T;
      }
      return Object.defineProperty(k.prototype, "nodeType", {
        get: function() {
          return 4;
        },
        enumerable: false,
        configurable: true
      }), k;
    }(u);
    De.CDATA = l;
    var c = function(x) {
      n(k, x);
      function k() {
        var T = x !== null && x.apply(this, arguments) || this;
        return T.type = t.ElementType.Root, T;
      }
      return Object.defineProperty(k.prototype, "nodeType", {
        get: function() {
          return 9;
        },
        enumerable: false,
        configurable: true
      }), k;
    }(u);
    De.Document = c;
    var h = function(x) {
      n(k, x);
      function k(T, M, D, I) {
        D === void 0 && (D = []), I === void 0 && (I = T === "script" ? t.ElementType.Script : T === "style" ? t.ElementType.Style : t.ElementType.Tag);
        var C = x.call(this, D) || this;
        return C.name = T, C.attribs = M, C.type = I, C;
      }
      return Object.defineProperty(k.prototype, "nodeType", {
        get: function() {
          return 1;
        },
        enumerable: false,
        configurable: true
      }), Object.defineProperty(k.prototype, "tagName", {
        get: function() {
          return this.name;
        },
        set: function(T) {
          this.name = T;
        },
        enumerable: false,
        configurable: true
      }), Object.defineProperty(k.prototype, "attributes", {
        get: function() {
          var T = this;
          return Object.keys(this.attribs).map(function(M) {
            var D, I;
            return {
              name: M,
              value: T.attribs[M],
              namespace: (D = T["x-attribsNamespace"]) === null || D === void 0 ? void 0 : D[M],
              prefix: (I = T["x-attribsPrefix"]) === null || I === void 0 ? void 0 : I[M]
            };
          });
        },
        enumerable: false,
        configurable: true
      }), k;
    }(u);
    De.Element = h;
    function d(x) {
      return (0, t.isTag)(x);
    }
    De.isTag = d;
    function f(x) {
      return x.type === t.ElementType.CDATA;
    }
    De.isCDATA = f;
    function p(x) {
      return x.type === t.ElementType.Text;
    }
    De.isText = p;
    function m(x) {
      return x.type === t.ElementType.Comment;
    }
    De.isComment = m;
    function b(x) {
      return x.type === t.ElementType.Directive;
    }
    De.isDirective = b;
    function g(x) {
      return x.type === t.ElementType.Root;
    }
    De.isDocument = g;
    function w(x) {
      return Object.prototype.hasOwnProperty.call(x, "children");
    }
    De.hasChildren = w;
    function v(x, k) {
      k === void 0 && (k = false);
      var T;
      if (p(x)) T = new s(x.data);
      else if (m(x)) T = new o(x.data);
      else if (d(x)) {
        var M = k ? y(x.children) : [], D = new h(x.name, e({}, x.attribs), M);
        M.forEach(function(E) {
          return E.parent = D;
        }), x.namespace != null && (D.namespace = x.namespace), x["x-attribsNamespace"] && (D["x-attribsNamespace"] = e({}, x["x-attribsNamespace"])), x["x-attribsPrefix"] && (D["x-attribsPrefix"] = e({}, x["x-attribsPrefix"])), T = D;
      } else if (f(x)) {
        var M = k ? y(x.children) : [], I = new l(M);
        M.forEach(function(N) {
          return N.parent = I;
        }), T = I;
      } else if (g(x)) {
        var M = k ? y(x.children) : [], C = new c(M);
        M.forEach(function(N) {
          return N.parent = C;
        }), x["x-mode"] && (C["x-mode"] = x["x-mode"]), T = C;
      } else if (b(x)) {
        var O = new a(x.name, x.data);
        x["x-name"] != null && (O["x-name"] = x["x-name"], O["x-publicId"] = x["x-publicId"], O["x-systemId"] = x["x-systemId"]), T = O;
      } else throw new Error("Not implemented yet: ".concat(x.type));
      return T.startIndex = x.startIndex, T.endIndex = x.endIndex, x.sourceCodeLocation != null && (T.sourceCodeLocation = x.sourceCodeLocation), T;
    }
    De.cloneNode = v;
    function y(x) {
      for (var k = x.map(function(M) {
        return v(M, true);
      }), T = 1; T < k.length; T++) k[T].prev = k[T - 1], k[T - 1].next = k[T];
      return k;
    }
    return De;
  }
  var Vd;
  function dr() {
    return Vd || (Vd = 1, function(n) {
      var e = gr && gr.__createBinding || (Object.create ? function(a, u, l, c) {
        c === void 0 && (c = l);
        var h = Object.getOwnPropertyDescriptor(u, l);
        (!h || ("get" in h ? !u.__esModule : h.writable || h.configurable)) && (h = {
          enumerable: true,
          get: function() {
            return u[l];
          }
        }), Object.defineProperty(a, c, h);
      } : function(a, u, l, c) {
        c === void 0 && (c = l), a[c] = u[l];
      }), t = gr && gr.__exportStar || function(a, u) {
        for (var l in a) l !== "default" && !Object.prototype.hasOwnProperty.call(u, l) && e(u, a, l);
      };
      Object.defineProperty(n, "__esModule", {
        value: true
      }), n.DomHandler = void 0;
      var r = is(), i = $d();
      t($d(), n);
      var s = {
        withStartIndices: false,
        withEndIndices: false,
        xmlMode: false
      }, o = function() {
        function a(u, l, c) {
          this.dom = [], this.root = new i.Document(this.dom), this.done = false, this.tagStack = [
            this.root
          ], this.lastNode = null, this.parser = null, typeof l == "function" && (c = l, l = s), typeof u == "object" && (l = u, u = void 0), this.callback = u ?? null, this.options = l ?? s, this.elementCB = c ?? null;
        }
        return a.prototype.onparserinit = function(u) {
          this.parser = u;
        }, a.prototype.onreset = function() {
          this.dom = [], this.root = new i.Document(this.dom), this.done = false, this.tagStack = [
            this.root
          ], this.lastNode = null, this.parser = null;
        }, a.prototype.onend = function() {
          this.done || (this.done = true, this.parser = null, this.handleCallback(null));
        }, a.prototype.onerror = function(u) {
          this.handleCallback(u);
        }, a.prototype.onclosetag = function() {
          this.lastNode = null;
          var u = this.tagStack.pop();
          this.options.withEndIndices && (u.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(u);
        }, a.prototype.onopentag = function(u, l) {
          var c = this.options.xmlMode ? r.ElementType.Tag : void 0, h = new i.Element(u, l, void 0, c);
          this.addNode(h), this.tagStack.push(h);
        }, a.prototype.ontext = function(u) {
          var l = this.lastNode;
          if (l && l.type === r.ElementType.Text) l.data += u, this.options.withEndIndices && (l.endIndex = this.parser.endIndex);
          else {
            var c = new i.Text(u);
            this.addNode(c), this.lastNode = c;
          }
        }, a.prototype.oncomment = function(u) {
          if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
            this.lastNode.data += u;
            return;
          }
          var l = new i.Comment(u);
          this.addNode(l), this.lastNode = l;
        }, a.prototype.oncommentend = function() {
          this.lastNode = null;
        }, a.prototype.oncdatastart = function() {
          var u = new i.Text(""), l = new i.CDATA([
            u
          ]);
          this.addNode(l), u.parent = l, this.lastNode = u;
        }, a.prototype.oncdataend = function() {
          this.lastNode = null;
        }, a.prototype.onprocessinginstruction = function(u, l) {
          var c = new i.ProcessingInstruction(u, l);
          this.addNode(c);
        }, a.prototype.handleCallback = function(u) {
          if (typeof this.callback == "function") this.callback(u, this.dom);
          else if (u) throw u;
        }, a.prototype.addNode = function(u) {
          var l = this.tagStack[this.tagStack.length - 1], c = l.children[l.children.length - 1];
          this.options.withStartIndices && (u.startIndex = this.parser.startIndex), this.options.withEndIndices && (u.endIndex = this.parser.endIndex), l.children.push(u), c && (u.prev = c, c.next = u), u.parent = l, this.lastNode = null;
        }, a;
      }();
      n.DomHandler = o, n.default = o;
    }(gr)), gr;
  }
  var br = {}, gn = {}, Ft = {}, Da = {}, Dn = {}, ks = {}, Hd;
  function Dk() {
    if (Hd) return ks;
    Hd = 1, Object.defineProperty(ks, "__esModule", {
      value: true
    });
    function n(e) {
      for (var t = 1; t < e.length; t++) e[t][0] += e[t - 1][0] + 1;
      return e;
    }
    return ks.default = new Map(n([
      [
        9,
        "&Tab;"
      ],
      [
        0,
        "&NewLine;"
      ],
      [
        22,
        "&excl;"
      ],
      [
        0,
        "&quot;"
      ],
      [
        0,
        "&num;"
      ],
      [
        0,
        "&dollar;"
      ],
      [
        0,
        "&percnt;"
      ],
      [
        0,
        "&amp;"
      ],
      [
        0,
        "&apos;"
      ],
      [
        0,
        "&lpar;"
      ],
      [
        0,
        "&rpar;"
      ],
      [
        0,
        "&ast;"
      ],
      [
        0,
        "&plus;"
      ],
      [
        0,
        "&comma;"
      ],
      [
        1,
        "&period;"
      ],
      [
        0,
        "&sol;"
      ],
      [
        10,
        "&colon;"
      ],
      [
        0,
        "&semi;"
      ],
      [
        0,
        {
          v: "&lt;",
          n: 8402,
          o: "&nvlt;"
        }
      ],
      [
        0,
        {
          v: "&equals;",
          n: 8421,
          o: "&bne;"
        }
      ],
      [
        0,
        {
          v: "&gt;",
          n: 8402,
          o: "&nvgt;"
        }
      ],
      [
        0,
        "&quest;"
      ],
      [
        0,
        "&commat;"
      ],
      [
        26,
        "&lbrack;"
      ],
      [
        0,
        "&bsol;"
      ],
      [
        0,
        "&rbrack;"
      ],
      [
        0,
        "&Hat;"
      ],
      [
        0,
        "&lowbar;"
      ],
      [
        0,
        "&DiacriticalGrave;"
      ],
      [
        5,
        {
          n: 106,
          o: "&fjlig;"
        }
      ],
      [
        20,
        "&lbrace;"
      ],
      [
        0,
        "&verbar;"
      ],
      [
        0,
        "&rbrace;"
      ],
      [
        34,
        "&nbsp;"
      ],
      [
        0,
        "&iexcl;"
      ],
      [
        0,
        "&cent;"
      ],
      [
        0,
        "&pound;"
      ],
      [
        0,
        "&curren;"
      ],
      [
        0,
        "&yen;"
      ],
      [
        0,
        "&brvbar;"
      ],
      [
        0,
        "&sect;"
      ],
      [
        0,
        "&die;"
      ],
      [
        0,
        "&copy;"
      ],
      [
        0,
        "&ordf;"
      ],
      [
        0,
        "&laquo;"
      ],
      [
        0,
        "&not;"
      ],
      [
        0,
        "&shy;"
      ],
      [
        0,
        "&circledR;"
      ],
      [
        0,
        "&macr;"
      ],
      [
        0,
        "&deg;"
      ],
      [
        0,
        "&PlusMinus;"
      ],
      [
        0,
        "&sup2;"
      ],
      [
        0,
        "&sup3;"
      ],
      [
        0,
        "&acute;"
      ],
      [
        0,
        "&micro;"
      ],
      [
        0,
        "&para;"
      ],
      [
        0,
        "&centerdot;"
      ],
      [
        0,
        "&cedil;"
      ],
      [
        0,
        "&sup1;"
      ],
      [
        0,
        "&ordm;"
      ],
      [
        0,
        "&raquo;"
      ],
      [
        0,
        "&frac14;"
      ],
      [
        0,
        "&frac12;"
      ],
      [
        0,
        "&frac34;"
      ],
      [
        0,
        "&iquest;"
      ],
      [
        0,
        "&Agrave;"
      ],
      [
        0,
        "&Aacute;"
      ],
      [
        0,
        "&Acirc;"
      ],
      [
        0,
        "&Atilde;"
      ],
      [
        0,
        "&Auml;"
      ],
      [
        0,
        "&angst;"
      ],
      [
        0,
        "&AElig;"
      ],
      [
        0,
        "&Ccedil;"
      ],
      [
        0,
        "&Egrave;"
      ],
      [
        0,
        "&Eacute;"
      ],
      [
        0,
        "&Ecirc;"
      ],
      [
        0,
        "&Euml;"
      ],
      [
        0,
        "&Igrave;"
      ],
      [
        0,
        "&Iacute;"
      ],
      [
        0,
        "&Icirc;"
      ],
      [
        0,
        "&Iuml;"
      ],
      [
        0,
        "&ETH;"
      ],
      [
        0,
        "&Ntilde;"
      ],
      [
        0,
        "&Ograve;"
      ],
      [
        0,
        "&Oacute;"
      ],
      [
        0,
        "&Ocirc;"
      ],
      [
        0,
        "&Otilde;"
      ],
      [
        0,
        "&Ouml;"
      ],
      [
        0,
        "&times;"
      ],
      [
        0,
        "&Oslash;"
      ],
      [
        0,
        "&Ugrave;"
      ],
      [
        0,
        "&Uacute;"
      ],
      [
        0,
        "&Ucirc;"
      ],
      [
        0,
        "&Uuml;"
      ],
      [
        0,
        "&Yacute;"
      ],
      [
        0,
        "&THORN;"
      ],
      [
        0,
        "&szlig;"
      ],
      [
        0,
        "&agrave;"
      ],
      [
        0,
        "&aacute;"
      ],
      [
        0,
        "&acirc;"
      ],
      [
        0,
        "&atilde;"
      ],
      [
        0,
        "&auml;"
      ],
      [
        0,
        "&aring;"
      ],
      [
        0,
        "&aelig;"
      ],
      [
        0,
        "&ccedil;"
      ],
      [
        0,
        "&egrave;"
      ],
      [
        0,
        "&eacute;"
      ],
      [
        0,
        "&ecirc;"
      ],
      [
        0,
        "&euml;"
      ],
      [
        0,
        "&igrave;"
      ],
      [
        0,
        "&iacute;"
      ],
      [
        0,
        "&icirc;"
      ],
      [
        0,
        "&iuml;"
      ],
      [
        0,
        "&eth;"
      ],
      [
        0,
        "&ntilde;"
      ],
      [
        0,
        "&ograve;"
      ],
      [
        0,
        "&oacute;"
      ],
      [
        0,
        "&ocirc;"
      ],
      [
        0,
        "&otilde;"
      ],
      [
        0,
        "&ouml;"
      ],
      [
        0,
        "&div;"
      ],
      [
        0,
        "&oslash;"
      ],
      [
        0,
        "&ugrave;"
      ],
      [
        0,
        "&uacute;"
      ],
      [
        0,
        "&ucirc;"
      ],
      [
        0,
        "&uuml;"
      ],
      [
        0,
        "&yacute;"
      ],
      [
        0,
        "&thorn;"
      ],
      [
        0,
        "&yuml;"
      ],
      [
        0,
        "&Amacr;"
      ],
      [
        0,
        "&amacr;"
      ],
      [
        0,
        "&Abreve;"
      ],
      [
        0,
        "&abreve;"
      ],
      [
        0,
        "&Aogon;"
      ],
      [
        0,
        "&aogon;"
      ],
      [
        0,
        "&Cacute;"
      ],
      [
        0,
        "&cacute;"
      ],
      [
        0,
        "&Ccirc;"
      ],
      [
        0,
        "&ccirc;"
      ],
      [
        0,
        "&Cdot;"
      ],
      [
        0,
        "&cdot;"
      ],
      [
        0,
        "&Ccaron;"
      ],
      [
        0,
        "&ccaron;"
      ],
      [
        0,
        "&Dcaron;"
      ],
      [
        0,
        "&dcaron;"
      ],
      [
        0,
        "&Dstrok;"
      ],
      [
        0,
        "&dstrok;"
      ],
      [
        0,
        "&Emacr;"
      ],
      [
        0,
        "&emacr;"
      ],
      [
        2,
        "&Edot;"
      ],
      [
        0,
        "&edot;"
      ],
      [
        0,
        "&Eogon;"
      ],
      [
        0,
        "&eogon;"
      ],
      [
        0,
        "&Ecaron;"
      ],
      [
        0,
        "&ecaron;"
      ],
      [
        0,
        "&Gcirc;"
      ],
      [
        0,
        "&gcirc;"
      ],
      [
        0,
        "&Gbreve;"
      ],
      [
        0,
        "&gbreve;"
      ],
      [
        0,
        "&Gdot;"
      ],
      [
        0,
        "&gdot;"
      ],
      [
        0,
        "&Gcedil;"
      ],
      [
        1,
        "&Hcirc;"
      ],
      [
        0,
        "&hcirc;"
      ],
      [
        0,
        "&Hstrok;"
      ],
      [
        0,
        "&hstrok;"
      ],
      [
        0,
        "&Itilde;"
      ],
      [
        0,
        "&itilde;"
      ],
      [
        0,
        "&Imacr;"
      ],
      [
        0,
        "&imacr;"
      ],
      [
        2,
        "&Iogon;"
      ],
      [
        0,
        "&iogon;"
      ],
      [
        0,
        "&Idot;"
      ],
      [
        0,
        "&imath;"
      ],
      [
        0,
        "&IJlig;"
      ],
      [
        0,
        "&ijlig;"
      ],
      [
        0,
        "&Jcirc;"
      ],
      [
        0,
        "&jcirc;"
      ],
      [
        0,
        "&Kcedil;"
      ],
      [
        0,
        "&kcedil;"
      ],
      [
        0,
        "&kgreen;"
      ],
      [
        0,
        "&Lacute;"
      ],
      [
        0,
        "&lacute;"
      ],
      [
        0,
        "&Lcedil;"
      ],
      [
        0,
        "&lcedil;"
      ],
      [
        0,
        "&Lcaron;"
      ],
      [
        0,
        "&lcaron;"
      ],
      [
        0,
        "&Lmidot;"
      ],
      [
        0,
        "&lmidot;"
      ],
      [
        0,
        "&Lstrok;"
      ],
      [
        0,
        "&lstrok;"
      ],
      [
        0,
        "&Nacute;"
      ],
      [
        0,
        "&nacute;"
      ],
      [
        0,
        "&Ncedil;"
      ],
      [
        0,
        "&ncedil;"
      ],
      [
        0,
        "&Ncaron;"
      ],
      [
        0,
        "&ncaron;"
      ],
      [
        0,
        "&napos;"
      ],
      [
        0,
        "&ENG;"
      ],
      [
        0,
        "&eng;"
      ],
      [
        0,
        "&Omacr;"
      ],
      [
        0,
        "&omacr;"
      ],
      [
        2,
        "&Odblac;"
      ],
      [
        0,
        "&odblac;"
      ],
      [
        0,
        "&OElig;"
      ],
      [
        0,
        "&oelig;"
      ],
      [
        0,
        "&Racute;"
      ],
      [
        0,
        "&racute;"
      ],
      [
        0,
        "&Rcedil;"
      ],
      [
        0,
        "&rcedil;"
      ],
      [
        0,
        "&Rcaron;"
      ],
      [
        0,
        "&rcaron;"
      ],
      [
        0,
        "&Sacute;"
      ],
      [
        0,
        "&sacute;"
      ],
      [
        0,
        "&Scirc;"
      ],
      [
        0,
        "&scirc;"
      ],
      [
        0,
        "&Scedil;"
      ],
      [
        0,
        "&scedil;"
      ],
      [
        0,
        "&Scaron;"
      ],
      [
        0,
        "&scaron;"
      ],
      [
        0,
        "&Tcedil;"
      ],
      [
        0,
        "&tcedil;"
      ],
      [
        0,
        "&Tcaron;"
      ],
      [
        0,
        "&tcaron;"
      ],
      [
        0,
        "&Tstrok;"
      ],
      [
        0,
        "&tstrok;"
      ],
      [
        0,
        "&Utilde;"
      ],
      [
        0,
        "&utilde;"
      ],
      [
        0,
        "&Umacr;"
      ],
      [
        0,
        "&umacr;"
      ],
      [
        0,
        "&Ubreve;"
      ],
      [
        0,
        "&ubreve;"
      ],
      [
        0,
        "&Uring;"
      ],
      [
        0,
        "&uring;"
      ],
      [
        0,
        "&Udblac;"
      ],
      [
        0,
        "&udblac;"
      ],
      [
        0,
        "&Uogon;"
      ],
      [
        0,
        "&uogon;"
      ],
      [
        0,
        "&Wcirc;"
      ],
      [
        0,
        "&wcirc;"
      ],
      [
        0,
        "&Ycirc;"
      ],
      [
        0,
        "&ycirc;"
      ],
      [
        0,
        "&Yuml;"
      ],
      [
        0,
        "&Zacute;"
      ],
      [
        0,
        "&zacute;"
      ],
      [
        0,
        "&Zdot;"
      ],
      [
        0,
        "&zdot;"
      ],
      [
        0,
        "&Zcaron;"
      ],
      [
        0,
        "&zcaron;"
      ],
      [
        19,
        "&fnof;"
      ],
      [
        34,
        "&imped;"
      ],
      [
        63,
        "&gacute;"
      ],
      [
        65,
        "&jmath;"
      ],
      [
        142,
        "&circ;"
      ],
      [
        0,
        "&caron;"
      ],
      [
        16,
        "&breve;"
      ],
      [
        0,
        "&DiacriticalDot;"
      ],
      [
        0,
        "&ring;"
      ],
      [
        0,
        "&ogon;"
      ],
      [
        0,
        "&DiacriticalTilde;"
      ],
      [
        0,
        "&dblac;"
      ],
      [
        51,
        "&DownBreve;"
      ],
      [
        127,
        "&Alpha;"
      ],
      [
        0,
        "&Beta;"
      ],
      [
        0,
        "&Gamma;"
      ],
      [
        0,
        "&Delta;"
      ],
      [
        0,
        "&Epsilon;"
      ],
      [
        0,
        "&Zeta;"
      ],
      [
        0,
        "&Eta;"
      ],
      [
        0,
        "&Theta;"
      ],
      [
        0,
        "&Iota;"
      ],
      [
        0,
        "&Kappa;"
      ],
      [
        0,
        "&Lambda;"
      ],
      [
        0,
        "&Mu;"
      ],
      [
        0,
        "&Nu;"
      ],
      [
        0,
        "&Xi;"
      ],
      [
        0,
        "&Omicron;"
      ],
      [
        0,
        "&Pi;"
      ],
      [
        0,
        "&Rho;"
      ],
      [
        1,
        "&Sigma;"
      ],
      [
        0,
        "&Tau;"
      ],
      [
        0,
        "&Upsilon;"
      ],
      [
        0,
        "&Phi;"
      ],
      [
        0,
        "&Chi;"
      ],
      [
        0,
        "&Psi;"
      ],
      [
        0,
        "&ohm;"
      ],
      [
        7,
        "&alpha;"
      ],
      [
        0,
        "&beta;"
      ],
      [
        0,
        "&gamma;"
      ],
      [
        0,
        "&delta;"
      ],
      [
        0,
        "&epsi;"
      ],
      [
        0,
        "&zeta;"
      ],
      [
        0,
        "&eta;"
      ],
      [
        0,
        "&theta;"
      ],
      [
        0,
        "&iota;"
      ],
      [
        0,
        "&kappa;"
      ],
      [
        0,
        "&lambda;"
      ],
      [
        0,
        "&mu;"
      ],
      [
        0,
        "&nu;"
      ],
      [
        0,
        "&xi;"
      ],
      [
        0,
        "&omicron;"
      ],
      [
        0,
        "&pi;"
      ],
      [
        0,
        "&rho;"
      ],
      [
        0,
        "&sigmaf;"
      ],
      [
        0,
        "&sigma;"
      ],
      [
        0,
        "&tau;"
      ],
      [
        0,
        "&upsi;"
      ],
      [
        0,
        "&phi;"
      ],
      [
        0,
        "&chi;"
      ],
      [
        0,
        "&psi;"
      ],
      [
        0,
        "&omega;"
      ],
      [
        7,
        "&thetasym;"
      ],
      [
        0,
        "&Upsi;"
      ],
      [
        2,
        "&phiv;"
      ],
      [
        0,
        "&piv;"
      ],
      [
        5,
        "&Gammad;"
      ],
      [
        0,
        "&digamma;"
      ],
      [
        18,
        "&kappav;"
      ],
      [
        0,
        "&rhov;"
      ],
      [
        3,
        "&epsiv;"
      ],
      [
        0,
        "&backepsilon;"
      ],
      [
        10,
        "&IOcy;"
      ],
      [
        0,
        "&DJcy;"
      ],
      [
        0,
        "&GJcy;"
      ],
      [
        0,
        "&Jukcy;"
      ],
      [
        0,
        "&DScy;"
      ],
      [
        0,
        "&Iukcy;"
      ],
      [
        0,
        "&YIcy;"
      ],
      [
        0,
        "&Jsercy;"
      ],
      [
        0,
        "&LJcy;"
      ],
      [
        0,
        "&NJcy;"
      ],
      [
        0,
        "&TSHcy;"
      ],
      [
        0,
        "&KJcy;"
      ],
      [
        1,
        "&Ubrcy;"
      ],
      [
        0,
        "&DZcy;"
      ],
      [
        0,
        "&Acy;"
      ],
      [
        0,
        "&Bcy;"
      ],
      [
        0,
        "&Vcy;"
      ],
      [
        0,
        "&Gcy;"
      ],
      [
        0,
        "&Dcy;"
      ],
      [
        0,
        "&IEcy;"
      ],
      [
        0,
        "&ZHcy;"
      ],
      [
        0,
        "&Zcy;"
      ],
      [
        0,
        "&Icy;"
      ],
      [
        0,
        "&Jcy;"
      ],
      [
        0,
        "&Kcy;"
      ],
      [
        0,
        "&Lcy;"
      ],
      [
        0,
        "&Mcy;"
      ],
      [
        0,
        "&Ncy;"
      ],
      [
        0,
        "&Ocy;"
      ],
      [
        0,
        "&Pcy;"
      ],
      [
        0,
        "&Rcy;"
      ],
      [
        0,
        "&Scy;"
      ],
      [
        0,
        "&Tcy;"
      ],
      [
        0,
        "&Ucy;"
      ],
      [
        0,
        "&Fcy;"
      ],
      [
        0,
        "&KHcy;"
      ],
      [
        0,
        "&TScy;"
      ],
      [
        0,
        "&CHcy;"
      ],
      [
        0,
        "&SHcy;"
      ],
      [
        0,
        "&SHCHcy;"
      ],
      [
        0,
        "&HARDcy;"
      ],
      [
        0,
        "&Ycy;"
      ],
      [
        0,
        "&SOFTcy;"
      ],
      [
        0,
        "&Ecy;"
      ],
      [
        0,
        "&YUcy;"
      ],
      [
        0,
        "&YAcy;"
      ],
      [
        0,
        "&acy;"
      ],
      [
        0,
        "&bcy;"
      ],
      [
        0,
        "&vcy;"
      ],
      [
        0,
        "&gcy;"
      ],
      [
        0,
        "&dcy;"
      ],
      [
        0,
        "&iecy;"
      ],
      [
        0,
        "&zhcy;"
      ],
      [
        0,
        "&zcy;"
      ],
      [
        0,
        "&icy;"
      ],
      [
        0,
        "&jcy;"
      ],
      [
        0,
        "&kcy;"
      ],
      [
        0,
        "&lcy;"
      ],
      [
        0,
        "&mcy;"
      ],
      [
        0,
        "&ncy;"
      ],
      [
        0,
        "&ocy;"
      ],
      [
        0,
        "&pcy;"
      ],
      [
        0,
        "&rcy;"
      ],
      [
        0,
        "&scy;"
      ],
      [
        0,
        "&tcy;"
      ],
      [
        0,
        "&ucy;"
      ],
      [
        0,
        "&fcy;"
      ],
      [
        0,
        "&khcy;"
      ],
      [
        0,
        "&tscy;"
      ],
      [
        0,
        "&chcy;"
      ],
      [
        0,
        "&shcy;"
      ],
      [
        0,
        "&shchcy;"
      ],
      [
        0,
        "&hardcy;"
      ],
      [
        0,
        "&ycy;"
      ],
      [
        0,
        "&softcy;"
      ],
      [
        0,
        "&ecy;"
      ],
      [
        0,
        "&yucy;"
      ],
      [
        0,
        "&yacy;"
      ],
      [
        1,
        "&iocy;"
      ],
      [
        0,
        "&djcy;"
      ],
      [
        0,
        "&gjcy;"
      ],
      [
        0,
        "&jukcy;"
      ],
      [
        0,
        "&dscy;"
      ],
      [
        0,
        "&iukcy;"
      ],
      [
        0,
        "&yicy;"
      ],
      [
        0,
        "&jsercy;"
      ],
      [
        0,
        "&ljcy;"
      ],
      [
        0,
        "&njcy;"
      ],
      [
        0,
        "&tshcy;"
      ],
      [
        0,
        "&kjcy;"
      ],
      [
        1,
        "&ubrcy;"
      ],
      [
        0,
        "&dzcy;"
      ],
      [
        7074,
        "&ensp;"
      ],
      [
        0,
        "&emsp;"
      ],
      [
        0,
        "&emsp13;"
      ],
      [
        0,
        "&emsp14;"
      ],
      [
        1,
        "&numsp;"
      ],
      [
        0,
        "&puncsp;"
      ],
      [
        0,
        "&ThinSpace;"
      ],
      [
        0,
        "&hairsp;"
      ],
      [
        0,
        "&NegativeMediumSpace;"
      ],
      [
        0,
        "&zwnj;"
      ],
      [
        0,
        "&zwj;"
      ],
      [
        0,
        "&lrm;"
      ],
      [
        0,
        "&rlm;"
      ],
      [
        0,
        "&dash;"
      ],
      [
        2,
        "&ndash;"
      ],
      [
        0,
        "&mdash;"
      ],
      [
        0,
        "&horbar;"
      ],
      [
        0,
        "&Verbar;"
      ],
      [
        1,
        "&lsquo;"
      ],
      [
        0,
        "&CloseCurlyQuote;"
      ],
      [
        0,
        "&lsquor;"
      ],
      [
        1,
        "&ldquo;"
      ],
      [
        0,
        "&CloseCurlyDoubleQuote;"
      ],
      [
        0,
        "&bdquo;"
      ],
      [
        1,
        "&dagger;"
      ],
      [
        0,
        "&Dagger;"
      ],
      [
        0,
        "&bull;"
      ],
      [
        2,
        "&nldr;"
      ],
      [
        0,
        "&hellip;"
      ],
      [
        9,
        "&permil;"
      ],
      [
        0,
        "&pertenk;"
      ],
      [
        0,
        "&prime;"
      ],
      [
        0,
        "&Prime;"
      ],
      [
        0,
        "&tprime;"
      ],
      [
        0,
        "&backprime;"
      ],
      [
        3,
        "&lsaquo;"
      ],
      [
        0,
        "&rsaquo;"
      ],
      [
        3,
        "&oline;"
      ],
      [
        2,
        "&caret;"
      ],
      [
        1,
        "&hybull;"
      ],
      [
        0,
        "&frasl;"
      ],
      [
        10,
        "&bsemi;"
      ],
      [
        7,
        "&qprime;"
      ],
      [
        7,
        {
          v: "&MediumSpace;",
          n: 8202,
          o: "&ThickSpace;"
        }
      ],
      [
        0,
        "&NoBreak;"
      ],
      [
        0,
        "&af;"
      ],
      [
        0,
        "&InvisibleTimes;"
      ],
      [
        0,
        "&ic;"
      ],
      [
        72,
        "&euro;"
      ],
      [
        46,
        "&tdot;"
      ],
      [
        0,
        "&DotDot;"
      ],
      [
        37,
        "&complexes;"
      ],
      [
        2,
        "&incare;"
      ],
      [
        4,
        "&gscr;"
      ],
      [
        0,
        "&hamilt;"
      ],
      [
        0,
        "&Hfr;"
      ],
      [
        0,
        "&Hopf;"
      ],
      [
        0,
        "&planckh;"
      ],
      [
        0,
        "&hbar;"
      ],
      [
        0,
        "&imagline;"
      ],
      [
        0,
        "&Ifr;"
      ],
      [
        0,
        "&lagran;"
      ],
      [
        0,
        "&ell;"
      ],
      [
        1,
        "&naturals;"
      ],
      [
        0,
        "&numero;"
      ],
      [
        0,
        "&copysr;"
      ],
      [
        0,
        "&weierp;"
      ],
      [
        0,
        "&Popf;"
      ],
      [
        0,
        "&Qopf;"
      ],
      [
        0,
        "&realine;"
      ],
      [
        0,
        "&real;"
      ],
      [
        0,
        "&reals;"
      ],
      [
        0,
        "&rx;"
      ],
      [
        3,
        "&trade;"
      ],
      [
        1,
        "&integers;"
      ],
      [
        2,
        "&mho;"
      ],
      [
        0,
        "&zeetrf;"
      ],
      [
        0,
        "&iiota;"
      ],
      [
        2,
        "&bernou;"
      ],
      [
        0,
        "&Cayleys;"
      ],
      [
        1,
        "&escr;"
      ],
      [
        0,
        "&Escr;"
      ],
      [
        0,
        "&Fouriertrf;"
      ],
      [
        1,
        "&Mellintrf;"
      ],
      [
        0,
        "&order;"
      ],
      [
        0,
        "&alefsym;"
      ],
      [
        0,
        "&beth;"
      ],
      [
        0,
        "&gimel;"
      ],
      [
        0,
        "&daleth;"
      ],
      [
        12,
        "&CapitalDifferentialD;"
      ],
      [
        0,
        "&dd;"
      ],
      [
        0,
        "&ee;"
      ],
      [
        0,
        "&ii;"
      ],
      [
        10,
        "&frac13;"
      ],
      [
        0,
        "&frac23;"
      ],
      [
        0,
        "&frac15;"
      ],
      [
        0,
        "&frac25;"
      ],
      [
        0,
        "&frac35;"
      ],
      [
        0,
        "&frac45;"
      ],
      [
        0,
        "&frac16;"
      ],
      [
        0,
        "&frac56;"
      ],
      [
        0,
        "&frac18;"
      ],
      [
        0,
        "&frac38;"
      ],
      [
        0,
        "&frac58;"
      ],
      [
        0,
        "&frac78;"
      ],
      [
        49,
        "&larr;"
      ],
      [
        0,
        "&ShortUpArrow;"
      ],
      [
        0,
        "&rarr;"
      ],
      [
        0,
        "&darr;"
      ],
      [
        0,
        "&harr;"
      ],
      [
        0,
        "&updownarrow;"
      ],
      [
        0,
        "&nwarr;"
      ],
      [
        0,
        "&nearr;"
      ],
      [
        0,
        "&LowerRightArrow;"
      ],
      [
        0,
        "&LowerLeftArrow;"
      ],
      [
        0,
        "&nlarr;"
      ],
      [
        0,
        "&nrarr;"
      ],
      [
        1,
        {
          v: "&rarrw;",
          n: 824,
          o: "&nrarrw;"
        }
      ],
      [
        0,
        "&Larr;"
      ],
      [
        0,
        "&Uarr;"
      ],
      [
        0,
        "&Rarr;"
      ],
      [
        0,
        "&Darr;"
      ],
      [
        0,
        "&larrtl;"
      ],
      [
        0,
        "&rarrtl;"
      ],
      [
        0,
        "&LeftTeeArrow;"
      ],
      [
        0,
        "&mapstoup;"
      ],
      [
        0,
        "&map;"
      ],
      [
        0,
        "&DownTeeArrow;"
      ],
      [
        1,
        "&hookleftarrow;"
      ],
      [
        0,
        "&hookrightarrow;"
      ],
      [
        0,
        "&larrlp;"
      ],
      [
        0,
        "&looparrowright;"
      ],
      [
        0,
        "&harrw;"
      ],
      [
        0,
        "&nharr;"
      ],
      [
        1,
        "&lsh;"
      ],
      [
        0,
        "&rsh;"
      ],
      [
        0,
        "&ldsh;"
      ],
      [
        0,
        "&rdsh;"
      ],
      [
        1,
        "&crarr;"
      ],
      [
        0,
        "&cularr;"
      ],
      [
        0,
        "&curarr;"
      ],
      [
        2,
        "&circlearrowleft;"
      ],
      [
        0,
        "&circlearrowright;"
      ],
      [
        0,
        "&leftharpoonup;"
      ],
      [
        0,
        "&DownLeftVector;"
      ],
      [
        0,
        "&RightUpVector;"
      ],
      [
        0,
        "&LeftUpVector;"
      ],
      [
        0,
        "&rharu;"
      ],
      [
        0,
        "&DownRightVector;"
      ],
      [
        0,
        "&dharr;"
      ],
      [
        0,
        "&dharl;"
      ],
      [
        0,
        "&RightArrowLeftArrow;"
      ],
      [
        0,
        "&udarr;"
      ],
      [
        0,
        "&LeftArrowRightArrow;"
      ],
      [
        0,
        "&leftleftarrows;"
      ],
      [
        0,
        "&upuparrows;"
      ],
      [
        0,
        "&rightrightarrows;"
      ],
      [
        0,
        "&ddarr;"
      ],
      [
        0,
        "&leftrightharpoons;"
      ],
      [
        0,
        "&Equilibrium;"
      ],
      [
        0,
        "&nlArr;"
      ],
      [
        0,
        "&nhArr;"
      ],
      [
        0,
        "&nrArr;"
      ],
      [
        0,
        "&DoubleLeftArrow;"
      ],
      [
        0,
        "&DoubleUpArrow;"
      ],
      [
        0,
        "&DoubleRightArrow;"
      ],
      [
        0,
        "&dArr;"
      ],
      [
        0,
        "&DoubleLeftRightArrow;"
      ],
      [
        0,
        "&DoubleUpDownArrow;"
      ],
      [
        0,
        "&nwArr;"
      ],
      [
        0,
        "&neArr;"
      ],
      [
        0,
        "&seArr;"
      ],
      [
        0,
        "&swArr;"
      ],
      [
        0,
        "&lAarr;"
      ],
      [
        0,
        "&rAarr;"
      ],
      [
        1,
        "&zigrarr;"
      ],
      [
        6,
        "&larrb;"
      ],
      [
        0,
        "&rarrb;"
      ],
      [
        15,
        "&DownArrowUpArrow;"
      ],
      [
        7,
        "&loarr;"
      ],
      [
        0,
        "&roarr;"
      ],
      [
        0,
        "&hoarr;"
      ],
      [
        0,
        "&forall;"
      ],
      [
        0,
        "&comp;"
      ],
      [
        0,
        {
          v: "&part;",
          n: 824,
          o: "&npart;"
        }
      ],
      [
        0,
        "&exist;"
      ],
      [
        0,
        "&nexist;"
      ],
      [
        0,
        "&empty;"
      ],
      [
        1,
        "&Del;"
      ],
      [
        0,
        "&Element;"
      ],
      [
        0,
        "&NotElement;"
      ],
      [
        1,
        "&ni;"
      ],
      [
        0,
        "&notni;"
      ],
      [
        2,
        "&prod;"
      ],
      [
        0,
        "&coprod;"
      ],
      [
        0,
        "&sum;"
      ],
      [
        0,
        "&minus;"
      ],
      [
        0,
        "&MinusPlus;"
      ],
      [
        0,
        "&dotplus;"
      ],
      [
        1,
        "&Backslash;"
      ],
      [
        0,
        "&lowast;"
      ],
      [
        0,
        "&compfn;"
      ],
      [
        1,
        "&radic;"
      ],
      [
        2,
        "&prop;"
      ],
      [
        0,
        "&infin;"
      ],
      [
        0,
        "&angrt;"
      ],
      [
        0,
        {
          v: "&ang;",
          n: 8402,
          o: "&nang;"
        }
      ],
      [
        0,
        "&angmsd;"
      ],
      [
        0,
        "&angsph;"
      ],
      [
        0,
        "&mid;"
      ],
      [
        0,
        "&nmid;"
      ],
      [
        0,
        "&DoubleVerticalBar;"
      ],
      [
        0,
        "&NotDoubleVerticalBar;"
      ],
      [
        0,
        "&and;"
      ],
      [
        0,
        "&or;"
      ],
      [
        0,
        {
          v: "&cap;",
          n: 65024,
          o: "&caps;"
        }
      ],
      [
        0,
        {
          v: "&cup;",
          n: 65024,
          o: "&cups;"
        }
      ],
      [
        0,
        "&int;"
      ],
      [
        0,
        "&Int;"
      ],
      [
        0,
        "&iiint;"
      ],
      [
        0,
        "&conint;"
      ],
      [
        0,
        "&Conint;"
      ],
      [
        0,
        "&Cconint;"
      ],
      [
        0,
        "&cwint;"
      ],
      [
        0,
        "&ClockwiseContourIntegral;"
      ],
      [
        0,
        "&awconint;"
      ],
      [
        0,
        "&there4;"
      ],
      [
        0,
        "&becaus;"
      ],
      [
        0,
        "&ratio;"
      ],
      [
        0,
        "&Colon;"
      ],
      [
        0,
        "&dotminus;"
      ],
      [
        1,
        "&mDDot;"
      ],
      [
        0,
        "&homtht;"
      ],
      [
        0,
        {
          v: "&sim;",
          n: 8402,
          o: "&nvsim;"
        }
      ],
      [
        0,
        {
          v: "&backsim;",
          n: 817,
          o: "&race;"
        }
      ],
      [
        0,
        {
          v: "&ac;",
          n: 819,
          o: "&acE;"
        }
      ],
      [
        0,
        "&acd;"
      ],
      [
        0,
        "&VerticalTilde;"
      ],
      [
        0,
        "&NotTilde;"
      ],
      [
        0,
        {
          v: "&eqsim;",
          n: 824,
          o: "&nesim;"
        }
      ],
      [
        0,
        "&sime;"
      ],
      [
        0,
        "&NotTildeEqual;"
      ],
      [
        0,
        "&cong;"
      ],
      [
        0,
        "&simne;"
      ],
      [
        0,
        "&ncong;"
      ],
      [
        0,
        "&ap;"
      ],
      [
        0,
        "&nap;"
      ],
      [
        0,
        "&ape;"
      ],
      [
        0,
        {
          v: "&apid;",
          n: 824,
          o: "&napid;"
        }
      ],
      [
        0,
        "&backcong;"
      ],
      [
        0,
        {
          v: "&asympeq;",
          n: 8402,
          o: "&nvap;"
        }
      ],
      [
        0,
        {
          v: "&bump;",
          n: 824,
          o: "&nbump;"
        }
      ],
      [
        0,
        {
          v: "&bumpe;",
          n: 824,
          o: "&nbumpe;"
        }
      ],
      [
        0,
        {
          v: "&doteq;",
          n: 824,
          o: "&nedot;"
        }
      ],
      [
        0,
        "&doteqdot;"
      ],
      [
        0,
        "&efDot;"
      ],
      [
        0,
        "&erDot;"
      ],
      [
        0,
        "&Assign;"
      ],
      [
        0,
        "&ecolon;"
      ],
      [
        0,
        "&ecir;"
      ],
      [
        0,
        "&circeq;"
      ],
      [
        1,
        "&wedgeq;"
      ],
      [
        0,
        "&veeeq;"
      ],
      [
        1,
        "&triangleq;"
      ],
      [
        2,
        "&equest;"
      ],
      [
        0,
        "&ne;"
      ],
      [
        0,
        {
          v: "&Congruent;",
          n: 8421,
          o: "&bnequiv;"
        }
      ],
      [
        0,
        "&nequiv;"
      ],
      [
        1,
        {
          v: "&le;",
          n: 8402,
          o: "&nvle;"
        }
      ],
      [
        0,
        {
          v: "&ge;",
          n: 8402,
          o: "&nvge;"
        }
      ],
      [
        0,
        {
          v: "&lE;",
          n: 824,
          o: "&nlE;"
        }
      ],
      [
        0,
        {
          v: "&gE;",
          n: 824,
          o: "&ngE;"
        }
      ],
      [
        0,
        {
          v: "&lnE;",
          n: 65024,
          o: "&lvertneqq;"
        }
      ],
      [
        0,
        {
          v: "&gnE;",
          n: 65024,
          o: "&gvertneqq;"
        }
      ],
      [
        0,
        {
          v: "&ll;",
          n: new Map(n([
            [
              824,
              "&nLtv;"
            ],
            [
              7577,
              "&nLt;"
            ]
          ]))
        }
      ],
      [
        0,
        {
          v: "&gg;",
          n: new Map(n([
            [
              824,
              "&nGtv;"
            ],
            [
              7577,
              "&nGt;"
            ]
          ]))
        }
      ],
      [
        0,
        "&between;"
      ],
      [
        0,
        "&NotCupCap;"
      ],
      [
        0,
        "&nless;"
      ],
      [
        0,
        "&ngt;"
      ],
      [
        0,
        "&nle;"
      ],
      [
        0,
        "&nge;"
      ],
      [
        0,
        "&lesssim;"
      ],
      [
        0,
        "&GreaterTilde;"
      ],
      [
        0,
        "&nlsim;"
      ],
      [
        0,
        "&ngsim;"
      ],
      [
        0,
        "&LessGreater;"
      ],
      [
        0,
        "&gl;"
      ],
      [
        0,
        "&NotLessGreater;"
      ],
      [
        0,
        "&NotGreaterLess;"
      ],
      [
        0,
        "&pr;"
      ],
      [
        0,
        "&sc;"
      ],
      [
        0,
        "&prcue;"
      ],
      [
        0,
        "&sccue;"
      ],
      [
        0,
        "&PrecedesTilde;"
      ],
      [
        0,
        {
          v: "&scsim;",
          n: 824,
          o: "&NotSucceedsTilde;"
        }
      ],
      [
        0,
        "&NotPrecedes;"
      ],
      [
        0,
        "&NotSucceeds;"
      ],
      [
        0,
        {
          v: "&sub;",
          n: 8402,
          o: "&NotSubset;"
        }
      ],
      [
        0,
        {
          v: "&sup;",
          n: 8402,
          o: "&NotSuperset;"
        }
      ],
      [
        0,
        "&nsub;"
      ],
      [
        0,
        "&nsup;"
      ],
      [
        0,
        "&sube;"
      ],
      [
        0,
        "&supe;"
      ],
      [
        0,
        "&NotSubsetEqual;"
      ],
      [
        0,
        "&NotSupersetEqual;"
      ],
      [
        0,
        {
          v: "&subne;",
          n: 65024,
          o: "&varsubsetneq;"
        }
      ],
      [
        0,
        {
          v: "&supne;",
          n: 65024,
          o: "&varsupsetneq;"
        }
      ],
      [
        1,
        "&cupdot;"
      ],
      [
        0,
        "&UnionPlus;"
      ],
      [
        0,
        {
          v: "&sqsub;",
          n: 824,
          o: "&NotSquareSubset;"
        }
      ],
      [
        0,
        {
          v: "&sqsup;",
          n: 824,
          o: "&NotSquareSuperset;"
        }
      ],
      [
        0,
        "&sqsube;"
      ],
      [
        0,
        "&sqsupe;"
      ],
      [
        0,
        {
          v: "&sqcap;",
          n: 65024,
          o: "&sqcaps;"
        }
      ],
      [
        0,
        {
          v: "&sqcup;",
          n: 65024,
          o: "&sqcups;"
        }
      ],
      [
        0,
        "&CirclePlus;"
      ],
      [
        0,
        "&CircleMinus;"
      ],
      [
        0,
        "&CircleTimes;"
      ],
      [
        0,
        "&osol;"
      ],
      [
        0,
        "&CircleDot;"
      ],
      [
        0,
        "&circledcirc;"
      ],
      [
        0,
        "&circledast;"
      ],
      [
        1,
        "&circleddash;"
      ],
      [
        0,
        "&boxplus;"
      ],
      [
        0,
        "&boxminus;"
      ],
      [
        0,
        "&boxtimes;"
      ],
      [
        0,
        "&dotsquare;"
      ],
      [
        0,
        "&RightTee;"
      ],
      [
        0,
        "&dashv;"
      ],
      [
        0,
        "&DownTee;"
      ],
      [
        0,
        "&bot;"
      ],
      [
        1,
        "&models;"
      ],
      [
        0,
        "&DoubleRightTee;"
      ],
      [
        0,
        "&Vdash;"
      ],
      [
        0,
        "&Vvdash;"
      ],
      [
        0,
        "&VDash;"
      ],
      [
        0,
        "&nvdash;"
      ],
      [
        0,
        "&nvDash;"
      ],
      [
        0,
        "&nVdash;"
      ],
      [
        0,
        "&nVDash;"
      ],
      [
        0,
        "&prurel;"
      ],
      [
        1,
        "&LeftTriangle;"
      ],
      [
        0,
        "&RightTriangle;"
      ],
      [
        0,
        {
          v: "&LeftTriangleEqual;",
          n: 8402,
          o: "&nvltrie;"
        }
      ],
      [
        0,
        {
          v: "&RightTriangleEqual;",
          n: 8402,
          o: "&nvrtrie;"
        }
      ],
      [
        0,
        "&origof;"
      ],
      [
        0,
        "&imof;"
      ],
      [
        0,
        "&multimap;"
      ],
      [
        0,
        "&hercon;"
      ],
      [
        0,
        "&intcal;"
      ],
      [
        0,
        "&veebar;"
      ],
      [
        1,
        "&barvee;"
      ],
      [
        0,
        "&angrtvb;"
      ],
      [
        0,
        "&lrtri;"
      ],
      [
        0,
        "&bigwedge;"
      ],
      [
        0,
        "&bigvee;"
      ],
      [
        0,
        "&bigcap;"
      ],
      [
        0,
        "&bigcup;"
      ],
      [
        0,
        "&diam;"
      ],
      [
        0,
        "&sdot;"
      ],
      [
        0,
        "&sstarf;"
      ],
      [
        0,
        "&divideontimes;"
      ],
      [
        0,
        "&bowtie;"
      ],
      [
        0,
        "&ltimes;"
      ],
      [
        0,
        "&rtimes;"
      ],
      [
        0,
        "&leftthreetimes;"
      ],
      [
        0,
        "&rightthreetimes;"
      ],
      [
        0,
        "&backsimeq;"
      ],
      [
        0,
        "&curlyvee;"
      ],
      [
        0,
        "&curlywedge;"
      ],
      [
        0,
        "&Sub;"
      ],
      [
        0,
        "&Sup;"
      ],
      [
        0,
        "&Cap;"
      ],
      [
        0,
        "&Cup;"
      ],
      [
        0,
        "&fork;"
      ],
      [
        0,
        "&epar;"
      ],
      [
        0,
        "&lessdot;"
      ],
      [
        0,
        "&gtdot;"
      ],
      [
        0,
        {
          v: "&Ll;",
          n: 824,
          o: "&nLl;"
        }
      ],
      [
        0,
        {
          v: "&Gg;",
          n: 824,
          o: "&nGg;"
        }
      ],
      [
        0,
        {
          v: "&leg;",
          n: 65024,
          o: "&lesg;"
        }
      ],
      [
        0,
        {
          v: "&gel;",
          n: 65024,
          o: "&gesl;"
        }
      ],
      [
        2,
        "&cuepr;"
      ],
      [
        0,
        "&cuesc;"
      ],
      [
        0,
        "&NotPrecedesSlantEqual;"
      ],
      [
        0,
        "&NotSucceedsSlantEqual;"
      ],
      [
        0,
        "&NotSquareSubsetEqual;"
      ],
      [
        0,
        "&NotSquareSupersetEqual;"
      ],
      [
        2,
        "&lnsim;"
      ],
      [
        0,
        "&gnsim;"
      ],
      [
        0,
        "&precnsim;"
      ],
      [
        0,
        "&scnsim;"
      ],
      [
        0,
        "&nltri;"
      ],
      [
        0,
        "&NotRightTriangle;"
      ],
      [
        0,
        "&nltrie;"
      ],
      [
        0,
        "&NotRightTriangleEqual;"
      ],
      [
        0,
        "&vellip;"
      ],
      [
        0,
        "&ctdot;"
      ],
      [
        0,
        "&utdot;"
      ],
      [
        0,
        "&dtdot;"
      ],
      [
        0,
        "&disin;"
      ],
      [
        0,
        "&isinsv;"
      ],
      [
        0,
        "&isins;"
      ],
      [
        0,
        {
          v: "&isindot;",
          n: 824,
          o: "&notindot;"
        }
      ],
      [
        0,
        "&notinvc;"
      ],
      [
        0,
        "&notinvb;"
      ],
      [
        1,
        {
          v: "&isinE;",
          n: 824,
          o: "&notinE;"
        }
      ],
      [
        0,
        "&nisd;"
      ],
      [
        0,
        "&xnis;"
      ],
      [
        0,
        "&nis;"
      ],
      [
        0,
        "&notnivc;"
      ],
      [
        0,
        "&notnivb;"
      ],
      [
        6,
        "&barwed;"
      ],
      [
        0,
        "&Barwed;"
      ],
      [
        1,
        "&lceil;"
      ],
      [
        0,
        "&rceil;"
      ],
      [
        0,
        "&LeftFloor;"
      ],
      [
        0,
        "&rfloor;"
      ],
      [
        0,
        "&drcrop;"
      ],
      [
        0,
        "&dlcrop;"
      ],
      [
        0,
        "&urcrop;"
      ],
      [
        0,
        "&ulcrop;"
      ],
      [
        0,
        "&bnot;"
      ],
      [
        1,
        "&profline;"
      ],
      [
        0,
        "&profsurf;"
      ],
      [
        1,
        "&telrec;"
      ],
      [
        0,
        "&target;"
      ],
      [
        5,
        "&ulcorn;"
      ],
      [
        0,
        "&urcorn;"
      ],
      [
        0,
        "&dlcorn;"
      ],
      [
        0,
        "&drcorn;"
      ],
      [
        2,
        "&frown;"
      ],
      [
        0,
        "&smile;"
      ],
      [
        9,
        "&cylcty;"
      ],
      [
        0,
        "&profalar;"
      ],
      [
        7,
        "&topbot;"
      ],
      [
        6,
        "&ovbar;"
      ],
      [
        1,
        "&solbar;"
      ],
      [
        60,
        "&angzarr;"
      ],
      [
        51,
        "&lmoustache;"
      ],
      [
        0,
        "&rmoustache;"
      ],
      [
        2,
        "&OverBracket;"
      ],
      [
        0,
        "&bbrk;"
      ],
      [
        0,
        "&bbrktbrk;"
      ],
      [
        37,
        "&OverParenthesis;"
      ],
      [
        0,
        "&UnderParenthesis;"
      ],
      [
        0,
        "&OverBrace;"
      ],
      [
        0,
        "&UnderBrace;"
      ],
      [
        2,
        "&trpezium;"
      ],
      [
        4,
        "&elinters;"
      ],
      [
        59,
        "&blank;"
      ],
      [
        164,
        "&circledS;"
      ],
      [
        55,
        "&boxh;"
      ],
      [
        1,
        "&boxv;"
      ],
      [
        9,
        "&boxdr;"
      ],
      [
        3,
        "&boxdl;"
      ],
      [
        3,
        "&boxur;"
      ],
      [
        3,
        "&boxul;"
      ],
      [
        3,
        "&boxvr;"
      ],
      [
        7,
        "&boxvl;"
      ],
      [
        7,
        "&boxhd;"
      ],
      [
        7,
        "&boxhu;"
      ],
      [
        7,
        "&boxvh;"
      ],
      [
        19,
        "&boxH;"
      ],
      [
        0,
        "&boxV;"
      ],
      [
        0,
        "&boxdR;"
      ],
      [
        0,
        "&boxDr;"
      ],
      [
        0,
        "&boxDR;"
      ],
      [
        0,
        "&boxdL;"
      ],
      [
        0,
        "&boxDl;"
      ],
      [
        0,
        "&boxDL;"
      ],
      [
        0,
        "&boxuR;"
      ],
      [
        0,
        "&boxUr;"
      ],
      [
        0,
        "&boxUR;"
      ],
      [
        0,
        "&boxuL;"
      ],
      [
        0,
        "&boxUl;"
      ],
      [
        0,
        "&boxUL;"
      ],
      [
        0,
        "&boxvR;"
      ],
      [
        0,
        "&boxVr;"
      ],
      [
        0,
        "&boxVR;"
      ],
      [
        0,
        "&boxvL;"
      ],
      [
        0,
        "&boxVl;"
      ],
      [
        0,
        "&boxVL;"
      ],
      [
        0,
        "&boxHd;"
      ],
      [
        0,
        "&boxhD;"
      ],
      [
        0,
        "&boxHD;"
      ],
      [
        0,
        "&boxHu;"
      ],
      [
        0,
        "&boxhU;"
      ],
      [
        0,
        "&boxHU;"
      ],
      [
        0,
        "&boxvH;"
      ],
      [
        0,
        "&boxVh;"
      ],
      [
        0,
        "&boxVH;"
      ],
      [
        19,
        "&uhblk;"
      ],
      [
        3,
        "&lhblk;"
      ],
      [
        3,
        "&block;"
      ],
      [
        8,
        "&blk14;"
      ],
      [
        0,
        "&blk12;"
      ],
      [
        0,
        "&blk34;"
      ],
      [
        13,
        "&square;"
      ],
      [
        8,
        "&blacksquare;"
      ],
      [
        0,
        "&EmptyVerySmallSquare;"
      ],
      [
        1,
        "&rect;"
      ],
      [
        0,
        "&marker;"
      ],
      [
        2,
        "&fltns;"
      ],
      [
        1,
        "&bigtriangleup;"
      ],
      [
        0,
        "&blacktriangle;"
      ],
      [
        0,
        "&triangle;"
      ],
      [
        2,
        "&blacktriangleright;"
      ],
      [
        0,
        "&rtri;"
      ],
      [
        3,
        "&bigtriangledown;"
      ],
      [
        0,
        "&blacktriangledown;"
      ],
      [
        0,
        "&dtri;"
      ],
      [
        2,
        "&blacktriangleleft;"
      ],
      [
        0,
        "&ltri;"
      ],
      [
        6,
        "&loz;"
      ],
      [
        0,
        "&cir;"
      ],
      [
        32,
        "&tridot;"
      ],
      [
        2,
        "&bigcirc;"
      ],
      [
        8,
        "&ultri;"
      ],
      [
        0,
        "&urtri;"
      ],
      [
        0,
        "&lltri;"
      ],
      [
        0,
        "&EmptySmallSquare;"
      ],
      [
        0,
        "&FilledSmallSquare;"
      ],
      [
        8,
        "&bigstar;"
      ],
      [
        0,
        "&star;"
      ],
      [
        7,
        "&phone;"
      ],
      [
        49,
        "&female;"
      ],
      [
        1,
        "&male;"
      ],
      [
        29,
        "&spades;"
      ],
      [
        2,
        "&clubs;"
      ],
      [
        1,
        "&hearts;"
      ],
      [
        0,
        "&diamondsuit;"
      ],
      [
        3,
        "&sung;"
      ],
      [
        2,
        "&flat;"
      ],
      [
        0,
        "&natural;"
      ],
      [
        0,
        "&sharp;"
      ],
      [
        163,
        "&check;"
      ],
      [
        3,
        "&cross;"
      ],
      [
        8,
        "&malt;"
      ],
      [
        21,
        "&sext;"
      ],
      [
        33,
        "&VerticalSeparator;"
      ],
      [
        25,
        "&lbbrk;"
      ],
      [
        0,
        "&rbbrk;"
      ],
      [
        84,
        "&bsolhsub;"
      ],
      [
        0,
        "&suphsol;"
      ],
      [
        28,
        "&LeftDoubleBracket;"
      ],
      [
        0,
        "&RightDoubleBracket;"
      ],
      [
        0,
        "&lang;"
      ],
      [
        0,
        "&rang;"
      ],
      [
        0,
        "&Lang;"
      ],
      [
        0,
        "&Rang;"
      ],
      [
        0,
        "&loang;"
      ],
      [
        0,
        "&roang;"
      ],
      [
        7,
        "&longleftarrow;"
      ],
      [
        0,
        "&longrightarrow;"
      ],
      [
        0,
        "&longleftrightarrow;"
      ],
      [
        0,
        "&DoubleLongLeftArrow;"
      ],
      [
        0,
        "&DoubleLongRightArrow;"
      ],
      [
        0,
        "&DoubleLongLeftRightArrow;"
      ],
      [
        1,
        "&longmapsto;"
      ],
      [
        2,
        "&dzigrarr;"
      ],
      [
        258,
        "&nvlArr;"
      ],
      [
        0,
        "&nvrArr;"
      ],
      [
        0,
        "&nvHarr;"
      ],
      [
        0,
        "&Map;"
      ],
      [
        6,
        "&lbarr;"
      ],
      [
        0,
        "&bkarow;"
      ],
      [
        0,
        "&lBarr;"
      ],
      [
        0,
        "&dbkarow;"
      ],
      [
        0,
        "&drbkarow;"
      ],
      [
        0,
        "&DDotrahd;"
      ],
      [
        0,
        "&UpArrowBar;"
      ],
      [
        0,
        "&DownArrowBar;"
      ],
      [
        2,
        "&Rarrtl;"
      ],
      [
        2,
        "&latail;"
      ],
      [
        0,
        "&ratail;"
      ],
      [
        0,
        "&lAtail;"
      ],
      [
        0,
        "&rAtail;"
      ],
      [
        0,
        "&larrfs;"
      ],
      [
        0,
        "&rarrfs;"
      ],
      [
        0,
        "&larrbfs;"
      ],
      [
        0,
        "&rarrbfs;"
      ],
      [
        2,
        "&nwarhk;"
      ],
      [
        0,
        "&nearhk;"
      ],
      [
        0,
        "&hksearow;"
      ],
      [
        0,
        "&hkswarow;"
      ],
      [
        0,
        "&nwnear;"
      ],
      [
        0,
        "&nesear;"
      ],
      [
        0,
        "&seswar;"
      ],
      [
        0,
        "&swnwar;"
      ],
      [
        8,
        {
          v: "&rarrc;",
          n: 824,
          o: "&nrarrc;"
        }
      ],
      [
        1,
        "&cudarrr;"
      ],
      [
        0,
        "&ldca;"
      ],
      [
        0,
        "&rdca;"
      ],
      [
        0,
        "&cudarrl;"
      ],
      [
        0,
        "&larrpl;"
      ],
      [
        2,
        "&curarrm;"
      ],
      [
        0,
        "&cularrp;"
      ],
      [
        7,
        "&rarrpl;"
      ],
      [
        2,
        "&harrcir;"
      ],
      [
        0,
        "&Uarrocir;"
      ],
      [
        0,
        "&lurdshar;"
      ],
      [
        0,
        "&ldrushar;"
      ],
      [
        2,
        "&LeftRightVector;"
      ],
      [
        0,
        "&RightUpDownVector;"
      ],
      [
        0,
        "&DownLeftRightVector;"
      ],
      [
        0,
        "&LeftUpDownVector;"
      ],
      [
        0,
        "&LeftVectorBar;"
      ],
      [
        0,
        "&RightVectorBar;"
      ],
      [
        0,
        "&RightUpVectorBar;"
      ],
      [
        0,
        "&RightDownVectorBar;"
      ],
      [
        0,
        "&DownLeftVectorBar;"
      ],
      [
        0,
        "&DownRightVectorBar;"
      ],
      [
        0,
        "&LeftUpVectorBar;"
      ],
      [
        0,
        "&LeftDownVectorBar;"
      ],
      [
        0,
        "&LeftTeeVector;"
      ],
      [
        0,
        "&RightTeeVector;"
      ],
      [
        0,
        "&RightUpTeeVector;"
      ],
      [
        0,
        "&RightDownTeeVector;"
      ],
      [
        0,
        "&DownLeftTeeVector;"
      ],
      [
        0,
        "&DownRightTeeVector;"
      ],
      [
        0,
        "&LeftUpTeeVector;"
      ],
      [
        0,
        "&LeftDownTeeVector;"
      ],
      [
        0,
        "&lHar;"
      ],
      [
        0,
        "&uHar;"
      ],
      [
        0,
        "&rHar;"
      ],
      [
        0,
        "&dHar;"
      ],
      [
        0,
        "&luruhar;"
      ],
      [
        0,
        "&ldrdhar;"
      ],
      [
        0,
        "&ruluhar;"
      ],
      [
        0,
        "&rdldhar;"
      ],
      [
        0,
        "&lharul;"
      ],
      [
        0,
        "&llhard;"
      ],
      [
        0,
        "&rharul;"
      ],
      [
        0,
        "&lrhard;"
      ],
      [
        0,
        "&udhar;"
      ],
      [
        0,
        "&duhar;"
      ],
      [
        0,
        "&RoundImplies;"
      ],
      [
        0,
        "&erarr;"
      ],
      [
        0,
        "&simrarr;"
      ],
      [
        0,
        "&larrsim;"
      ],
      [
        0,
        "&rarrsim;"
      ],
      [
        0,
        "&rarrap;"
      ],
      [
        0,
        "&ltlarr;"
      ],
      [
        1,
        "&gtrarr;"
      ],
      [
        0,
        "&subrarr;"
      ],
      [
        1,
        "&suplarr;"
      ],
      [
        0,
        "&lfisht;"
      ],
      [
        0,
        "&rfisht;"
      ],
      [
        0,
        "&ufisht;"
      ],
      [
        0,
        "&dfisht;"
      ],
      [
        5,
        "&lopar;"
      ],
      [
        0,
        "&ropar;"
      ],
      [
        4,
        "&lbrke;"
      ],
      [
        0,
        "&rbrke;"
      ],
      [
        0,
        "&lbrkslu;"
      ],
      [
        0,
        "&rbrksld;"
      ],
      [
        0,
        "&lbrksld;"
      ],
      [
        0,
        "&rbrkslu;"
      ],
      [
        0,
        "&langd;"
      ],
      [
        0,
        "&rangd;"
      ],
      [
        0,
        "&lparlt;"
      ],
      [
        0,
        "&rpargt;"
      ],
      [
        0,
        "&gtlPar;"
      ],
      [
        0,
        "&ltrPar;"
      ],
      [
        3,
        "&vzigzag;"
      ],
      [
        1,
        "&vangrt;"
      ],
      [
        0,
        "&angrtvbd;"
      ],
      [
        6,
        "&ange;"
      ],
      [
        0,
        "&range;"
      ],
      [
        0,
        "&dwangle;"
      ],
      [
        0,
        "&uwangle;"
      ],
      [
        0,
        "&angmsdaa;"
      ],
      [
        0,
        "&angmsdab;"
      ],
      [
        0,
        "&angmsdac;"
      ],
      [
        0,
        "&angmsdad;"
      ],
      [
        0,
        "&angmsdae;"
      ],
      [
        0,
        "&angmsdaf;"
      ],
      [
        0,
        "&angmsdag;"
      ],
      [
        0,
        "&angmsdah;"
      ],
      [
        0,
        "&bemptyv;"
      ],
      [
        0,
        "&demptyv;"
      ],
      [
        0,
        "&cemptyv;"
      ],
      [
        0,
        "&raemptyv;"
      ],
      [
        0,
        "&laemptyv;"
      ],
      [
        0,
        "&ohbar;"
      ],
      [
        0,
        "&omid;"
      ],
      [
        0,
        "&opar;"
      ],
      [
        1,
        "&operp;"
      ],
      [
        1,
        "&olcross;"
      ],
      [
        0,
        "&odsold;"
      ],
      [
        1,
        "&olcir;"
      ],
      [
        0,
        "&ofcir;"
      ],
      [
        0,
        "&olt;"
      ],
      [
        0,
        "&ogt;"
      ],
      [
        0,
        "&cirscir;"
      ],
      [
        0,
        "&cirE;"
      ],
      [
        0,
        "&solb;"
      ],
      [
        0,
        "&bsolb;"
      ],
      [
        3,
        "&boxbox;"
      ],
      [
        3,
        "&trisb;"
      ],
      [
        0,
        "&rtriltri;"
      ],
      [
        0,
        {
          v: "&LeftTriangleBar;",
          n: 824,
          o: "&NotLeftTriangleBar;"
        }
      ],
      [
        0,
        {
          v: "&RightTriangleBar;",
          n: 824,
          o: "&NotRightTriangleBar;"
        }
      ],
      [
        11,
        "&iinfin;"
      ],
      [
        0,
        "&infintie;"
      ],
      [
        0,
        "&nvinfin;"
      ],
      [
        4,
        "&eparsl;"
      ],
      [
        0,
        "&smeparsl;"
      ],
      [
        0,
        "&eqvparsl;"
      ],
      [
        5,
        "&blacklozenge;"
      ],
      [
        8,
        "&RuleDelayed;"
      ],
      [
        1,
        "&dsol;"
      ],
      [
        9,
        "&bigodot;"
      ],
      [
        0,
        "&bigoplus;"
      ],
      [
        0,
        "&bigotimes;"
      ],
      [
        1,
        "&biguplus;"
      ],
      [
        1,
        "&bigsqcup;"
      ],
      [
        5,
        "&iiiint;"
      ],
      [
        0,
        "&fpartint;"
      ],
      [
        2,
        "&cirfnint;"
      ],
      [
        0,
        "&awint;"
      ],
      [
        0,
        "&rppolint;"
      ],
      [
        0,
        "&scpolint;"
      ],
      [
        0,
        "&npolint;"
      ],
      [
        0,
        "&pointint;"
      ],
      [
        0,
        "&quatint;"
      ],
      [
        0,
        "&intlarhk;"
      ],
      [
        10,
        "&pluscir;"
      ],
      [
        0,
        "&plusacir;"
      ],
      [
        0,
        "&simplus;"
      ],
      [
        0,
        "&plusdu;"
      ],
      [
        0,
        "&plussim;"
      ],
      [
        0,
        "&plustwo;"
      ],
      [
        1,
        "&mcomma;"
      ],
      [
        0,
        "&minusdu;"
      ],
      [
        2,
        "&loplus;"
      ],
      [
        0,
        "&roplus;"
      ],
      [
        0,
        "&Cross;"
      ],
      [
        0,
        "&timesd;"
      ],
      [
        0,
        "&timesbar;"
      ],
      [
        1,
        "&smashp;"
      ],
      [
        0,
        "&lotimes;"
      ],
      [
        0,
        "&rotimes;"
      ],
      [
        0,
        "&otimesas;"
      ],
      [
        0,
        "&Otimes;"
      ],
      [
        0,
        "&odiv;"
      ],
      [
        0,
        "&triplus;"
      ],
      [
        0,
        "&triminus;"
      ],
      [
        0,
        "&tritime;"
      ],
      [
        0,
        "&intprod;"
      ],
      [
        2,
        "&amalg;"
      ],
      [
        0,
        "&capdot;"
      ],
      [
        1,
        "&ncup;"
      ],
      [
        0,
        "&ncap;"
      ],
      [
        0,
        "&capand;"
      ],
      [
        0,
        "&cupor;"
      ],
      [
        0,
        "&cupcap;"
      ],
      [
        0,
        "&capcup;"
      ],
      [
        0,
        "&cupbrcap;"
      ],
      [
        0,
        "&capbrcup;"
      ],
      [
        0,
        "&cupcup;"
      ],
      [
        0,
        "&capcap;"
      ],
      [
        0,
        "&ccups;"
      ],
      [
        0,
        "&ccaps;"
      ],
      [
        2,
        "&ccupssm;"
      ],
      [
        2,
        "&And;"
      ],
      [
        0,
        "&Or;"
      ],
      [
        0,
        "&andand;"
      ],
      [
        0,
        "&oror;"
      ],
      [
        0,
        "&orslope;"
      ],
      [
        0,
        "&andslope;"
      ],
      [
        1,
        "&andv;"
      ],
      [
        0,
        "&orv;"
      ],
      [
        0,
        "&andd;"
      ],
      [
        0,
        "&ord;"
      ],
      [
        1,
        "&wedbar;"
      ],
      [
        6,
        "&sdote;"
      ],
      [
        3,
        "&simdot;"
      ],
      [
        2,
        {
          v: "&congdot;",
          n: 824,
          o: "&ncongdot;"
        }
      ],
      [
        0,
        "&easter;"
      ],
      [
        0,
        "&apacir;"
      ],
      [
        0,
        {
          v: "&apE;",
          n: 824,
          o: "&napE;"
        }
      ],
      [
        0,
        "&eplus;"
      ],
      [
        0,
        "&pluse;"
      ],
      [
        0,
        "&Esim;"
      ],
      [
        0,
        "&Colone;"
      ],
      [
        0,
        "&Equal;"
      ],
      [
        1,
        "&ddotseq;"
      ],
      [
        0,
        "&equivDD;"
      ],
      [
        0,
        "&ltcir;"
      ],
      [
        0,
        "&gtcir;"
      ],
      [
        0,
        "&ltquest;"
      ],
      [
        0,
        "&gtquest;"
      ],
      [
        0,
        {
          v: "&leqslant;",
          n: 824,
          o: "&nleqslant;"
        }
      ],
      [
        0,
        {
          v: "&geqslant;",
          n: 824,
          o: "&ngeqslant;"
        }
      ],
      [
        0,
        "&lesdot;"
      ],
      [
        0,
        "&gesdot;"
      ],
      [
        0,
        "&lesdoto;"
      ],
      [
        0,
        "&gesdoto;"
      ],
      [
        0,
        "&lesdotor;"
      ],
      [
        0,
        "&gesdotol;"
      ],
      [
        0,
        "&lap;"
      ],
      [
        0,
        "&gap;"
      ],
      [
        0,
        "&lne;"
      ],
      [
        0,
        "&gne;"
      ],
      [
        0,
        "&lnap;"
      ],
      [
        0,
        "&gnap;"
      ],
      [
        0,
        "&lEg;"
      ],
      [
        0,
        "&gEl;"
      ],
      [
        0,
        "&lsime;"
      ],
      [
        0,
        "&gsime;"
      ],
      [
        0,
        "&lsimg;"
      ],
      [
        0,
        "&gsiml;"
      ],
      [
        0,
        "&lgE;"
      ],
      [
        0,
        "&glE;"
      ],
      [
        0,
        "&lesges;"
      ],
      [
        0,
        "&gesles;"
      ],
      [
        0,
        "&els;"
      ],
      [
        0,
        "&egs;"
      ],
      [
        0,
        "&elsdot;"
      ],
      [
        0,
        "&egsdot;"
      ],
      [
        0,
        "&el;"
      ],
      [
        0,
        "&eg;"
      ],
      [
        2,
        "&siml;"
      ],
      [
        0,
        "&simg;"
      ],
      [
        0,
        "&simlE;"
      ],
      [
        0,
        "&simgE;"
      ],
      [
        0,
        {
          v: "&LessLess;",
          n: 824,
          o: "&NotNestedLessLess;"
        }
      ],
      [
        0,
        {
          v: "&GreaterGreater;",
          n: 824,
          o: "&NotNestedGreaterGreater;"
        }
      ],
      [
        1,
        "&glj;"
      ],
      [
        0,
        "&gla;"
      ],
      [
        0,
        "&ltcc;"
      ],
      [
        0,
        "&gtcc;"
      ],
      [
        0,
        "&lescc;"
      ],
      [
        0,
        "&gescc;"
      ],
      [
        0,
        "&smt;"
      ],
      [
        0,
        "&lat;"
      ],
      [
        0,
        {
          v: "&smte;",
          n: 65024,
          o: "&smtes;"
        }
      ],
      [
        0,
        {
          v: "&late;",
          n: 65024,
          o: "&lates;"
        }
      ],
      [
        0,
        "&bumpE;"
      ],
      [
        0,
        {
          v: "&PrecedesEqual;",
          n: 824,
          o: "&NotPrecedesEqual;"
        }
      ],
      [
        0,
        {
          v: "&sce;",
          n: 824,
          o: "&NotSucceedsEqual;"
        }
      ],
      [
        2,
        "&prE;"
      ],
      [
        0,
        "&scE;"
      ],
      [
        0,
        "&precneqq;"
      ],
      [
        0,
        "&scnE;"
      ],
      [
        0,
        "&prap;"
      ],
      [
        0,
        "&scap;"
      ],
      [
        0,
        "&precnapprox;"
      ],
      [
        0,
        "&scnap;"
      ],
      [
        0,
        "&Pr;"
      ],
      [
        0,
        "&Sc;"
      ],
      [
        0,
        "&subdot;"
      ],
      [
        0,
        "&supdot;"
      ],
      [
        0,
        "&subplus;"
      ],
      [
        0,
        "&supplus;"
      ],
      [
        0,
        "&submult;"
      ],
      [
        0,
        "&supmult;"
      ],
      [
        0,
        "&subedot;"
      ],
      [
        0,
        "&supedot;"
      ],
      [
        0,
        {
          v: "&subE;",
          n: 824,
          o: "&nsubE;"
        }
      ],
      [
        0,
        {
          v: "&supE;",
          n: 824,
          o: "&nsupE;"
        }
      ],
      [
        0,
        "&subsim;"
      ],
      [
        0,
        "&supsim;"
      ],
      [
        2,
        {
          v: "&subnE;",
          n: 65024,
          o: "&varsubsetneqq;"
        }
      ],
      [
        0,
        {
          v: "&supnE;",
          n: 65024,
          o: "&varsupsetneqq;"
        }
      ],
      [
        2,
        "&csub;"
      ],
      [
        0,
        "&csup;"
      ],
      [
        0,
        "&csube;"
      ],
      [
        0,
        "&csupe;"
      ],
      [
        0,
        "&subsup;"
      ],
      [
        0,
        "&supsub;"
      ],
      [
        0,
        "&subsub;"
      ],
      [
        0,
        "&supsup;"
      ],
      [
        0,
        "&suphsub;"
      ],
      [
        0,
        "&supdsub;"
      ],
      [
        0,
        "&forkv;"
      ],
      [
        0,
        "&topfork;"
      ],
      [
        0,
        "&mlcp;"
      ],
      [
        8,
        "&Dashv;"
      ],
      [
        1,
        "&Vdashl;"
      ],
      [
        0,
        "&Barv;"
      ],
      [
        0,
        "&vBar;"
      ],
      [
        0,
        "&vBarv;"
      ],
      [
        1,
        "&Vbar;"
      ],
      [
        0,
        "&Not;"
      ],
      [
        0,
        "&bNot;"
      ],
      [
        0,
        "&rnmid;"
      ],
      [
        0,
        "&cirmid;"
      ],
      [
        0,
        "&midcir;"
      ],
      [
        0,
        "&topcir;"
      ],
      [
        0,
        "&nhpar;"
      ],
      [
        0,
        "&parsim;"
      ],
      [
        9,
        {
          v: "&parsl;",
          n: 8421,
          o: "&nparsl;"
        }
      ],
      [
        44343,
        {
          n: new Map(n([
            [
              56476,
              "&Ascr;"
            ],
            [
              1,
              "&Cscr;"
            ],
            [
              0,
              "&Dscr;"
            ],
            [
              2,
              "&Gscr;"
            ],
            [
              2,
              "&Jscr;"
            ],
            [
              0,
              "&Kscr;"
            ],
            [
              2,
              "&Nscr;"
            ],
            [
              0,
              "&Oscr;"
            ],
            [
              0,
              "&Pscr;"
            ],
            [
              0,
              "&Qscr;"
            ],
            [
              1,
              "&Sscr;"
            ],
            [
              0,
              "&Tscr;"
            ],
            [
              0,
              "&Uscr;"
            ],
            [
              0,
              "&Vscr;"
            ],
            [
              0,
              "&Wscr;"
            ],
            [
              0,
              "&Xscr;"
            ],
            [
              0,
              "&Yscr;"
            ],
            [
              0,
              "&Zscr;"
            ],
            [
              0,
              "&ascr;"
            ],
            [
              0,
              "&bscr;"
            ],
            [
              0,
              "&cscr;"
            ],
            [
              0,
              "&dscr;"
            ],
            [
              1,
              "&fscr;"
            ],
            [
              1,
              "&hscr;"
            ],
            [
              0,
              "&iscr;"
            ],
            [
              0,
              "&jscr;"
            ],
            [
              0,
              "&kscr;"
            ],
            [
              0,
              "&lscr;"
            ],
            [
              0,
              "&mscr;"
            ],
            [
              0,
              "&nscr;"
            ],
            [
              1,
              "&pscr;"
            ],
            [
              0,
              "&qscr;"
            ],
            [
              0,
              "&rscr;"
            ],
            [
              0,
              "&sscr;"
            ],
            [
              0,
              "&tscr;"
            ],
            [
              0,
              "&uscr;"
            ],
            [
              0,
              "&vscr;"
            ],
            [
              0,
              "&wscr;"
            ],
            [
              0,
              "&xscr;"
            ],
            [
              0,
              "&yscr;"
            ],
            [
              0,
              "&zscr;"
            ],
            [
              52,
              "&Afr;"
            ],
            [
              0,
              "&Bfr;"
            ],
            [
              1,
              "&Dfr;"
            ],
            [
              0,
              "&Efr;"
            ],
            [
              0,
              "&Ffr;"
            ],
            [
              0,
              "&Gfr;"
            ],
            [
              2,
              "&Jfr;"
            ],
            [
              0,
              "&Kfr;"
            ],
            [
              0,
              "&Lfr;"
            ],
            [
              0,
              "&Mfr;"
            ],
            [
              0,
              "&Nfr;"
            ],
            [
              0,
              "&Ofr;"
            ],
            [
              0,
              "&Pfr;"
            ],
            [
              0,
              "&Qfr;"
            ],
            [
              1,
              "&Sfr;"
            ],
            [
              0,
              "&Tfr;"
            ],
            [
              0,
              "&Ufr;"
            ],
            [
              0,
              "&Vfr;"
            ],
            [
              0,
              "&Wfr;"
            ],
            [
              0,
              "&Xfr;"
            ],
            [
              0,
              "&Yfr;"
            ],
            [
              1,
              "&afr;"
            ],
            [
              0,
              "&bfr;"
            ],
            [
              0,
              "&cfr;"
            ],
            [
              0,
              "&dfr;"
            ],
            [
              0,
              "&efr;"
            ],
            [
              0,
              "&ffr;"
            ],
            [
              0,
              "&gfr;"
            ],
            [
              0,
              "&hfr;"
            ],
            [
              0,
              "&ifr;"
            ],
            [
              0,
              "&jfr;"
            ],
            [
              0,
              "&kfr;"
            ],
            [
              0,
              "&lfr;"
            ],
            [
              0,
              "&mfr;"
            ],
            [
              0,
              "&nfr;"
            ],
            [
              0,
              "&ofr;"
            ],
            [
              0,
              "&pfr;"
            ],
            [
              0,
              "&qfr;"
            ],
            [
              0,
              "&rfr;"
            ],
            [
              0,
              "&sfr;"
            ],
            [
              0,
              "&tfr;"
            ],
            [
              0,
              "&ufr;"
            ],
            [
              0,
              "&vfr;"
            ],
            [
              0,
              "&wfr;"
            ],
            [
              0,
              "&xfr;"
            ],
            [
              0,
              "&yfr;"
            ],
            [
              0,
              "&zfr;"
            ],
            [
              0,
              "&Aopf;"
            ],
            [
              0,
              "&Bopf;"
            ],
            [
              1,
              "&Dopf;"
            ],
            [
              0,
              "&Eopf;"
            ],
            [
              0,
              "&Fopf;"
            ],
            [
              0,
              "&Gopf;"
            ],
            [
              1,
              "&Iopf;"
            ],
            [
              0,
              "&Jopf;"
            ],
            [
              0,
              "&Kopf;"
            ],
            [
              0,
              "&Lopf;"
            ],
            [
              0,
              "&Mopf;"
            ],
            [
              1,
              "&Oopf;"
            ],
            [
              3,
              "&Sopf;"
            ],
            [
              0,
              "&Topf;"
            ],
            [
              0,
              "&Uopf;"
            ],
            [
              0,
              "&Vopf;"
            ],
            [
              0,
              "&Wopf;"
            ],
            [
              0,
              "&Xopf;"
            ],
            [
              0,
              "&Yopf;"
            ],
            [
              1,
              "&aopf;"
            ],
            [
              0,
              "&bopf;"
            ],
            [
              0,
              "&copf;"
            ],
            [
              0,
              "&dopf;"
            ],
            [
              0,
              "&eopf;"
            ],
            [
              0,
              "&fopf;"
            ],
            [
              0,
              "&gopf;"
            ],
            [
              0,
              "&hopf;"
            ],
            [
              0,
              "&iopf;"
            ],
            [
              0,
              "&jopf;"
            ],
            [
              0,
              "&kopf;"
            ],
            [
              0,
              "&lopf;"
            ],
            [
              0,
              "&mopf;"
            ],
            [
              0,
              "&nopf;"
            ],
            [
              0,
              "&oopf;"
            ],
            [
              0,
              "&popf;"
            ],
            [
              0,
              "&qopf;"
            ],
            [
              0,
              "&ropf;"
            ],
            [
              0,
              "&sopf;"
            ],
            [
              0,
              "&topf;"
            ],
            [
              0,
              "&uopf;"
            ],
            [
              0,
              "&vopf;"
            ],
            [
              0,
              "&wopf;"
            ],
            [
              0,
              "&xopf;"
            ],
            [
              0,
              "&yopf;"
            ],
            [
              0,
              "&zopf;"
            ]
          ]))
        }
      ],
      [
        8906,
        "&fflig;"
      ],
      [
        0,
        "&filig;"
      ],
      [
        0,
        "&fllig;"
      ],
      [
        0,
        "&ffilig;"
      ],
      [
        0,
        "&ffllig;"
      ]
    ])), ks;
  }
  var Ia = {}, Wd;
  function Ku() {
    return Wd || (Wd = 1, function(n) {
      Object.defineProperty(n, "__esModule", {
        value: true
      }), n.escapeText = n.escapeAttribute = n.escapeUTF8 = n.escape = n.encodeXML = n.getCodePoint = n.xmlReplacer = void 0, n.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
      var e = /* @__PURE__ */ new Map([
        [
          34,
          "&quot;"
        ],
        [
          38,
          "&amp;"
        ],
        [
          39,
          "&apos;"
        ],
        [
          60,
          "&lt;"
        ],
        [
          62,
          "&gt;"
        ]
      ]);
      n.getCodePoint = String.prototype.codePointAt != null ? function(i, s) {
        return i.codePointAt(s);
      } : function(i, s) {
        return (i.charCodeAt(s) & 64512) === 55296 ? (i.charCodeAt(s) - 55296) * 1024 + i.charCodeAt(s + 1) - 56320 + 65536 : i.charCodeAt(s);
      };
      function t(i) {
        for (var s = "", o = 0, a; (a = n.xmlReplacer.exec(i)) !== null; ) {
          var u = a.index, l = i.charCodeAt(u), c = e.get(l);
          c !== void 0 ? (s += i.substring(o, u) + c, o = u + 1) : (s += "".concat(i.substring(o, u), "&#x").concat((0, n.getCodePoint)(i, u).toString(16), ";"), o = n.xmlReplacer.lastIndex += +((l & 64512) === 55296));
        }
        return s + i.substr(o);
      }
      n.encodeXML = t, n.escape = t;
      function r(i, s) {
        return function(a) {
          for (var u, l = 0, c = ""; u = i.exec(a); ) l !== u.index && (c += a.substring(l, u.index)), c += s.get(u[0].charCodeAt(0)), l = u.index + 1;
          return c + a.substring(l);
        };
      }
      n.escapeUTF8 = r(/[&<>'"]/g, e), n.escapeAttribute = r(/["&\u00A0]/g, /* @__PURE__ */ new Map([
        [
          34,
          "&quot;"
        ],
        [
          38,
          "&amp;"
        ],
        [
          160,
          "&nbsp;"
        ]
      ])), n.escapeText = r(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
        [
          38,
          "&amp;"
        ],
        [
          60,
          "&lt;"
        ],
        [
          62,
          "&gt;"
        ],
        [
          160,
          "&nbsp;"
        ]
      ]));
    }(Ia)), Ia;
  }
  var Ud;
  function Gd() {
    if (Ud) return Dn;
    Ud = 1;
    var n = Dn && Dn.__importDefault || function(a) {
      return a && a.__esModule ? a : {
        default: a
      };
    };
    Object.defineProperty(Dn, "__esModule", {
      value: true
    }), Dn.encodeNonAsciiHTML = Dn.encodeHTML = void 0;
    var e = n(Dk()), t = Ku(), r = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
    function i(a) {
      return o(r, a);
    }
    Dn.encodeHTML = i;
    function s(a) {
      return o(t.xmlReplacer, a);
    }
    Dn.encodeNonAsciiHTML = s;
    function o(a, u) {
      for (var l = "", c = 0, h; (h = a.exec(u)) !== null; ) {
        var d = h.index;
        l += u.substring(c, d);
        var f = u.charCodeAt(d), p = e.default.get(f);
        if (typeof p == "object") {
          if (d + 1 < u.length) {
            var m = u.charCodeAt(d + 1), b = typeof p.n == "number" ? p.n === m ? p.o : void 0 : p.n.get(m);
            if (b !== void 0) {
              l += b, c = a.lastIndex += 1;
              continue;
            }
          }
          p = p.v;
        }
        if (p !== void 0) l += p, c = d + 1;
        else {
          var g = (0, t.getCodePoint)(u, d);
          l += "&#x".concat(g.toString(16), ";"), c = a.lastIndex += +(g !== f);
        }
      }
      return l + u.substr(c);
    }
    return Dn;
  }
  var Kd;
  function Ik() {
    return Kd || (Kd = 1, function(n) {
      Object.defineProperty(n, "__esModule", {
        value: true
      }), n.decodeXMLStrict = n.decodeHTML5Strict = n.decodeHTML4Strict = n.decodeHTML5 = n.decodeHTML4 = n.decodeHTMLAttribute = n.decodeHTMLStrict = n.decodeHTML = n.decodeXML = n.DecodingMode = n.EntityDecoder = n.encodeHTML5 = n.encodeHTML4 = n.encodeNonAsciiHTML = n.encodeHTML = n.escapeText = n.escapeAttribute = n.escapeUTF8 = n.escape = n.encodeXML = n.encode = n.decodeStrict = n.decode = n.EncodingMode = n.EntityLevel = void 0;
      var e = mo(), t = Gd(), r = Ku(), i;
      (function(d) {
        d[d.XML = 0] = "XML", d[d.HTML = 1] = "HTML";
      })(i = n.EntityLevel || (n.EntityLevel = {}));
      var s;
      (function(d) {
        d[d.UTF8 = 0] = "UTF8", d[d.ASCII = 1] = "ASCII", d[d.Extensive = 2] = "Extensive", d[d.Attribute = 3] = "Attribute", d[d.Text = 4] = "Text";
      })(s = n.EncodingMode || (n.EncodingMode = {}));
      function o(d, f) {
        f === void 0 && (f = i.XML);
        var p = typeof f == "number" ? f : f.level;
        if (p === i.HTML) {
          var m = typeof f == "object" ? f.mode : void 0;
          return (0, e.decodeHTML)(d, m);
        }
        return (0, e.decodeXML)(d);
      }
      n.decode = o;
      function a(d, f) {
        var p;
        f === void 0 && (f = i.XML);
        var m = typeof f == "number" ? {
          level: f
        } : f;
        return (p = m.mode) !== null && p !== void 0 || (m.mode = e.DecodingMode.Strict), o(d, m);
      }
      n.decodeStrict = a;
      function u(d, f) {
        f === void 0 && (f = i.XML);
        var p = typeof f == "number" ? {
          level: f
        } : f;
        return p.mode === s.UTF8 ? (0, r.escapeUTF8)(d) : p.mode === s.Attribute ? (0, r.escapeAttribute)(d) : p.mode === s.Text ? (0, r.escapeText)(d) : p.level === i.HTML ? p.mode === s.ASCII ? (0, t.encodeNonAsciiHTML)(d) : (0, t.encodeHTML)(d) : (0, r.encodeXML)(d);
      }
      n.encode = u;
      var l = Ku();
      Object.defineProperty(n, "encodeXML", {
        enumerable: true,
        get: function() {
          return l.encodeXML;
        }
      }), Object.defineProperty(n, "escape", {
        enumerable: true,
        get: function() {
          return l.escape;
        }
      }), Object.defineProperty(n, "escapeUTF8", {
        enumerable: true,
        get: function() {
          return l.escapeUTF8;
        }
      }), Object.defineProperty(n, "escapeAttribute", {
        enumerable: true,
        get: function() {
          return l.escapeAttribute;
        }
      }), Object.defineProperty(n, "escapeText", {
        enumerable: true,
        get: function() {
          return l.escapeText;
        }
      });
      var c = Gd();
      Object.defineProperty(n, "encodeHTML", {
        enumerable: true,
        get: function() {
          return c.encodeHTML;
        }
      }), Object.defineProperty(n, "encodeNonAsciiHTML", {
        enumerable: true,
        get: function() {
          return c.encodeNonAsciiHTML;
        }
      }), Object.defineProperty(n, "encodeHTML4", {
        enumerable: true,
        get: function() {
          return c.encodeHTML;
        }
      }), Object.defineProperty(n, "encodeHTML5", {
        enumerable: true,
        get: function() {
          return c.encodeHTML;
        }
      });
      var h = mo();
      Object.defineProperty(n, "EntityDecoder", {
        enumerable: true,
        get: function() {
          return h.EntityDecoder;
        }
      }), Object.defineProperty(n, "DecodingMode", {
        enumerable: true,
        get: function() {
          return h.DecodingMode;
        }
      }), Object.defineProperty(n, "decodeXML", {
        enumerable: true,
        get: function() {
          return h.decodeXML;
        }
      }), Object.defineProperty(n, "decodeHTML", {
        enumerable: true,
        get: function() {
          return h.decodeHTML;
        }
      }), Object.defineProperty(n, "decodeHTMLStrict", {
        enumerable: true,
        get: function() {
          return h.decodeHTMLStrict;
        }
      }), Object.defineProperty(n, "decodeHTMLAttribute", {
        enumerable: true,
        get: function() {
          return h.decodeHTMLAttribute;
        }
      }), Object.defineProperty(n, "decodeHTML4", {
        enumerable: true,
        get: function() {
          return h.decodeHTML;
        }
      }), Object.defineProperty(n, "decodeHTML5", {
        enumerable: true,
        get: function() {
          return h.decodeHTML;
        }
      }), Object.defineProperty(n, "decodeHTML4Strict", {
        enumerable: true,
        get: function() {
          return h.decodeHTMLStrict;
        }
      }), Object.defineProperty(n, "decodeHTML5Strict", {
        enumerable: true,
        get: function() {
          return h.decodeHTMLStrict;
        }
      }), Object.defineProperty(n, "decodeXMLStrict", {
        enumerable: true,
        get: function() {
          return h.decodeXML;
        }
      });
    }(Da)), Da;
  }
  var yr = {}, Jd;
  function Rk() {
    return Jd || (Jd = 1, Object.defineProperty(yr, "__esModule", {
      value: true
    }), yr.attributeNames = yr.elementNames = void 0, yr.elementNames = new Map([
      "altGlyph",
      "altGlyphDef",
      "altGlyphItem",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "clipPath",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feDropShadow",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "foreignObject",
      "glyphRef",
      "linearGradient",
      "radialGradient",
      "textPath"
    ].map(function(n) {
      return [
        n.toLowerCase(),
        n
      ];
    })), yr.attributeNames = new Map([
      "definitionURL",
      "attributeName",
      "attributeType",
      "baseFrequency",
      "baseProfile",
      "calcMode",
      "clipPathUnits",
      "diffuseConstant",
      "edgeMode",
      "filterUnits",
      "glyphRef",
      "gradientTransform",
      "gradientUnits",
      "kernelMatrix",
      "kernelUnitLength",
      "keyPoints",
      "keySplines",
      "keyTimes",
      "lengthAdjust",
      "limitingConeAngle",
      "markerHeight",
      "markerUnits",
      "markerWidth",
      "maskContentUnits",
      "maskUnits",
      "numOctaves",
      "pathLength",
      "patternContentUnits",
      "patternTransform",
      "patternUnits",
      "pointsAtX",
      "pointsAtY",
      "pointsAtZ",
      "preserveAlpha",
      "preserveAspectRatio",
      "primitiveUnits",
      "refX",
      "refY",
      "repeatCount",
      "repeatDur",
      "requiredExtensions",
      "requiredFeatures",
      "specularConstant",
      "specularExponent",
      "spreadMethod",
      "startOffset",
      "stdDeviation",
      "stitchTiles",
      "surfaceScale",
      "systemLanguage",
      "tableValues",
      "targetX",
      "targetY",
      "textLength",
      "viewBox",
      "viewTarget",
      "xChannelSelector",
      "yChannelSelector",
      "zoomAndPan"
    ].map(function(n) {
      return [
        n.toLowerCase(),
        n
      ];
    }))), yr;
  }
  var Yd;
  function _k() {
    if (Yd) return Ft;
    Yd = 1;
    var n = Ft && Ft.__assign || function() {
      return n = Object.assign || function(y) {
        for (var x, k = 1, T = arguments.length; k < T; k++) {
          x = arguments[k];
          for (var M in x) Object.prototype.hasOwnProperty.call(x, M) && (y[M] = x[M]);
        }
        return y;
      }, n.apply(this, arguments);
    }, e = Ft && Ft.__createBinding || (Object.create ? function(y, x, k, T) {
      T === void 0 && (T = k);
      var M = Object.getOwnPropertyDescriptor(x, k);
      (!M || ("get" in M ? !x.__esModule : M.writable || M.configurable)) && (M = {
        enumerable: true,
        get: function() {
          return x[k];
        }
      }), Object.defineProperty(y, T, M);
    } : function(y, x, k, T) {
      T === void 0 && (T = k), y[T] = x[k];
    }), t = Ft && Ft.__setModuleDefault || (Object.create ? function(y, x) {
      Object.defineProperty(y, "default", {
        enumerable: true,
        value: x
      });
    } : function(y, x) {
      y.default = x;
    }), r = Ft && Ft.__importStar || function(y) {
      if (y && y.__esModule) return y;
      var x = {};
      if (y != null) for (var k in y) k !== "default" && Object.prototype.hasOwnProperty.call(y, k) && e(x, y, k);
      return t(x, y), x;
    };
    Object.defineProperty(Ft, "__esModule", {
      value: true
    }), Ft.render = void 0;
    var i = r(is()), s = Ik(), o = Rk(), a = /* @__PURE__ */ new Set([
      "style",
      "script",
      "xmp",
      "iframe",
      "noembed",
      "noframes",
      "plaintext",
      "noscript"
    ]);
    function u(y) {
      return y.replace(/"/g, "&quot;");
    }
    function l(y, x) {
      var k;
      if (y) {
        var T = ((k = x.encodeEntities) !== null && k !== void 0 ? k : x.decodeEntities) === false ? u : x.xmlMode || x.encodeEntities !== "utf8" ? s.encodeXML : s.escapeAttribute;
        return Object.keys(y).map(function(M) {
          var D, I, C = (D = y[M]) !== null && D !== void 0 ? D : "";
          return x.xmlMode === "foreign" && (M = (I = o.attributeNames.get(M)) !== null && I !== void 0 ? I : M), !x.emptyAttrs && !x.xmlMode && C === "" ? M : "".concat(M, '="').concat(T(C), '"');
        }).join(" ");
      }
    }
    var c = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    function h(y, x) {
      x === void 0 && (x = {});
      for (var k = ("length" in y) ? y : [
        y
      ], T = "", M = 0; M < k.length; M++) T += d(k[M], x);
      return T;
    }
    Ft.render = h, Ft.default = h;
    function d(y, x) {
      switch (y.type) {
        case i.Root:
          return h(y.children, x);
        case i.Doctype:
        case i.Directive:
          return b(y);
        case i.Comment:
          return v(y);
        case i.CDATA:
          return w(y);
        case i.Script:
        case i.Style:
        case i.Tag:
          return m(y, x);
        case i.Text:
          return g(y, x);
      }
    }
    var f = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignObject",
      "desc",
      "title"
    ]), p = /* @__PURE__ */ new Set([
      "svg",
      "math"
    ]);
    function m(y, x) {
      var k;
      x.xmlMode === "foreign" && (y.name = (k = o.elementNames.get(y.name)) !== null && k !== void 0 ? k : y.name, y.parent && f.has(y.parent.name) && (x = n(n({}, x), {
        xmlMode: false
      }))), !x.xmlMode && p.has(y.name) && (x = n(n({}, x), {
        xmlMode: "foreign"
      }));
      var T = "<".concat(y.name), M = l(y.attribs, x);
      return M && (T += " ".concat(M)), y.children.length === 0 && (x.xmlMode ? x.selfClosingTags !== false : x.selfClosingTags && c.has(y.name)) ? (x.xmlMode || (T += " "), T += "/>") : (T += ">", y.children.length > 0 && (T += h(y.children, x)), (x.xmlMode || !c.has(y.name)) && (T += "</".concat(y.name, ">"))), T;
    }
    function b(y) {
      return "<".concat(y.data, ">");
    }
    function g(y, x) {
      var k, T = y.data || "";
      return ((k = x.encodeEntities) !== null && k !== void 0 ? k : x.decodeEntities) !== false && !(!x.xmlMode && y.parent && a.has(y.parent.name)) && (T = x.xmlMode || x.encodeEntities !== "utf8" ? (0, s.encodeXML)(T) : (0, s.escapeText)(T)), T;
    }
    function w(y) {
      return "<![CDATA[".concat(y.children[0].data, "]]>");
    }
    function v(y) {
      return "<!--".concat(y.data, "-->");
    }
    return Ft;
  }
  var Xd;
  function H0() {
    if (Xd) return gn;
    Xd = 1;
    var n = gn && gn.__importDefault || function(l) {
      return l && l.__esModule ? l : {
        default: l
      };
    };
    Object.defineProperty(gn, "__esModule", {
      value: true
    }), gn.getOuterHTML = i, gn.getInnerHTML = s, gn.getText = o, gn.textContent = a, gn.innerText = u;
    var e = dr(), t = n(_k()), r = is();
    function i(l, c) {
      return (0, t.default)(l, c);
    }
    function s(l, c) {
      return (0, e.hasChildren)(l) ? l.children.map(function(h) {
        return i(h, c);
      }).join("") : "";
    }
    function o(l) {
      return Array.isArray(l) ? l.map(o).join("") : (0, e.isTag)(l) ? l.name === "br" ? `
` : o(l.children) : (0, e.isCDATA)(l) ? o(l.children) : (0, e.isText)(l) ? l.data : "";
    }
    function a(l) {
      return Array.isArray(l) ? l.map(a).join("") : (0, e.hasChildren)(l) && !(0, e.isComment)(l) ? a(l.children) : (0, e.isText)(l) ? l.data : "";
    }
    function u(l) {
      return Array.isArray(l) ? l.map(u).join("") : (0, e.hasChildren)(l) && (l.type === r.ElementType.Tag || (0, e.isCDATA)(l)) ? u(l.children) : (0, e.isText)(l) ? l.data : "";
    }
    return gn;
  }
  var rn = {}, Qd;
  function Lk() {
    if (Qd) return rn;
    Qd = 1, Object.defineProperty(rn, "__esModule", {
      value: true
    }), rn.getChildren = e, rn.getParent = t, rn.getSiblings = r, rn.getAttributeValue = i, rn.hasAttrib = s, rn.getName = o, rn.nextElementSibling = a, rn.prevElementSibling = u;
    var n = dr();
    function e(l) {
      return (0, n.hasChildren)(l) ? l.children : [];
    }
    function t(l) {
      return l.parent || null;
    }
    function r(l) {
      var c, h, d = t(l);
      if (d != null) return e(d);
      for (var f = [
        l
      ], p = l.prev, m = l.next; p != null; ) f.unshift(p), c = p, p = c.prev;
      for (; m != null; ) f.push(m), h = m, m = h.next;
      return f;
    }
    function i(l, c) {
      var h;
      return (h = l.attribs) === null || h === void 0 ? void 0 : h[c];
    }
    function s(l, c) {
      return l.attribs != null && Object.prototype.hasOwnProperty.call(l.attribs, c) && l.attribs[c] != null;
    }
    function o(l) {
      return l.name;
    }
    function a(l) {
      for (var c, h = l.next; h !== null && !(0, n.isTag)(h); ) c = h, h = c.next;
      return h;
    }
    function u(l) {
      for (var c, h = l.prev; h !== null && !(0, n.isTag)(h); ) c = h, h = c.prev;
      return h;
    }
    return rn;
  }
  var In = {}, Zd;
  function Bk() {
    if (Zd) return In;
    Zd = 1, Object.defineProperty(In, "__esModule", {
      value: true
    }), In.removeElement = n, In.replaceElement = e, In.appendChild = t, In.append = r, In.prependChild = i, In.prepend = s;
    function n(o) {
      if (o.prev && (o.prev.next = o.next), o.next && (o.next.prev = o.prev), o.parent) {
        var a = o.parent.children, u = a.lastIndexOf(o);
        u >= 0 && a.splice(u, 1);
      }
      o.next = null, o.prev = null, o.parent = null;
    }
    function e(o, a) {
      var u = a.prev = o.prev;
      u && (u.next = a);
      var l = a.next = o.next;
      l && (l.prev = a);
      var c = a.parent = o.parent;
      if (c) {
        var h = c.children;
        h[h.lastIndexOf(o)] = a, o.parent = null;
      }
    }
    function t(o, a) {
      if (n(a), a.next = null, a.parent = o, o.children.push(a) > 1) {
        var u = o.children[o.children.length - 2];
        u.next = a, a.prev = u;
      } else a.prev = null;
    }
    function r(o, a) {
      n(a);
      var u = o.parent, l = o.next;
      if (a.next = l, a.prev = o, o.next = a, a.parent = u, l) {
        if (l.prev = a, u) {
          var c = u.children;
          c.splice(c.lastIndexOf(l), 0, a);
        }
      } else u && u.children.push(a);
    }
    function i(o, a) {
      if (n(a), a.parent = o, a.prev = null, o.children.unshift(a) !== 1) {
        var u = o.children[1];
        u.prev = a, a.next = u;
      } else a.next = null;
    }
    function s(o, a) {
      n(a);
      var u = o.parent;
      if (u) {
        var l = u.children;
        l.splice(l.indexOf(o), 0, a);
      }
      o.prev && (o.prev.next = a), a.parent = u, a.prev = o.prev, a.next = o, o.prev = a;
    }
    return In;
  }
  var Rn = {}, ef;
  function W0() {
    if (ef) return Rn;
    ef = 1, Object.defineProperty(Rn, "__esModule", {
      value: true
    }), Rn.filter = e, Rn.find = t, Rn.findOneChild = r, Rn.findOne = i, Rn.existsOne = s, Rn.findAll = o;
    var n = dr();
    function e(a, u, l, c) {
      return l === void 0 && (l = true), c === void 0 && (c = 1 / 0), t(a, Array.isArray(u) ? u : [
        u
      ], l, c);
    }
    function t(a, u, l, c) {
      for (var h = [], d = [
        Array.isArray(u) ? u : [
          u
        ]
      ], f = [
        0
      ]; ; ) {
        if (f[0] >= d[0].length) {
          if (f.length === 1) return h;
          d.shift(), f.shift();
          continue;
        }
        var p = d[0][f[0]++];
        if (a(p) && (h.push(p), --c <= 0)) return h;
        l && (0, n.hasChildren)(p) && p.children.length > 0 && (f.unshift(0), d.unshift(p.children));
      }
    }
    function r(a, u) {
      return u.find(a);
    }
    function i(a, u, l) {
      l === void 0 && (l = true);
      for (var c = Array.isArray(u) ? u : [
        u
      ], h = 0; h < c.length; h++) {
        var d = c[h];
        if ((0, n.isTag)(d) && a(d)) return d;
        if (l && (0, n.hasChildren)(d) && d.children.length > 0) {
          var f = i(a, d.children, true);
          if (f) return f;
        }
      }
      return null;
    }
    function s(a, u) {
      return (Array.isArray(u) ? u : [
        u
      ]).some(function(l) {
        return (0, n.isTag)(l) && a(l) || (0, n.hasChildren)(l) && s(a, l.children);
      });
    }
    function o(a, u) {
      for (var l = [], c = [
        Array.isArray(u) ? u : [
          u
        ]
      ], h = [
        0
      ]; ; ) {
        if (h[0] >= c[0].length) {
          if (c.length === 1) return l;
          c.shift(), h.shift();
          continue;
        }
        var d = c[0][h[0]++];
        (0, n.isTag)(d) && a(d) && l.push(d), (0, n.hasChildren)(d) && d.children.length > 0 && (h.unshift(0), c.unshift(d.children));
      }
    }
    return Rn;
  }
  var _n = {}, tf;
  function U0() {
    if (tf) return _n;
    tf = 1, Object.defineProperty(_n, "__esModule", {
      value: true
    }), _n.testElement = o, _n.getElements = a, _n.getElementById = u, _n.getElementsByTagName = l, _n.getElementsByClassName = c, _n.getElementsByTagType = h;
    var n = dr(), e = W0(), t = {
      tag_name: function(d) {
        return typeof d == "function" ? function(f) {
          return (0, n.isTag)(f) && d(f.name);
        } : d === "*" ? n.isTag : function(f) {
          return (0, n.isTag)(f) && f.name === d;
        };
      },
      tag_type: function(d) {
        return typeof d == "function" ? function(f) {
          return d(f.type);
        } : function(f) {
          return f.type === d;
        };
      },
      tag_contains: function(d) {
        return typeof d == "function" ? function(f) {
          return (0, n.isText)(f) && d(f.data);
        } : function(f) {
          return (0, n.isText)(f) && f.data === d;
        };
      }
    };
    function r(d, f) {
      return typeof f == "function" ? function(p) {
        return (0, n.isTag)(p) && f(p.attribs[d]);
      } : function(p) {
        return (0, n.isTag)(p) && p.attribs[d] === f;
      };
    }
    function i(d, f) {
      return function(p) {
        return d(p) || f(p);
      };
    }
    function s(d) {
      var f = Object.keys(d).map(function(p) {
        var m = d[p];
        return Object.prototype.hasOwnProperty.call(t, p) ? t[p](m) : r(p, m);
      });
      return f.length === 0 ? null : f.reduce(i);
    }
    function o(d, f) {
      var p = s(d);
      return p ? p(f) : true;
    }
    function a(d, f, p, m) {
      m === void 0 && (m = 1 / 0);
      var b = s(d);
      return b ? (0, e.filter)(b, f, p, m) : [];
    }
    function u(d, f, p) {
      return p === void 0 && (p = true), Array.isArray(f) || (f = [
        f
      ]), (0, e.findOne)(r("id", d), f, p);
    }
    function l(d, f, p, m) {
      return p === void 0 && (p = true), m === void 0 && (m = 1 / 0), (0, e.filter)(t.tag_name(d), f, p, m);
    }
    function c(d, f, p, m) {
      return p === void 0 && (p = true), m === void 0 && (m = 1 / 0), (0, e.filter)(r("class", d), f, p, m);
    }
    function h(d, f, p, m) {
      return p === void 0 && (p = true), m === void 0 && (m = 1 / 0), (0, e.filter)(t.tag_type(d), f, p, m);
    }
    return _n;
  }
  var Wn = {}, nf;
  function Fk() {
    if (nf) return Wn;
    nf = 1, Object.defineProperty(Wn, "__esModule", {
      value: true
    }), Wn.DocumentPosition = void 0, Wn.removeSubsets = e, Wn.compareDocumentPosition = r, Wn.uniqueSort = i;
    var n = dr();
    function e(s) {
      for (var o = s.length; --o >= 0; ) {
        var a = s[o];
        if (o > 0 && s.lastIndexOf(a, o - 1) >= 0) {
          s.splice(o, 1);
          continue;
        }
        for (var u = a.parent; u; u = u.parent) if (s.includes(u)) {
          s.splice(o, 1);
          break;
        }
      }
      return s;
    }
    var t;
    (function(s) {
      s[s.DISCONNECTED = 1] = "DISCONNECTED", s[s.PRECEDING = 2] = "PRECEDING", s[s.FOLLOWING = 4] = "FOLLOWING", s[s.CONTAINS = 8] = "CONTAINS", s[s.CONTAINED_BY = 16] = "CONTAINED_BY";
    })(t || (Wn.DocumentPosition = t = {}));
    function r(s, o) {
      var a = [], u = [];
      if (s === o) return 0;
      for (var l = (0, n.hasChildren)(s) ? s : s.parent; l; ) a.unshift(l), l = l.parent;
      for (l = (0, n.hasChildren)(o) ? o : o.parent; l; ) u.unshift(l), l = l.parent;
      for (var c = Math.min(a.length, u.length), h = 0; h < c && a[h] === u[h]; ) h++;
      if (h === 0) return t.DISCONNECTED;
      var d = a[h - 1], f = d.children, p = a[h], m = u[h];
      return f.indexOf(p) > f.indexOf(m) ? d === o ? t.FOLLOWING | t.CONTAINED_BY : t.FOLLOWING : d === s ? t.PRECEDING | t.CONTAINS : t.PRECEDING;
    }
    function i(s) {
      return s = s.filter(function(o, a, u) {
        return !u.includes(o, a + 1);
      }), s.sort(function(o, a) {
        var u = r(o, a);
        return u & t.PRECEDING ? -1 : u & t.FOLLOWING ? 1 : 0;
      }), s;
    }
    return Wn;
  }
  var Ss = {}, rf;
  function zk() {
    if (rf) return Ss;
    rf = 1, Object.defineProperty(Ss, "__esModule", {
      value: true
    }), Ss.getFeed = t;
    var n = H0(), e = U0();
    function t(d) {
      var f = u(h, d);
      return f ? f.name === "feed" ? r(f) : i(f) : null;
    }
    function r(d) {
      var f, p = d.children, m = {
        type: "atom",
        items: (0, e.getElementsByTagName)("entry", p).map(function(w) {
          var v, y = w.children, x = {
            media: a(y)
          };
          c(x, "id", "id", y), c(x, "title", "title", y);
          var k = (v = u("link", y)) === null || v === void 0 ? void 0 : v.attribs.href;
          k && (x.link = k);
          var T = l("summary", y) || l("content", y);
          T && (x.description = T);
          var M = l("updated", y);
          return M && (x.pubDate = new Date(M)), x;
        })
      };
      c(m, "id", "id", p), c(m, "title", "title", p);
      var b = (f = u("link", p)) === null || f === void 0 ? void 0 : f.attribs.href;
      b && (m.link = b), c(m, "description", "subtitle", p);
      var g = l("updated", p);
      return g && (m.updated = new Date(g)), c(m, "author", "email", p, true), m;
    }
    function i(d) {
      var f, p, m = (p = (f = u("channel", d.children)) === null || f === void 0 ? void 0 : f.children) !== null && p !== void 0 ? p : [], b = {
        type: d.name.substr(0, 3),
        id: "",
        items: (0, e.getElementsByTagName)("item", d.children).map(function(w) {
          var v = w.children, y = {
            media: a(v)
          };
          c(y, "id", "guid", v), c(y, "title", "title", v), c(y, "link", "link", v), c(y, "description", "description", v);
          var x = l("pubDate", v) || l("dc:date", v);
          return x && (y.pubDate = new Date(x)), y;
        })
      };
      c(b, "title", "title", m), c(b, "link", "link", m), c(b, "description", "description", m);
      var g = l("lastBuildDate", m);
      return g && (b.updated = new Date(g)), c(b, "author", "managingEditor", m, true), b;
    }
    var s = [
      "url",
      "type",
      "lang"
    ], o = [
      "fileSize",
      "bitrate",
      "framerate",
      "samplingrate",
      "channels",
      "duration",
      "height",
      "width"
    ];
    function a(d) {
      return (0, e.getElementsByTagName)("media:content", d).map(function(f) {
        for (var p = f.attribs, m = {
          medium: p.medium,
          isDefault: !!p.isDefault
        }, b = 0, g = s; b < g.length; b++) {
          var w = g[b];
          p[w] && (m[w] = p[w]);
        }
        for (var v = 0, y = o; v < y.length; v++) {
          var w = y[v];
          p[w] && (m[w] = parseInt(p[w], 10));
        }
        return p.expression && (m.expression = p.expression), m;
      });
    }
    function u(d, f) {
      return (0, e.getElementsByTagName)(d, f, true, 1)[0];
    }
    function l(d, f, p) {
      return p === void 0 && (p = false), (0, n.textContent)((0, e.getElementsByTagName)(d, f, p, 1)).trim();
    }
    function c(d, f, p, m, b) {
      b === void 0 && (b = false);
      var g = l(p, m, b);
      g && (d[f] = g);
    }
    function h(d) {
      return d === "rss" || d === "feed" || d === "rdf:RDF";
    }
    return Ss;
  }
  var sf;
  function Ra() {
    return sf || (sf = 1, function(n) {
      var e = br && br.__createBinding || (Object.create ? function(i, s, o, a) {
        a === void 0 && (a = o);
        var u = Object.getOwnPropertyDescriptor(s, o);
        (!u || ("get" in u ? !s.__esModule : u.writable || u.configurable)) && (u = {
          enumerable: true,
          get: function() {
            return s[o];
          }
        }), Object.defineProperty(i, a, u);
      } : function(i, s, o, a) {
        a === void 0 && (a = o), i[a] = s[o];
      }), t = br && br.__exportStar || function(i, s) {
        for (var o in i) o !== "default" && !Object.prototype.hasOwnProperty.call(s, o) && e(s, i, o);
      };
      Object.defineProperty(n, "__esModule", {
        value: true
      }), n.hasChildren = n.isDocument = n.isComment = n.isText = n.isCDATA = n.isTag = void 0, t(H0(), n), t(Lk(), n), t(Bk(), n), t(W0(), n), t(U0(), n), t(Fk(), n), t(zk(), n);
      var r = dr();
      Object.defineProperty(n, "isTag", {
        enumerable: true,
        get: function() {
          return r.isTag;
        }
      }), Object.defineProperty(n, "isCDATA", {
        enumerable: true,
        get: function() {
          return r.isCDATA;
        }
      }), Object.defineProperty(n, "isText", {
        enumerable: true,
        get: function() {
          return r.isText;
        }
      }), Object.defineProperty(n, "isComment", {
        enumerable: true,
        get: function() {
          return r.isComment;
        }
      }), Object.defineProperty(n, "isDocument", {
        enumerable: true,
        get: function() {
          return r.isDocument;
        }
      }), Object.defineProperty(n, "hasChildren", {
        enumerable: true,
        get: function() {
          return r.hasChildren;
        }
      });
    }(br)), br;
  }
  var of;
  function jk() {
    return of || (of = 1, function(n) {
      var e = en && en.__createBinding || (Object.create ? function(g, w, v, y) {
        y === void 0 && (y = v);
        var x = Object.getOwnPropertyDescriptor(w, v);
        (!x || ("get" in x ? !w.__esModule : x.writable || x.configurable)) && (x = {
          enumerable: true,
          get: function() {
            return w[v];
          }
        }), Object.defineProperty(g, y, x);
      } : function(g, w, v, y) {
        y === void 0 && (y = v), g[y] = w[v];
      }), t = en && en.__setModuleDefault || (Object.create ? function(g, w) {
        Object.defineProperty(g, "default", {
          enumerable: true,
          value: w
        });
      } : function(g, w) {
        g.default = w;
      }), r = en && en.__importStar || function(g) {
        if (g && g.__esModule) return g;
        var w = {};
        if (g != null) for (var v in g) v !== "default" && Object.prototype.hasOwnProperty.call(g, v) && e(w, g, v);
        return t(w, g), w;
      }, i = en && en.__importDefault || function(g) {
        return g && g.__esModule ? g : {
          default: g
        };
      };
      Object.defineProperty(n, "__esModule", {
        value: true
      }), n.DomUtils = n.parseFeed = n.getFeed = n.ElementType = n.Tokenizer = n.createDomStream = n.parseDOM = n.parseDocument = n.DefaultHandler = n.DomHandler = n.Parser = void 0;
      var s = zd(), o = zd();
      Object.defineProperty(n, "Parser", {
        enumerable: true,
        get: function() {
          return o.Parser;
        }
      });
      var a = dr(), u = dr();
      Object.defineProperty(n, "DomHandler", {
        enumerable: true,
        get: function() {
          return u.DomHandler;
        }
      }), Object.defineProperty(n, "DefaultHandler", {
        enumerable: true,
        get: function() {
          return u.DomHandler;
        }
      });
      function l(g, w) {
        var v = new a.DomHandler(void 0, w);
        return new s.Parser(v, w).end(g), v.root;
      }
      n.parseDocument = l;
      function c(g, w) {
        return l(g, w).children;
      }
      n.parseDOM = c;
      function h(g, w, v) {
        var y = new a.DomHandler(g, w, v);
        return new s.Parser(y, w);
      }
      n.createDomStream = h;
      var d = V0();
      Object.defineProperty(n, "Tokenizer", {
        enumerable: true,
        get: function() {
          return i(d).default;
        }
      }), n.ElementType = r(is());
      var f = Ra(), p = Ra();
      Object.defineProperty(n, "getFeed", {
        enumerable: true,
        get: function() {
          return p.getFeed;
        }
      });
      var m = {
        xmlMode: true
      };
      function b(g, w) {
        return w === void 0 && (w = m), (0, f.getFeed)(c(g, w));
      }
      n.parseFeed = b, n.DomUtils = r(Ra());
    }(en)), en;
  }
  var _a, af;
  function qk() {
    return af || (af = 1, _a = (n) => {
      if (typeof n != "string") throw new TypeError("Expected a string");
      return n.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    }), _a;
  }
  var Ts = {}, uf;
  function $k() {
    if (uf) return Ts;
    uf = 1, Object.defineProperty(Ts, "__esModule", {
      value: true
    });
    function n(t) {
      return Object.prototype.toString.call(t) === "[object Object]";
    }
    function e(t) {
      var r, i;
      return n(t) === false ? false : (r = t.constructor, r === void 0 ? true : (i = r.prototype, !(n(i) === false || i.hasOwnProperty("isPrototypeOf") === false)));
    }
    return Ts.isPlainObject = e, Ts;
  }
  var La, lf;
  function Vk() {
    if (lf) return La;
    lf = 1;
    var n = function(w) {
      return e(w) && !t(w);
    };
    function e(g) {
      return !!g && typeof g == "object";
    }
    function t(g) {
      var w = Object.prototype.toString.call(g);
      return w === "[object RegExp]" || w === "[object Date]" || s(g);
    }
    var r = typeof Symbol == "function" && Symbol.for, i = r ? Symbol.for("react.element") : 60103;
    function s(g) {
      return g.$$typeof === i;
    }
    function o(g) {
      return Array.isArray(g) ? [] : {};
    }
    function a(g, w) {
      return w.clone !== false && w.isMergeableObject(g) ? m(o(g), g, w) : g;
    }
    function u(g, w, v) {
      return g.concat(w).map(function(y) {
        return a(y, v);
      });
    }
    function l(g, w) {
      if (!w.customMerge) return m;
      var v = w.customMerge(g);
      return typeof v == "function" ? v : m;
    }
    function c(g) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(g).filter(function(w) {
        return Object.propertyIsEnumerable.call(g, w);
      }) : [];
    }
    function h(g) {
      return Object.keys(g).concat(c(g));
    }
    function d(g, w) {
      try {
        return w in g;
      } catch {
        return false;
      }
    }
    function f(g, w) {
      return d(g, w) && !(Object.hasOwnProperty.call(g, w) && Object.propertyIsEnumerable.call(g, w));
    }
    function p(g, w, v) {
      var y = {};
      return v.isMergeableObject(g) && h(g).forEach(function(x) {
        y[x] = a(g[x], v);
      }), h(w).forEach(function(x) {
        f(g, x) || (d(g, x) && v.isMergeableObject(w[x]) ? y[x] = l(x, v)(g[x], w[x], v) : y[x] = a(w[x], v));
      }), y;
    }
    function m(g, w, v) {
      v = v || {}, v.arrayMerge = v.arrayMerge || u, v.isMergeableObject = v.isMergeableObject || n, v.cloneUnlessOtherwiseSpecified = a;
      var y = Array.isArray(w), x = Array.isArray(g), k = y === x;
      return k ? y ? v.arrayMerge(g, w, v) : p(g, w, v) : a(w, v);
    }
    m.all = function(w, v) {
      if (!Array.isArray(w)) throw new Error("first argument should be an array");
      return w.reduce(function(y, x) {
        return m(y, x, v);
      }, {});
    };
    var b = m;
    return La = b, La;
  }
  var Ws = {
    exports: {}
  }, Hk = Ws.exports, cf;
  function Wk() {
    return cf || (cf = 1, function(n) {
      (function(e, t) {
        n.exports ? n.exports = t() : e.parseSrcset = t();
      })(Hk, function() {
        return function(e) {
          function t(y) {
            return y === " " || y === "	" || y === `
` || y === "\f" || y === "\r";
          }
          function r(y) {
            var x, k = y.exec(e.substring(b));
            if (k) return x = k[0], b += x.length, x;
          }
          for (var i = e.length, s = /^[ \t\n\r\u000c]+/, o = /^[, \t\n\r\u000c]+/, a = /^[^ \t\n\r\u000c]+/, u = /[,]+$/, l = /^\d+$/, c = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, h, d, f, p, m, b = 0, g = []; ; ) {
            if (r(o), b >= i) return g;
            h = r(a), d = [], h.slice(-1) === "," ? (h = h.replace(u, ""), v()) : w();
          }
          function w() {
            for (r(s), f = "", p = "in descriptor"; ; ) {
              if (m = e.charAt(b), p === "in descriptor") if (t(m)) f && (d.push(f), f = "", p = "after descriptor");
              else if (m === ",") {
                b += 1, f && d.push(f), v();
                return;
              } else if (m === "(") f = f + m, p = "in parens";
              else if (m === "") {
                f && d.push(f), v();
                return;
              } else f = f + m;
              else if (p === "in parens") if (m === ")") f = f + m, p = "in descriptor";
              else if (m === "") {
                d.push(f), v();
                return;
              } else f = f + m;
              else if (p === "after descriptor" && !t(m)) if (m === "") {
                v();
                return;
              } else p = "in descriptor", b -= 1;
              b += 1;
            }
          }
          function v() {
            var y = false, x, k, T, M, D = {}, I, C, O, E, N;
            for (M = 0; M < d.length; M++) I = d[M], C = I[I.length - 1], O = I.substring(0, I.length - 1), E = parseInt(O, 10), N = parseFloat(O), l.test(O) && C === "w" ? ((x || k) && (y = true), E === 0 ? y = true : x = E) : c.test(O) && C === "x" ? ((x || k || T) && (y = true), N < 0 ? y = true : k = N) : l.test(O) && C === "h" ? ((T || k) && (y = true), E === 0 ? y = true : T = E) : y = true;
            y ? console && console.log && console.log("Invalid srcset descriptor found in '" + e + "' at '" + I + "'.") : (D.url = h, x && (D.w = x), k && (D.d = k), T && (D.h = T), g.push(D));
          }
        };
      });
    }(Ws)), Ws.exports;
  }
  var Es = {
    exports: {}
  }, df;
  function Uk() {
    if (df) return Es.exports;
    df = 1;
    var n = String, e = function() {
      return {
        isColorSupported: false,
        reset: n,
        bold: n,
        dim: n,
        italic: n,
        underline: n,
        inverse: n,
        hidden: n,
        strikethrough: n,
        black: n,
        red: n,
        green: n,
        yellow: n,
        blue: n,
        magenta: n,
        cyan: n,
        white: n,
        gray: n,
        bgBlack: n,
        bgRed: n,
        bgGreen: n,
        bgYellow: n,
        bgBlue: n,
        bgMagenta: n,
        bgCyan: n,
        bgWhite: n,
        blackBright: n,
        redBright: n,
        greenBright: n,
        yellowBright: n,
        blueBright: n,
        magentaBright: n,
        cyanBright: n,
        whiteBright: n,
        bgBlackBright: n,
        bgRedBright: n,
        bgGreenBright: n,
        bgYellowBright: n,
        bgBlueBright: n,
        bgMagentaBright: n,
        bgCyanBright: n,
        bgWhiteBright: n
      };
    };
    return Es.exports = e(), Es.exports.createColors = e, Es.exports;
  }
  var Ba, ff;
  function $l() {
    if (ff) return Ba;
    ff = 1;
    let n = Uk(), e = ln;
    class t extends Error {
      constructor(i, s, o, a, u, l) {
        super(i), this.name = "CssSyntaxError", this.reason = i, u && (this.file = u), a && (this.source = a), l && (this.plugin = l), typeof s < "u" && typeof o < "u" && (typeof s == "number" ? (this.line = s, this.column = o) : (this.line = s.line, this.column = s.column, this.endLine = o.line, this.endColumn = o.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, t);
      }
      setMessage() {
        this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
      }
      showSourceCode(i) {
        if (!this.source) return "";
        let s = this.source;
        i == null && (i = n.isColorSupported);
        let o = (f) => f, a = (f) => f, u = (f) => f;
        if (i) {
          let { bold: f, gray: p, red: m } = n.createColors(true);
          a = (b) => f(m(b)), o = (b) => p(b), e && (u = (b) => e(b));
        }
        let l = s.split(/\r?\n/), c = Math.max(this.line - 3, 0), h = Math.min(this.line + 2, l.length), d = String(h).length;
        return l.slice(c, h).map((f, p) => {
          let m = c + 1 + p, b = " " + (" " + m).slice(-d) + " | ";
          if (m === this.line) {
            if (f.length > 160) {
              let w = 20, v = Math.max(0, this.column - w), y = Math.max(this.column + w, this.endColumn + w), x = f.slice(v, y), k = o(b.replace(/\d/g, " ")) + f.slice(0, Math.min(this.column - 1, w - 1)).replace(/[^\t]/g, " ");
              return a(">") + o(b) + u(x) + `
 ` + k + a("^");
            }
            let g = o(b.replace(/\d/g, " ")) + f.slice(0, this.column - 1).replace(/[^\t]/g, " ");
            return a(">") + o(b) + u(f) + `
 ` + g + a("^");
          }
          return " " + o(b) + u(f);
        }).join(`
`);
      }
      toString() {
        let i = this.showSourceCode();
        return i && (i = `

` + i + `
`), this.name + ": " + this.message + i;
      }
    }
    return Ba = t, t.default = t, Ba;
  }
  var Fa, hf;
  function G0() {
    if (hf) return Fa;
    hf = 1;
    const n = {
      after: `
`,
      beforeClose: `
`,
      beforeComment: `
`,
      beforeDecl: `
`,
      beforeOpen: " ",
      beforeRule: `
`,
      colon: ": ",
      commentLeft: " ",
      commentRight: " ",
      emptyBody: "",
      indent: "    ",
      semicolon: false
    };
    function e(r) {
      return r[0].toUpperCase() + r.slice(1);
    }
    class t {
      constructor(i) {
        this.builder = i;
      }
      atrule(i, s) {
        let o = "@" + i.name, a = i.params ? this.rawValue(i, "params") : "";
        if (typeof i.raws.afterName < "u" ? o += i.raws.afterName : a && (o += " "), i.nodes) this.block(i, o + a);
        else {
          let u = (i.raws.between || "") + (s ? ";" : "");
          this.builder(o + a + u, i);
        }
      }
      beforeAfter(i, s) {
        let o;
        i.type === "decl" ? o = this.raw(i, null, "beforeDecl") : i.type === "comment" ? o = this.raw(i, null, "beforeComment") : s === "before" ? o = this.raw(i, null, "beforeRule") : o = this.raw(i, null, "beforeClose");
        let a = i.parent, u = 0;
        for (; a && a.type !== "root"; ) u += 1, a = a.parent;
        if (o.includes(`
`)) {
          let l = this.raw(i, null, "indent");
          if (l.length) for (let c = 0; c < u; c++) o += l;
        }
        return o;
      }
      block(i, s) {
        let o = this.raw(i, "between", "beforeOpen");
        this.builder(s + o + "{", i, "start");
        let a;
        i.nodes && i.nodes.length ? (this.body(i), a = this.raw(i, "after")) : a = this.raw(i, "after", "emptyBody"), a && this.builder(a), this.builder("}", i, "end");
      }
      body(i) {
        let s = i.nodes.length - 1;
        for (; s > 0 && i.nodes[s].type === "comment"; ) s -= 1;
        let o = this.raw(i, "semicolon");
        for (let a = 0; a < i.nodes.length; a++) {
          let u = i.nodes[a], l = this.raw(u, "before");
          l && this.builder(l), this.stringify(u, s !== a || o);
        }
      }
      comment(i) {
        let s = this.raw(i, "left", "commentLeft"), o = this.raw(i, "right", "commentRight");
        this.builder("/*" + s + i.text + o + "*/", i);
      }
      decl(i, s) {
        let o = this.raw(i, "between", "colon"), a = i.prop + o + this.rawValue(i, "value");
        i.important && (a += i.raws.important || " !important"), s && (a += ";"), this.builder(a, i);
      }
      document(i) {
        this.body(i);
      }
      raw(i, s, o) {
        let a;
        if (o || (o = s), s && (a = i.raws[s], typeof a < "u")) return a;
        let u = i.parent;
        if (o === "before" && (!u || u.type === "root" && u.first === i || u && u.type === "document")) return "";
        if (!u) return n[o];
        let l = i.root();
        if (l.rawCache || (l.rawCache = {}), typeof l.rawCache[o] < "u") return l.rawCache[o];
        if (o === "before" || o === "after") return this.beforeAfter(i, o);
        {
          let c = "raw" + e(o);
          this[c] ? a = this[c](l, i) : l.walk((h) => {
            if (a = h.raws[s], typeof a < "u") return false;
          });
        }
        return typeof a > "u" && (a = n[o]), l.rawCache[o] = a, a;
      }
      rawBeforeClose(i) {
        let s;
        return i.walk((o) => {
          if (o.nodes && o.nodes.length > 0 && typeof o.raws.after < "u") return s = o.raws.after, s.includes(`
`) && (s = s.replace(/[^\n]+$/, "")), false;
        }), s && (s = s.replace(/\S/g, "")), s;
      }
      rawBeforeComment(i, s) {
        let o;
        return i.walkComments((a) => {
          if (typeof a.raws.before < "u") return o = a.raws.before, o.includes(`
`) && (o = o.replace(/[^\n]+$/, "")), false;
        }), typeof o > "u" ? o = this.raw(s, null, "beforeDecl") : o && (o = o.replace(/\S/g, "")), o;
      }
      rawBeforeDecl(i, s) {
        let o;
        return i.walkDecls((a) => {
          if (typeof a.raws.before < "u") return o = a.raws.before, o.includes(`
`) && (o = o.replace(/[^\n]+$/, "")), false;
        }), typeof o > "u" ? o = this.raw(s, null, "beforeRule") : o && (o = o.replace(/\S/g, "")), o;
      }
      rawBeforeOpen(i) {
        let s;
        return i.walk((o) => {
          if (o.type !== "decl" && (s = o.raws.between, typeof s < "u")) return false;
        }), s;
      }
      rawBeforeRule(i) {
        let s;
        return i.walk((o) => {
          if (o.nodes && (o.parent !== i || i.first !== o) && typeof o.raws.before < "u") return s = o.raws.before, s.includes(`
`) && (s = s.replace(/[^\n]+$/, "")), false;
        }), s && (s = s.replace(/\S/g, "")), s;
      }
      rawColon(i) {
        let s;
        return i.walkDecls((o) => {
          if (typeof o.raws.between < "u") return s = o.raws.between.replace(/[^\s:]/g, ""), false;
        }), s;
      }
      rawEmptyBody(i) {
        let s;
        return i.walk((o) => {
          if (o.nodes && o.nodes.length === 0 && (s = o.raws.after, typeof s < "u")) return false;
        }), s;
      }
      rawIndent(i) {
        if (i.raws.indent) return i.raws.indent;
        let s;
        return i.walk((o) => {
          let a = o.parent;
          if (a && a !== i && a.parent && a.parent === i && typeof o.raws.before < "u") {
            let u = o.raws.before.split(`
`);
            return s = u[u.length - 1], s = s.replace(/\S/g, ""), false;
          }
        }), s;
      }
      rawSemicolon(i) {
        let s;
        return i.walk((o) => {
          if (o.nodes && o.nodes.length && o.last.type === "decl" && (s = o.raws.semicolon, typeof s < "u")) return false;
        }), s;
      }
      rawValue(i, s) {
        let o = i[s], a = i.raws[s];
        return a && a.value === o ? a.raw : o;
      }
      root(i) {
        this.body(i), i.raws.after && this.builder(i.raws.after);
      }
      rule(i) {
        this.block(i, this.rawValue(i, "selector")), i.raws.ownSemicolon && this.builder(i.raws.ownSemicolon, i, "end");
      }
      stringify(i, s) {
        if (!this[i.type]) throw new Error("Unknown AST node type " + i.type + ". Maybe you need to change PostCSS stringifier.");
        this[i.type](i, s);
      }
    }
    return Fa = t, t.default = t, Fa;
  }
  var za, pf;
  function Yo() {
    if (pf) return za;
    pf = 1;
    let n = G0();
    function e(t, r) {
      new n(r).stringify(t);
    }
    return za = e, e.default = e, za;
  }
  var Cs = {}, mf;
  function Vl() {
    return mf || (mf = 1, Cs.isClean = Symbol("isClean"), Cs.my = Symbol("my")), Cs;
  }
  var ja, gf;
  function Xo() {
    if (gf) return ja;
    gf = 1;
    let n = $l(), e = G0(), t = Yo(), { isClean: r, my: i } = Vl();
    function s(u, l) {
      let c = new u.constructor();
      for (let h in u) {
        if (!Object.prototype.hasOwnProperty.call(u, h) || h === "proxyCache") continue;
        let d = u[h], f = typeof d;
        h === "parent" && f === "object" ? l && (c[h] = l) : h === "source" ? c[h] = d : Array.isArray(d) ? c[h] = d.map((p) => s(p, c)) : (f === "object" && d !== null && (d = s(d)), c[h] = d);
      }
      return c;
    }
    function o(u, l) {
      if (l && typeof l.offset < "u") return l.offset;
      let c = 1, h = 1, d = 0;
      for (let f = 0; f < u.length; f++) {
        if (h === l.line && c === l.column) {
          d = f;
          break;
        }
        u[f] === `
` ? (c = 1, h += 1) : c += 1;
      }
      return d;
    }
    class a {
      get proxyOf() {
        return this;
      }
      constructor(l = {}) {
        this.raws = {}, this[r] = false, this[i] = true;
        for (let c in l) if (c === "nodes") {
          this.nodes = [];
          for (let h of l[c]) typeof h.clone == "function" ? this.append(h.clone()) : this.append(h);
        } else this[c] = l[c];
      }
      addToError(l) {
        if (l.postcssNode = this, l.stack && this.source && /\n\s{4}at /.test(l.stack)) {
          let c = this.source;
          l.stack = l.stack.replace(/\n\s{4}at /, `$&${c.input.from}:${c.start.line}:${c.start.column}$&`);
        }
        return l;
      }
      after(l) {
        return this.parent.insertAfter(this, l), this;
      }
      assign(l = {}) {
        for (let c in l) this[c] = l[c];
        return this;
      }
      before(l) {
        return this.parent.insertBefore(this, l), this;
      }
      cleanRaws(l) {
        delete this.raws.before, delete this.raws.after, l || delete this.raws.between;
      }
      clone(l = {}) {
        let c = s(this);
        for (let h in l) c[h] = l[h];
        return c;
      }
      cloneAfter(l = {}) {
        let c = this.clone(l);
        return this.parent.insertAfter(this, c), c;
      }
      cloneBefore(l = {}) {
        let c = this.clone(l);
        return this.parent.insertBefore(this, c), c;
      }
      error(l, c = {}) {
        if (this.source) {
          let { end: h, start: d } = this.rangeBy(c);
          return this.source.input.error(l, {
            column: d.column,
            line: d.line
          }, {
            column: h.column,
            line: h.line
          }, c);
        }
        return new n(l);
      }
      getProxyProcessor() {
        return {
          get(l, c) {
            return c === "proxyOf" ? l : c === "root" ? () => l.root().toProxy() : l[c];
          },
          set(l, c, h) {
            return l[c] === h || (l[c] = h, (c === "prop" || c === "value" || c === "name" || c === "params" || c === "important" || c === "text") && l.markDirty()), true;
          }
        };
      }
      markClean() {
        this[r] = true;
      }
      markDirty() {
        if (this[r]) {
          this[r] = false;
          let l = this;
          for (; l = l.parent; ) l[r] = false;
        }
      }
      next() {
        if (!this.parent) return;
        let l = this.parent.index(this);
        return this.parent.nodes[l + 1];
      }
      positionBy(l) {
        let c = this.source.start;
        if (l.index) c = this.positionInside(l.index);
        else if (l.word) {
          let h = "document" in this.source.input ? this.source.input.document : this.source.input.css, f = h.slice(o(h, this.source.start), o(h, this.source.end)).indexOf(l.word);
          f !== -1 && (c = this.positionInside(f));
        }
        return c;
      }
      positionInside(l) {
        let c = this.source.start.column, h = this.source.start.line, d = "document" in this.source.input ? this.source.input.document : this.source.input.css, f = o(d, this.source.start), p = f + l;
        for (let m = f; m < p; m++) d[m] === `
` ? (c = 1, h += 1) : c += 1;
        return {
          column: c,
          line: h
        };
      }
      prev() {
        if (!this.parent) return;
        let l = this.parent.index(this);
        return this.parent.nodes[l - 1];
      }
      rangeBy(l) {
        let c = {
          column: this.source.start.column,
          line: this.source.start.line
        }, h = this.source.end ? {
          column: this.source.end.column + 1,
          line: this.source.end.line
        } : {
          column: c.column + 1,
          line: c.line
        };
        if (l.word) {
          let d = "document" in this.source.input ? this.source.input.document : this.source.input.css, p = d.slice(o(d, this.source.start), o(d, this.source.end)).indexOf(l.word);
          p !== -1 && (c = this.positionInside(p), h = this.positionInside(p + l.word.length));
        } else l.start ? c = {
          column: l.start.column,
          line: l.start.line
        } : l.index && (c = this.positionInside(l.index)), l.end ? h = {
          column: l.end.column,
          line: l.end.line
        } : typeof l.endIndex == "number" ? h = this.positionInside(l.endIndex) : l.index && (h = this.positionInside(l.index + 1));
        return (h.line < c.line || h.line === c.line && h.column <= c.column) && (h = {
          column: c.column + 1,
          line: c.line
        }), {
          end: h,
          start: c
        };
      }
      raw(l, c) {
        return new e().raw(this, l, c);
      }
      remove() {
        return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
      }
      replaceWith(...l) {
        if (this.parent) {
          let c = this, h = false;
          for (let d of l) d === this ? h = true : h ? (this.parent.insertAfter(c, d), c = d) : this.parent.insertBefore(c, d);
          h || this.remove();
        }
        return this;
      }
      root() {
        let l = this;
        for (; l.parent && l.parent.type !== "document"; ) l = l.parent;
        return l;
      }
      toJSON(l, c) {
        let h = {}, d = c == null;
        c = c || /* @__PURE__ */ new Map();
        let f = 0;
        for (let p in this) {
          if (!Object.prototype.hasOwnProperty.call(this, p) || p === "parent" || p === "proxyCache") continue;
          let m = this[p];
          if (Array.isArray(m)) h[p] = m.map((b) => typeof b == "object" && b.toJSON ? b.toJSON(null, c) : b);
          else if (typeof m == "object" && m.toJSON) h[p] = m.toJSON(null, c);
          else if (p === "source") {
            let b = c.get(m.input);
            b == null && (b = f, c.set(m.input, f), f++), h[p] = {
              end: m.end,
              inputId: b,
              start: m.start
            };
          } else h[p] = m;
        }
        return d && (h.inputs = [
          ...c.keys()
        ].map((p) => p.toJSON())), h;
      }
      toProxy() {
        return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
      }
      toString(l = t) {
        l.stringify && (l = l.stringify);
        let c = "";
        return l(this, (h) => {
          c += h;
        }), c;
      }
      warn(l, c, h) {
        let d = {
          node: this
        };
        for (let f in h) d[f] = h[f];
        return l.warn(c, d);
      }
    }
    return ja = a, a.default = a, ja;
  }
  var qa, bf;
  function Qo() {
    if (bf) return qa;
    bf = 1;
    let n = Xo();
    class e extends n {
      constructor(r) {
        super(r), this.type = "comment";
      }
    }
    return qa = e, e.default = e, qa;
  }
  var $a, yf;
  function Zo() {
    if (yf) return $a;
    yf = 1;
    let n = Xo();
    class e extends n {
      get variable() {
        return this.prop.startsWith("--") || this.prop[0] === "$";
      }
      constructor(r) {
        r && typeof r.value < "u" && typeof r.value != "string" && (r = {
          ...r,
          value: String(r.value)
        }), super(r), this.type = "decl";
      }
    }
    return $a = e, e.default = e, $a;
  }
  var Va, vf;
  function Wr() {
    if (vf) return Va;
    vf = 1;
    let n = Qo(), e = Zo(), t = Xo(), { isClean: r, my: i } = Vl(), s, o, a, u;
    function l(d) {
      return d.map((f) => (f.nodes && (f.nodes = l(f.nodes)), delete f.source, f));
    }
    function c(d) {
      if (d[r] = false, d.proxyOf.nodes) for (let f of d.proxyOf.nodes) c(f);
    }
    class h extends t {
      get first() {
        if (this.proxyOf.nodes) return this.proxyOf.nodes[0];
      }
      get last() {
        if (this.proxyOf.nodes) return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
      }
      append(...f) {
        for (let p of f) {
          let m = this.normalize(p, this.last);
          for (let b of m) this.proxyOf.nodes.push(b);
        }
        return this.markDirty(), this;
      }
      cleanRaws(f) {
        if (super.cleanRaws(f), this.nodes) for (let p of this.nodes) p.cleanRaws(f);
      }
      each(f) {
        if (!this.proxyOf.nodes) return;
        let p = this.getIterator(), m, b;
        for (; this.indexes[p] < this.proxyOf.nodes.length && (m = this.indexes[p], b = f(this.proxyOf.nodes[m], m), b !== false); ) this.indexes[p] += 1;
        return delete this.indexes[p], b;
      }
      every(f) {
        return this.nodes.every(f);
      }
      getIterator() {
        this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
        let f = this.lastEach;
        return this.indexes[f] = 0, f;
      }
      getProxyProcessor() {
        return {
          get(f, p) {
            return p === "proxyOf" ? f : f[p] ? p === "each" || typeof p == "string" && p.startsWith("walk") ? (...m) => f[p](...m.map((b) => typeof b == "function" ? (g, w) => b(g.toProxy(), w) : b)) : p === "every" || p === "some" ? (m) => f[p]((b, ...g) => m(b.toProxy(), ...g)) : p === "root" ? () => f.root().toProxy() : p === "nodes" ? f.nodes.map((m) => m.toProxy()) : p === "first" || p === "last" ? f[p].toProxy() : f[p] : f[p];
          },
          set(f, p, m) {
            return f[p] === m || (f[p] = m, (p === "name" || p === "params" || p === "selector") && f.markDirty()), true;
          }
        };
      }
      index(f) {
        return typeof f == "number" ? f : (f.proxyOf && (f = f.proxyOf), this.proxyOf.nodes.indexOf(f));
      }
      insertAfter(f, p) {
        let m = this.index(f), b = this.normalize(p, this.proxyOf.nodes[m]).reverse();
        m = this.index(f);
        for (let w of b) this.proxyOf.nodes.splice(m + 1, 0, w);
        let g;
        for (let w in this.indexes) g = this.indexes[w], m < g && (this.indexes[w] = g + b.length);
        return this.markDirty(), this;
      }
      insertBefore(f, p) {
        let m = this.index(f), b = m === 0 ? "prepend" : false, g = this.normalize(p, this.proxyOf.nodes[m], b).reverse();
        m = this.index(f);
        for (let v of g) this.proxyOf.nodes.splice(m, 0, v);
        let w;
        for (let v in this.indexes) w = this.indexes[v], m <= w && (this.indexes[v] = w + g.length);
        return this.markDirty(), this;
      }
      normalize(f, p) {
        if (typeof f == "string") f = l(o(f).nodes);
        else if (typeof f > "u") f = [];
        else if (Array.isArray(f)) {
          f = f.slice(0);
          for (let b of f) b.parent && b.parent.removeChild(b, "ignore");
        } else if (f.type === "root" && this.type !== "document") {
          f = f.nodes.slice(0);
          for (let b of f) b.parent && b.parent.removeChild(b, "ignore");
        } else if (f.type) f = [
          f
        ];
        else if (f.prop) {
          if (typeof f.value > "u") throw new Error("Value field is missed in node creation");
          typeof f.value != "string" && (f.value = String(f.value)), f = [
            new e(f)
          ];
        } else if (f.selector || f.selectors) f = [
          new u(f)
        ];
        else if (f.name) f = [
          new s(f)
        ];
        else if (f.text) f = [
          new n(f)
        ];
        else throw new Error("Unknown node type in node creation");
        return f.map((b) => (b[i] || h.rebuild(b), b = b.proxyOf, b.parent && b.parent.removeChild(b), b[r] && c(b), b.raws || (b.raws = {}), typeof b.raws.before > "u" && p && typeof p.raws.before < "u" && (b.raws.before = p.raws.before.replace(/\S/g, "")), b.parent = this.proxyOf, b));
      }
      prepend(...f) {
        f = f.reverse();
        for (let p of f) {
          let m = this.normalize(p, this.first, "prepend").reverse();
          for (let b of m) this.proxyOf.nodes.unshift(b);
          for (let b in this.indexes) this.indexes[b] = this.indexes[b] + m.length;
        }
        return this.markDirty(), this;
      }
      push(f) {
        return f.parent = this, this.proxyOf.nodes.push(f), this;
      }
      removeAll() {
        for (let f of this.proxyOf.nodes) f.parent = void 0;
        return this.proxyOf.nodes = [], this.markDirty(), this;
      }
      removeChild(f) {
        f = this.index(f), this.proxyOf.nodes[f].parent = void 0, this.proxyOf.nodes.splice(f, 1);
        let p;
        for (let m in this.indexes) p = this.indexes[m], p >= f && (this.indexes[m] = p - 1);
        return this.markDirty(), this;
      }
      replaceValues(f, p, m) {
        return m || (m = p, p = {}), this.walkDecls((b) => {
          p.props && !p.props.includes(b.prop) || p.fast && !b.value.includes(p.fast) || (b.value = b.value.replace(f, m));
        }), this.markDirty(), this;
      }
      some(f) {
        return this.nodes.some(f);
      }
      walk(f) {
        return this.each((p, m) => {
          let b;
          try {
            b = f(p, m);
          } catch (g) {
            throw p.addToError(g);
          }
          return b !== false && p.walk && (b = p.walk(f)), b;
        });
      }
      walkAtRules(f, p) {
        return p ? f instanceof RegExp ? this.walk((m, b) => {
          if (m.type === "atrule" && f.test(m.name)) return p(m, b);
        }) : this.walk((m, b) => {
          if (m.type === "atrule" && m.name === f) return p(m, b);
        }) : (p = f, this.walk((m, b) => {
          if (m.type === "atrule") return p(m, b);
        }));
      }
      walkComments(f) {
        return this.walk((p, m) => {
          if (p.type === "comment") return f(p, m);
        });
      }
      walkDecls(f, p) {
        return p ? f instanceof RegExp ? this.walk((m, b) => {
          if (m.type === "decl" && f.test(m.prop)) return p(m, b);
        }) : this.walk((m, b) => {
          if (m.type === "decl" && m.prop === f) return p(m, b);
        }) : (p = f, this.walk((m, b) => {
          if (m.type === "decl") return p(m, b);
        }));
      }
      walkRules(f, p) {
        return p ? f instanceof RegExp ? this.walk((m, b) => {
          if (m.type === "rule" && f.test(m.selector)) return p(m, b);
        }) : this.walk((m, b) => {
          if (m.type === "rule" && m.selector === f) return p(m, b);
        }) : (p = f, this.walk((m, b) => {
          if (m.type === "rule") return p(m, b);
        }));
      }
    }
    return h.registerParse = (d) => {
      o = d;
    }, h.registerRule = (d) => {
      u = d;
    }, h.registerAtRule = (d) => {
      s = d;
    }, h.registerRoot = (d) => {
      a = d;
    }, Va = h, h.default = h, h.rebuild = (d) => {
      d.type === "atrule" ? Object.setPrototypeOf(d, s.prototype) : d.type === "rule" ? Object.setPrototypeOf(d, u.prototype) : d.type === "decl" ? Object.setPrototypeOf(d, e.prototype) : d.type === "comment" ? Object.setPrototypeOf(d, n.prototype) : d.type === "root" && Object.setPrototypeOf(d, a.prototype), d[i] = true, d.nodes && d.nodes.forEach((f) => {
        h.rebuild(f);
      });
    }, Va;
  }
  var Ha, wf;
  function Hl() {
    if (wf) return Ha;
    wf = 1;
    let n = Wr();
    class e extends n {
      constructor(r) {
        super(r), this.type = "atrule";
      }
      append(...r) {
        return this.proxyOf.nodes || (this.nodes = []), super.append(...r);
      }
      prepend(...r) {
        return this.proxyOf.nodes || (this.nodes = []), super.prepend(...r);
      }
    }
    return Ha = e, e.default = e, n.registerAtRule(e), Ha;
  }
  var Wa, xf;
  function Wl() {
    if (xf) return Wa;
    xf = 1;
    let n = Wr(), e, t;
    class r extends n {
      constructor(s) {
        super({
          type: "document",
          ...s
        }), this.nodes || (this.nodes = []);
      }
      toResult(s = {}) {
        return new e(new t(), this, s).stringify();
      }
    }
    return r.registerLazyResult = (i) => {
      e = i;
    }, r.registerProcessor = (i) => {
      t = i;
    }, Wa = r, r.default = r, Wa;
  }
  var Ua, kf;
  function Gk() {
    if (kf) return Ua;
    kf = 1;
    let n = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    return Ua = {
      nanoid: (r = 21) => {
        let i = "", s = r | 0;
        for (; s--; ) i += n[Math.random() * 64 | 0];
        return i;
      },
      customAlphabet: (r, i = 21) => (s = i) => {
        let o = "", a = s | 0;
        for (; a--; ) o += r[Math.random() * r.length | 0];
        return o;
      }
    }, Ua;
  }
  var Ga, Sf;
  function K0() {
    if (Sf) return Ga;
    Sf = 1;
    let { existsSync: n, readFileSync: e } = ln, { dirname: t, join: r } = ln, { SourceMapConsumer: i, SourceMapGenerator: s } = ln;
    function o(u) {
      return Buffer ? Buffer.from(u, "base64").toString() : window.atob(u);
    }
    class a {
      constructor(l, c) {
        if (c.map === false) return;
        this.loadAnnotation(l), this.inline = this.startWith(this.annotation, "data:");
        let h = c.map ? c.map.prev : void 0, d = this.loadMap(c.from, h);
        !this.mapFile && c.from && (this.mapFile = c.from), this.mapFile && (this.root = t(this.mapFile)), d && (this.text = d);
      }
      consumer() {
        return this.consumerCache || (this.consumerCache = new i(this.text)), this.consumerCache;
      }
      decodeInline(l) {
        let c = /^data:application\/json;charset=utf-?8;base64,/, h = /^data:application\/json;base64,/, d = /^data:application\/json;charset=utf-?8,/, f = /^data:application\/json,/, p = l.match(d) || l.match(f);
        if (p) return decodeURIComponent(l.substr(p[0].length));
        let m = l.match(c) || l.match(h);
        if (m) return o(l.substr(m[0].length));
        let b = l.match(/data:application\/json;([^,]+),/)[1];
        throw new Error("Unsupported source map encoding " + b);
      }
      getAnnotationURL(l) {
        return l.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
      }
      isMap(l) {
        return typeof l != "object" ? false : typeof l.mappings == "string" || typeof l._mappings == "string" || Array.isArray(l.sections);
      }
      loadAnnotation(l) {
        let c = l.match(/\/\*\s*# sourceMappingURL=/g);
        if (!c) return;
        let h = l.lastIndexOf(c.pop()), d = l.indexOf("*/", h);
        h > -1 && d > -1 && (this.annotation = this.getAnnotationURL(l.substring(h, d)));
      }
      loadFile(l) {
        if (this.root = t(l), n(l)) return this.mapFile = l, e(l, "utf-8").toString().trim();
      }
      loadMap(l, c) {
        if (c === false) return false;
        if (c) {
          if (typeof c == "string") return c;
          if (typeof c == "function") {
            let h = c(l);
            if (h) {
              let d = this.loadFile(h);
              if (!d) throw new Error("Unable to load previous source map: " + h.toString());
              return d;
            }
          } else {
            if (c instanceof i) return s.fromSourceMap(c).toString();
            if (c instanceof s) return c.toString();
            if (this.isMap(c)) return JSON.stringify(c);
            throw new Error("Unsupported previous source map format: " + c.toString());
          }
        } else {
          if (this.inline) return this.decodeInline(this.annotation);
          if (this.annotation) {
            let h = this.annotation;
            return l && (h = r(t(l), h)), this.loadFile(h);
          }
        }
      }
      startWith(l, c) {
        return l ? l.substr(0, c.length) === c : false;
      }
      withContent() {
        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
      }
    }
    return Ga = a, a.default = a, Ga;
  }
  var Ka, Tf;
  function ea() {
    if (Tf) return Ka;
    Tf = 1;
    let { nanoid: n } = Gk(), { isAbsolute: e, resolve: t } = ln, { SourceMapConsumer: r, SourceMapGenerator: i } = ln, { fileURLToPath: s, pathToFileURL: o } = ln, a = $l(), u = K0(), l = ln, c = Symbol("fromOffsetCache"), h = !!(r && i), d = !!(t && e);
    class f {
      get from() {
        return this.file || this.id;
      }
      constructor(m, b = {}) {
        if (m === null || typeof m > "u" || typeof m == "object" && !m.toString) throw new Error(`PostCSS received ${m} instead of CSS string`);
        if (this.css = m.toString(), this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE" ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, this.document = this.css, b.document && (this.document = b.document.toString()), b.from && (!d || /^\w+:\/\//.test(b.from) || e(b.from) ? this.file = b.from : this.file = t(b.from)), d && h) {
          let g = new u(this.css, b);
          if (g.text) {
            this.map = g;
            let w = g.consumer().file;
            !this.file && w && (this.file = this.mapResolve(w));
          }
        }
        this.file || (this.id = "<input css " + n(6) + ">"), this.map && (this.map.file = this.from);
      }
      error(m, b, g, w = {}) {
        let v, y, x;
        if (b && typeof b == "object") {
          let T = b, M = g;
          if (typeof T.offset == "number") {
            let D = this.fromOffset(T.offset);
            b = D.line, g = D.col;
          } else b = T.line, g = T.column;
          if (typeof M.offset == "number") {
            let D = this.fromOffset(M.offset);
            y = D.line, v = D.col;
          } else y = M.line, v = M.column;
        } else if (!g) {
          let T = this.fromOffset(b);
          b = T.line, g = T.col;
        }
        let k = this.origin(b, g, y, v);
        return k ? x = new a(m, k.endLine === void 0 ? k.line : {
          column: k.column,
          line: k.line
        }, k.endLine === void 0 ? k.column : {
          column: k.endColumn,
          line: k.endLine
        }, k.source, k.file, w.plugin) : x = new a(m, y === void 0 ? b : {
          column: g,
          line: b
        }, y === void 0 ? g : {
          column: v,
          line: y
        }, this.css, this.file, w.plugin), x.input = {
          column: g,
          endColumn: v,
          endLine: y,
          line: b,
          source: this.css
        }, this.file && (o && (x.input.url = o(this.file).toString()), x.input.file = this.file), x;
      }
      fromOffset(m) {
        let b, g;
        if (this[c]) g = this[c];
        else {
          let v = this.css.split(`
`);
          g = new Array(v.length);
          let y = 0;
          for (let x = 0, k = v.length; x < k; x++) g[x] = y, y += v[x].length + 1;
          this[c] = g;
        }
        b = g[g.length - 1];
        let w = 0;
        if (m >= b) w = g.length - 1;
        else {
          let v = g.length - 2, y;
          for (; w < v; ) if (y = w + (v - w >> 1), m < g[y]) v = y - 1;
          else if (m >= g[y + 1]) w = y + 1;
          else {
            w = y;
            break;
          }
        }
        return {
          col: m - g[w] + 1,
          line: w + 1
        };
      }
      mapResolve(m) {
        return /^\w+:\/\//.test(m) ? m : t(this.map.consumer().sourceRoot || this.map.root || ".", m);
      }
      origin(m, b, g, w) {
        if (!this.map) return false;
        let v = this.map.consumer(), y = v.originalPositionFor({
          column: b,
          line: m
        });
        if (!y.source) return false;
        let x;
        typeof g == "number" && (x = v.originalPositionFor({
          column: w,
          line: g
        }));
        let k;
        e(y.source) ? k = o(y.source) : k = new URL(y.source, this.map.consumer().sourceRoot || o(this.map.mapFile));
        let T = {
          column: y.column,
          endColumn: x && x.column,
          endLine: x && x.line,
          line: y.line,
          url: k.toString()
        };
        if (k.protocol === "file:") if (s) T.file = s(k);
        else throw new Error("file: protocol is not available in this PostCSS build");
        let M = v.sourceContentFor(y.source);
        return M && (T.source = M), T;
      }
      toJSON() {
        let m = {};
        for (let b of [
          "hasBOM",
          "css",
          "file",
          "id"
        ]) this[b] != null && (m[b] = this[b]);
        return this.map && (m.map = {
          ...this.map
        }, m.map.consumerCache && (m.map.consumerCache = void 0)), m;
      }
    }
    return Ka = f, f.default = f, l && l.registerInput && l.registerInput(f), Ka;
  }
  var Ja, Ef;
  function ss() {
    if (Ef) return Ja;
    Ef = 1;
    let n = Wr(), e, t;
    class r extends n {
      constructor(s) {
        super(s), this.type = "root", this.nodes || (this.nodes = []);
      }
      normalize(s, o, a) {
        let u = super.normalize(s);
        if (o) {
          if (a === "prepend") this.nodes.length > 1 ? o.raws.before = this.nodes[1].raws.before : delete o.raws.before;
          else if (this.first !== o) for (let l of u) l.raws.before = o.raws.before;
        }
        return u;
      }
      removeChild(s, o) {
        let a = this.index(s);
        return !o && a === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[a].raws.before), super.removeChild(s);
      }
      toResult(s = {}) {
        return new e(new t(), this, s).stringify();
      }
    }
    return r.registerLazyResult = (i) => {
      e = i;
    }, r.registerProcessor = (i) => {
      t = i;
    }, Ja = r, r.default = r, n.registerRoot(r), Ja;
  }
  var Ya, Cf;
  function J0() {
    if (Cf) return Ya;
    Cf = 1;
    let n = {
      comma(e) {
        return n.split(e, [
          ","
        ], true);
      },
      space(e) {
        let t = [
          " ",
          `
`,
          "	"
        ];
        return n.split(e, t);
      },
      split(e, t, r) {
        let i = [], s = "", o = false, a = 0, u = false, l = "", c = false;
        for (let h of e) c ? c = false : h === "\\" ? c = true : u ? h === l && (u = false) : h === '"' || h === "'" ? (u = true, l = h) : h === "(" ? a += 1 : h === ")" ? a > 0 && (a -= 1) : a === 0 && t.includes(h) && (o = true), o ? (s !== "" && i.push(s.trim()), s = "", o = false) : s += h;
        return (r || s !== "") && i.push(s.trim()), i;
      }
    };
    return Ya = n, n.default = n, Ya;
  }
  var Xa, Of;
  function Ul() {
    if (Of) return Xa;
    Of = 1;
    let n = Wr(), e = J0();
    class t extends n {
      get selectors() {
        return e.comma(this.selector);
      }
      set selectors(i) {
        let s = this.selector ? this.selector.match(/,\s*/) : null, o = s ? s[0] : "," + this.raw("between", "beforeOpen");
        this.selector = i.join(o);
      }
      constructor(i) {
        super(i), this.type = "rule", this.nodes || (this.nodes = []);
      }
    }
    return Xa = t, t.default = t, n.registerRule(t), Xa;
  }
  var Qa, Af;
  function Kk() {
    if (Af) return Qa;
    Af = 1;
    let n = Hl(), e = Qo(), t = Zo(), r = ea(), i = K0(), s = ss(), o = Ul();
    function a(u, l) {
      if (Array.isArray(u)) return u.map((d) => a(d));
      let { inputs: c, ...h } = u;
      if (c) {
        l = [];
        for (let d of c) {
          let f = {
            ...d,
            __proto__: r.prototype
          };
          f.map && (f.map = {
            ...f.map,
            __proto__: i.prototype
          }), l.push(f);
        }
      }
      if (h.nodes && (h.nodes = u.nodes.map((d) => a(d, l))), h.source) {
        let { inputId: d, ...f } = h.source;
        h.source = f, d != null && (h.source.input = l[d]);
      }
      if (h.type === "root") return new s(h);
      if (h.type === "decl") return new t(h);
      if (h.type === "rule") return new o(h);
      if (h.type === "comment") return new e(h);
      if (h.type === "atrule") return new n(h);
      throw new Error("Unknown node type: " + u.type);
    }
    return Qa = a, a.default = a, Qa;
  }
  var Za, Mf;
  function Y0() {
    if (Mf) return Za;
    Mf = 1;
    let { dirname: n, relative: e, resolve: t, sep: r } = ln, { SourceMapConsumer: i, SourceMapGenerator: s } = ln, { pathToFileURL: o } = ln, a = ea(), u = !!(i && s), l = !!(n && t && e && r);
    class c {
      constructor(d, f, p, m) {
        this.stringify = d, this.mapOpts = p.map || {}, this.root = f, this.opts = p, this.css = m, this.originalCSS = m, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
      }
      addAnnotation() {
        let d;
        this.isInline() ? d = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? d = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? d = this.mapOpts.annotation(this.opts.to, this.root) : d = this.outputFile() + ".map";
        let f = `
`;
        this.css.includes(`\r
`) && (f = `\r
`), this.css += f + "/*# sourceMappingURL=" + d + " */";
      }
      applyPrevMaps() {
        for (let d of this.previous()) {
          let f = this.toUrl(this.path(d.file)), p = d.root || n(d.file), m;
          this.mapOpts.sourcesContent === false ? (m = new i(d.text), m.sourcesContent && (m.sourcesContent = null)) : m = d.consumer(), this.map.applySourceMap(m, f, this.toUrl(this.path(p)));
        }
      }
      clearAnnotation() {
        if (this.mapOpts.annotation !== false) if (this.root) {
          let d;
          for (let f = this.root.nodes.length - 1; f >= 0; f--) d = this.root.nodes[f], d.type === "comment" && d.text.startsWith("# sourceMappingURL=") && this.root.removeChild(f);
        } else this.css && (this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, ""));
      }
      generate() {
        if (this.clearAnnotation(), l && u && this.isMap()) return this.generateMap();
        {
          let d = "";
          return this.stringify(this.root, (f) => {
            d += f;
          }), [
            d
          ];
        }
      }
      generateMap() {
        if (this.root) this.generateString();
        else if (this.previous().length === 1) {
          let d = this.previous()[0].consumer();
          d.file = this.outputFile(), this.map = s.fromSourceMap(d, {
            ignoreInvalidMapping: true
          });
        } else this.map = new s({
          file: this.outputFile(),
          ignoreInvalidMapping: true
        }), this.map.addMapping({
          generated: {
            column: 0,
            line: 1
          },
          original: {
            column: 0,
            line: 1
          },
          source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
        });
        return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [
          this.css
        ] : [
          this.css,
          this.map
        ];
      }
      generateString() {
        this.css = "", this.map = new s({
          file: this.outputFile(),
          ignoreInvalidMapping: true
        });
        let d = 1, f = 1, p = "<no source>", m = {
          generated: {
            column: 0,
            line: 0
          },
          original: {
            column: 0,
            line: 0
          },
          source: ""
        }, b, g;
        this.stringify(this.root, (w, v, y) => {
          if (this.css += w, v && y !== "end" && (m.generated.line = d, m.generated.column = f - 1, v.source && v.source.start ? (m.source = this.sourcePath(v), m.original.line = v.source.start.line, m.original.column = v.source.start.column - 1, this.map.addMapping(m)) : (m.source = p, m.original.line = 1, m.original.column = 0, this.map.addMapping(m))), g = w.match(/\n/g), g ? (d += g.length, b = w.lastIndexOf(`
`), f = w.length - b) : f += w.length, v && y !== "start") {
            let x = v.parent || {
              raws: {}
            };
            (!(v.type === "decl" || v.type === "atrule" && !v.nodes) || v !== x.last || x.raws.semicolon) && (v.source && v.source.end ? (m.source = this.sourcePath(v), m.original.line = v.source.end.line, m.original.column = v.source.end.column - 1, m.generated.line = d, m.generated.column = f - 2, this.map.addMapping(m)) : (m.source = p, m.original.line = 1, m.original.column = 0, m.generated.line = d, m.generated.column = f - 1, this.map.addMapping(m)));
          }
        });
      }
      isAnnotation() {
        return this.isInline() ? true : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((d) => d.annotation) : true;
      }
      isInline() {
        if (typeof this.mapOpts.inline < "u") return this.mapOpts.inline;
        let d = this.mapOpts.annotation;
        return typeof d < "u" && d !== true ? false : this.previous().length ? this.previous().some((f) => f.inline) : true;
      }
      isMap() {
        return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
      }
      isSourcesContent() {
        return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((d) => d.withContent()) : true;
      }
      outputFile() {
        return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
      }
      path(d) {
        if (this.mapOpts.absolute || d.charCodeAt(0) === 60 || /^\w+:\/\//.test(d)) return d;
        let f = this.memoizedPaths.get(d);
        if (f) return f;
        let p = this.opts.to ? n(this.opts.to) : ".";
        typeof this.mapOpts.annotation == "string" && (p = n(t(p, this.mapOpts.annotation)));
        let m = e(p, d);
        return this.memoizedPaths.set(d, m), m;
      }
      previous() {
        if (!this.previousMaps) if (this.previousMaps = [], this.root) this.root.walk((d) => {
          if (d.source && d.source.input.map) {
            let f = d.source.input.map;
            this.previousMaps.includes(f) || this.previousMaps.push(f);
          }
        });
        else {
          let d = new a(this.originalCSS, this.opts);
          d.map && this.previousMaps.push(d.map);
        }
        return this.previousMaps;
      }
      setSourcesContent() {
        let d = {};
        if (this.root) this.root.walk((f) => {
          if (f.source) {
            let p = f.source.input.from;
            if (p && !d[p]) {
              d[p] = true;
              let m = this.usesFileUrls ? this.toFileUrl(p) : this.toUrl(this.path(p));
              this.map.setSourceContent(m, f.source.input.css);
            }
          }
        });
        else if (this.css) {
          let f = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
          this.map.setSourceContent(f, this.css);
        }
      }
      sourcePath(d) {
        return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(d.source.input.from) : this.toUrl(this.path(d.source.input.from));
      }
      toBase64(d) {
        return Buffer ? Buffer.from(d).toString("base64") : window.btoa(unescape(encodeURIComponent(d)));
      }
      toFileUrl(d) {
        let f = this.memoizedFileURLs.get(d);
        if (f) return f;
        if (o) {
          let p = o(d).toString();
          return this.memoizedFileURLs.set(d, p), p;
        } else throw new Error("`map.absolute` option is not available in this PostCSS build");
      }
      toUrl(d) {
        let f = this.memoizedURLs.get(d);
        if (f) return f;
        r === "\\" && (d = d.replace(/\\/g, "/"));
        let p = encodeURI(d).replace(/[#?]/g, encodeURIComponent);
        return this.memoizedURLs.set(d, p), p;
      }
    }
    return Za = c, Za;
  }
  var eu, Nf;
  function Jk() {
    if (Nf) return eu;
    Nf = 1;
    const n = 39, e = 34, t = 92, r = 47, i = 10, s = 32, o = 12, a = 9, u = 13, l = 91, c = 93, h = 40, d = 41, f = 123, p = 125, m = 59, b = 42, g = 58, w = 64, v = /[\t\n\f\r "#'()/;[\\\]{}]/g, y = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, x = /.[\r\n"'(/\\]/, k = /[\da-f]/i;
    return eu = function(M, D = {}) {
      let I = M.css.valueOf(), C = D.ignoreErrors, O, E, N, A, R, B, z, L, V, K, pe = I.length, H = 0, ue = [], ne = [];
      function ce() {
        return H;
      }
      function Z(P) {
        throw M.error("Unclosed " + P, H);
      }
      function de() {
        return ne.length === 0 && H >= pe;
      }
      function _(P) {
        if (ne.length) return ne.pop();
        if (H >= pe) return;
        let q = P ? P.ignoreUnclosed : false;
        switch (O = I.charCodeAt(H), O) {
          case i:
          case s:
          case a:
          case u:
          case o: {
            A = H;
            do
              A += 1, O = I.charCodeAt(A);
            while (O === s || O === i || O === a || O === u || O === o);
            B = [
              "space",
              I.slice(H, A)
            ], H = A - 1;
            break;
          }
          case l:
          case c:
          case f:
          case p:
          case g:
          case m:
          case d: {
            let j = String.fromCharCode(O);
            B = [
              j,
              j,
              H
            ];
            break;
          }
          case h: {
            if (K = ue.length ? ue.pop()[1] : "", V = I.charCodeAt(H + 1), K === "url" && V !== n && V !== e && V !== s && V !== i && V !== a && V !== o && V !== u) {
              A = H;
              do {
                if (z = false, A = I.indexOf(")", A + 1), A === -1) if (C || q) {
                  A = H;
                  break;
                } else Z("bracket");
                for (L = A; I.charCodeAt(L - 1) === t; ) L -= 1, z = !z;
              } while (z);
              B = [
                "brackets",
                I.slice(H, A + 1),
                H,
                A
              ], H = A;
            } else A = I.indexOf(")", H + 1), E = I.slice(H, A + 1), A === -1 || x.test(E) ? B = [
              "(",
              "(",
              H
            ] : (B = [
              "brackets",
              E,
              H,
              A
            ], H = A);
            break;
          }
          case n:
          case e: {
            R = O === n ? "'" : '"', A = H;
            do {
              if (z = false, A = I.indexOf(R, A + 1), A === -1) if (C || q) {
                A = H + 1;
                break;
              } else Z("string");
              for (L = A; I.charCodeAt(L - 1) === t; ) L -= 1, z = !z;
            } while (z);
            B = [
              "string",
              I.slice(H, A + 1),
              H,
              A
            ], H = A;
            break;
          }
          case w: {
            v.lastIndex = H + 1, v.test(I), v.lastIndex === 0 ? A = I.length - 1 : A = v.lastIndex - 2, B = [
              "at-word",
              I.slice(H, A + 1),
              H,
              A
            ], H = A;
            break;
          }
          case t: {
            for (A = H, N = true; I.charCodeAt(A + 1) === t; ) A += 1, N = !N;
            if (O = I.charCodeAt(A + 1), N && O !== r && O !== s && O !== i && O !== a && O !== u && O !== o && (A += 1, k.test(I.charAt(A)))) {
              for (; k.test(I.charAt(A + 1)); ) A += 1;
              I.charCodeAt(A + 1) === s && (A += 1);
            }
            B = [
              "word",
              I.slice(H, A + 1),
              H,
              A
            ], H = A;
            break;
          }
          default: {
            O === r && I.charCodeAt(H + 1) === b ? (A = I.indexOf("*/", H + 2) + 1, A === 0 && (C || q ? A = I.length : Z("comment")), B = [
              "comment",
              I.slice(H, A + 1),
              H,
              A
            ], H = A) : (y.lastIndex = H + 1, y.test(I), y.lastIndex === 0 ? A = I.length - 1 : A = y.lastIndex - 2, B = [
              "word",
              I.slice(H, A + 1),
              H,
              A
            ], ue.push(B), H = A);
            break;
          }
        }
        return H++, B;
      }
      function W(P) {
        ne.push(P);
      }
      return {
        back: W,
        endOfFile: de,
        nextToken: _,
        position: ce
      };
    }, eu;
  }
  var tu, Pf;
  function Yk() {
    if (Pf) return tu;
    Pf = 1;
    let n = Hl(), e = Qo(), t = Zo(), r = ss(), i = Ul(), s = Jk();
    const o = {
      empty: true,
      space: true
    };
    function a(l) {
      for (let c = l.length - 1; c >= 0; c--) {
        let h = l[c], d = h[3] || h[2];
        if (d) return d;
      }
    }
    class u {
      constructor(c) {
        this.input = c, this.root = new r(), this.current = this.root, this.spaces = "", this.semicolon = false, this.createTokenizer(), this.root.source = {
          input: c,
          start: {
            column: 1,
            line: 1,
            offset: 0
          }
        };
      }
      atrule(c) {
        let h = new n();
        h.name = c[1].slice(1), h.name === "" && this.unnamedAtrule(h, c), this.init(h, c[2]);
        let d, f, p, m = false, b = false, g = [], w = [];
        for (; !this.tokenizer.endOfFile(); ) {
          if (c = this.tokenizer.nextToken(), d = c[0], d === "(" || d === "[" ? w.push(d === "(" ? ")" : "]") : d === "{" && w.length > 0 ? w.push("}") : d === w[w.length - 1] && w.pop(), w.length === 0) if (d === ";") {
            h.source.end = this.getPosition(c[2]), h.source.end.offset++, this.semicolon = true;
            break;
          } else if (d === "{") {
            b = true;
            break;
          } else if (d === "}") {
            if (g.length > 0) {
              for (p = g.length - 1, f = g[p]; f && f[0] === "space"; ) f = g[--p];
              f && (h.source.end = this.getPosition(f[3] || f[2]), h.source.end.offset++);
            }
            this.end(c);
            break;
          } else g.push(c);
          else g.push(c);
          if (this.tokenizer.endOfFile()) {
            m = true;
            break;
          }
        }
        h.raws.between = this.spacesAndCommentsFromEnd(g), g.length ? (h.raws.afterName = this.spacesAndCommentsFromStart(g), this.raw(h, "params", g), m && (c = g[g.length - 1], h.source.end = this.getPosition(c[3] || c[2]), h.source.end.offset++, this.spaces = h.raws.between, h.raws.between = "")) : (h.raws.afterName = "", h.params = ""), b && (h.nodes = [], this.current = h);
      }
      checkMissedSemicolon(c) {
        let h = this.colon(c);
        if (h === false) return;
        let d = 0, f;
        for (let p = h - 1; p >= 0 && (f = c[p], !(f[0] !== "space" && (d += 1, d === 2))); p--) ;
        throw this.input.error("Missed semicolon", f[0] === "word" ? f[3] + 1 : f[2]);
      }
      colon(c) {
        let h = 0, d, f, p;
        for (let [m, b] of c.entries()) {
          if (f = b, p = f[0], p === "(" && (h += 1), p === ")" && (h -= 1), h === 0 && p === ":") if (!d) this.doubleColon(f);
          else {
            if (d[0] === "word" && d[1] === "progid") continue;
            return m;
          }
          d = f;
        }
        return false;
      }
      comment(c) {
        let h = new e();
        this.init(h, c[2]), h.source.end = this.getPosition(c[3] || c[2]), h.source.end.offset++;
        let d = c[1].slice(2, -2);
        if (/^\s*$/.test(d)) h.text = "", h.raws.left = d, h.raws.right = "";
        else {
          let f = d.match(/^(\s*)([^]*\S)(\s*)$/);
          h.text = f[2], h.raws.left = f[1], h.raws.right = f[3];
        }
      }
      createTokenizer() {
        this.tokenizer = s(this.input);
      }
      decl(c, h) {
        let d = new t();
        this.init(d, c[0][2]);
        let f = c[c.length - 1];
        for (f[0] === ";" && (this.semicolon = true, c.pop()), d.source.end = this.getPosition(f[3] || f[2] || a(c)), d.source.end.offset++; c[0][0] !== "word"; ) c.length === 1 && this.unknownWord(c), d.raws.before += c.shift()[1];
        for (d.source.start = this.getPosition(c[0][2]), d.prop = ""; c.length; ) {
          let w = c[0][0];
          if (w === ":" || w === "space" || w === "comment") break;
          d.prop += c.shift()[1];
        }
        d.raws.between = "";
        let p;
        for (; c.length; ) if (p = c.shift(), p[0] === ":") {
          d.raws.between += p[1];
          break;
        } else p[0] === "word" && /\w/.test(p[1]) && this.unknownWord([
          p
        ]), d.raws.between += p[1];
        (d.prop[0] === "_" || d.prop[0] === "*") && (d.raws.before += d.prop[0], d.prop = d.prop.slice(1));
        let m = [], b;
        for (; c.length && (b = c[0][0], !(b !== "space" && b !== "comment")); ) m.push(c.shift());
        this.precheckMissedSemicolon(c);
        for (let w = c.length - 1; w >= 0; w--) {
          if (p = c[w], p[1].toLowerCase() === "!important") {
            d.important = true;
            let v = this.stringFrom(c, w);
            v = this.spacesFromEnd(c) + v, v !== " !important" && (d.raws.important = v);
            break;
          } else if (p[1].toLowerCase() === "important") {
            let v = c.slice(0), y = "";
            for (let x = w; x > 0; x--) {
              let k = v[x][0];
              if (y.trim().startsWith("!") && k !== "space") break;
              y = v.pop()[1] + y;
            }
            y.trim().startsWith("!") && (d.important = true, d.raws.important = y, c = v);
          }
          if (p[0] !== "space" && p[0] !== "comment") break;
        }
        c.some((w) => w[0] !== "space" && w[0] !== "comment") && (d.raws.between += m.map((w) => w[1]).join(""), m = []), this.raw(d, "value", m.concat(c), h), d.value.includes(":") && !h && this.checkMissedSemicolon(c);
      }
      doubleColon(c) {
        throw this.input.error("Double colon", {
          offset: c[2]
        }, {
          offset: c[2] + c[1].length
        });
      }
      emptyRule(c) {
        let h = new i();
        this.init(h, c[2]), h.selector = "", h.raws.between = "", this.current = h;
      }
      end(c) {
        this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(c[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(c);
      }
      endFile() {
        this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
      }
      freeSemicolon(c) {
        if (this.spaces += c[1], this.current.nodes) {
          let h = this.current.nodes[this.current.nodes.length - 1];
          h && h.type === "rule" && !h.raws.ownSemicolon && (h.raws.ownSemicolon = this.spaces, this.spaces = "", h.source.end = this.getPosition(c[2]), h.source.end.offset += h.raws.ownSemicolon.length);
        }
      }
      getPosition(c) {
        let h = this.input.fromOffset(c);
        return {
          column: h.col,
          line: h.line,
          offset: c
        };
      }
      init(c, h) {
        this.current.push(c), c.source = {
          input: this.input,
          start: this.getPosition(h)
        }, c.raws.before = this.spaces, this.spaces = "", c.type !== "comment" && (this.semicolon = false);
      }
      other(c) {
        let h = false, d = null, f = false, p = null, m = [], b = c[1].startsWith("--"), g = [], w = c;
        for (; w; ) {
          if (d = w[0], g.push(w), d === "(" || d === "[") p || (p = w), m.push(d === "(" ? ")" : "]");
          else if (b && f && d === "{") p || (p = w), m.push("}");
          else if (m.length === 0) if (d === ";") if (f) {
            this.decl(g, b);
            return;
          } else break;
          else if (d === "{") {
            this.rule(g);
            return;
          } else if (d === "}") {
            this.tokenizer.back(g.pop()), h = true;
            break;
          } else d === ":" && (f = true);
          else d === m[m.length - 1] && (m.pop(), m.length === 0 && (p = null));
          w = this.tokenizer.nextToken();
        }
        if (this.tokenizer.endOfFile() && (h = true), m.length > 0 && this.unclosedBracket(p), h && f) {
          if (!b) for (; g.length && (w = g[g.length - 1][0], !(w !== "space" && w !== "comment")); ) this.tokenizer.back(g.pop());
          this.decl(g, b);
        } else this.unknownWord(g);
      }
      parse() {
        let c;
        for (; !this.tokenizer.endOfFile(); ) switch (c = this.tokenizer.nextToken(), c[0]) {
          case "space":
            this.spaces += c[1];
            break;
          case ";":
            this.freeSemicolon(c);
            break;
          case "}":
            this.end(c);
            break;
          case "comment":
            this.comment(c);
            break;
          case "at-word":
            this.atrule(c);
            break;
          case "{":
            this.emptyRule(c);
            break;
          default:
            this.other(c);
            break;
        }
        this.endFile();
      }
      precheckMissedSemicolon() {
      }
      raw(c, h, d, f) {
        let p, m, b = d.length, g = "", w = true, v, y;
        for (let x = 0; x < b; x += 1) p = d[x], m = p[0], m === "space" && x === b - 1 && !f ? w = false : m === "comment" ? (y = d[x - 1] ? d[x - 1][0] : "empty", v = d[x + 1] ? d[x + 1][0] : "empty", !o[y] && !o[v] ? g.slice(-1) === "," ? w = false : g += p[1] : w = false) : g += p[1];
        if (!w) {
          let x = d.reduce((k, T) => k + T[1], "");
          c.raws[h] = {
            raw: x,
            value: g
          };
        }
        c[h] = g;
      }
      rule(c) {
        c.pop();
        let h = new i();
        this.init(h, c[0][2]), h.raws.between = this.spacesAndCommentsFromEnd(c), this.raw(h, "selector", c), this.current = h;
      }
      spacesAndCommentsFromEnd(c) {
        let h, d = "";
        for (; c.length && (h = c[c.length - 1][0], !(h !== "space" && h !== "comment")); ) d = c.pop()[1] + d;
        return d;
      }
      spacesAndCommentsFromStart(c) {
        let h, d = "";
        for (; c.length && (h = c[0][0], !(h !== "space" && h !== "comment")); ) d += c.shift()[1];
        return d;
      }
      spacesFromEnd(c) {
        let h, d = "";
        for (; c.length && (h = c[c.length - 1][0], h === "space"); ) d = c.pop()[1] + d;
        return d;
      }
      stringFrom(c, h) {
        let d = "";
        for (let f = h; f < c.length; f++) d += c[f][1];
        return c.splice(h, c.length - h), d;
      }
      unclosedBlock() {
        let c = this.current.source.start;
        throw this.input.error("Unclosed block", c.line, c.column);
      }
      unclosedBracket(c) {
        throw this.input.error("Unclosed bracket", {
          offset: c[2]
        }, {
          offset: c[2] + 1
        });
      }
      unexpectedClose(c) {
        throw this.input.error("Unexpected }", {
          offset: c[2]
        }, {
          offset: c[2] + 1
        });
      }
      unknownWord(c) {
        throw this.input.error("Unknown word " + c[0][1], {
          offset: c[0][2]
        }, {
          offset: c[0][2] + c[0][1].length
        });
      }
      unnamedAtrule(c, h) {
        throw this.input.error("At-rule without name", {
          offset: h[2]
        }, {
          offset: h[2] + h[1].length
        });
      }
    }
    return tu = u, tu;
  }
  var nu, Df;
  function Gl() {
    if (Df) return nu;
    Df = 1;
    let n = Wr(), e = ea(), t = Yk();
    function r(i, s) {
      let o = new e(i, s), a = new t(o);
      try {
        a.parse();
      } catch (u) {
        throw u;
      }
      return a.root;
    }
    return nu = r, r.default = r, n.registerParse(r), nu;
  }
  var ru, If;
  function X0() {
    if (If) return ru;
    If = 1;
    class n {
      constructor(t, r = {}) {
        if (this.type = "warning", this.text = t, r.node && r.node.source) {
          let i = r.node.rangeBy(r);
          this.line = i.start.line, this.column = i.start.column, this.endLine = i.end.line, this.endColumn = i.end.column;
        }
        for (let i in r) this[i] = r[i];
      }
      toString() {
        return this.node ? this.node.error(this.text, {
          index: this.index,
          plugin: this.plugin,
          word: this.word
        }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
      }
    }
    return ru = n, n.default = n, ru;
  }
  var iu, Rf;
  function Kl() {
    if (Rf) return iu;
    Rf = 1;
    let n = X0();
    class e {
      get content() {
        return this.css;
      }
      constructor(r, i, s) {
        this.processor = r, this.messages = [], this.root = i, this.opts = s, this.css = void 0, this.map = void 0;
      }
      toString() {
        return this.css;
      }
      warn(r, i = {}) {
        i.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (i.plugin = this.lastPlugin.postcssPlugin);
        let s = new n(r, i);
        return this.messages.push(s), s;
      }
      warnings() {
        return this.messages.filter((r) => r.type === "warning");
      }
    }
    return iu = e, e.default = e, iu;
  }
  var su, _f;
  function Q0() {
    if (_f) return su;
    _f = 1;
    let n = Wr(), e = Wl(), t = Y0(), r = Gl(), i = Kl(), s = ss(), o = Yo(), { isClean: a, my: u } = Vl();
    const l = {
      atrule: "AtRule",
      comment: "Comment",
      decl: "Declaration",
      document: "Document",
      root: "Root",
      rule: "Rule"
    }, c = {
      AtRule: true,
      AtRuleExit: true,
      Comment: true,
      CommentExit: true,
      Declaration: true,
      DeclarationExit: true,
      Document: true,
      DocumentExit: true,
      Once: true,
      OnceExit: true,
      postcssPlugin: true,
      prepare: true,
      Root: true,
      RootExit: true,
      Rule: true,
      RuleExit: true
    }, h = {
      Once: true,
      postcssPlugin: true,
      prepare: true
    }, d = 0;
    function f(v) {
      return typeof v == "object" && typeof v.then == "function";
    }
    function p(v) {
      let y = false, x = l[v.type];
      return v.type === "decl" ? y = v.prop.toLowerCase() : v.type === "atrule" && (y = v.name.toLowerCase()), y && v.append ? [
        x,
        x + "-" + y,
        d,
        x + "Exit",
        x + "Exit-" + y
      ] : y ? [
        x,
        x + "-" + y,
        x + "Exit",
        x + "Exit-" + y
      ] : v.append ? [
        x,
        d,
        x + "Exit"
      ] : [
        x,
        x + "Exit"
      ];
    }
    function m(v) {
      let y;
      return v.type === "document" ? y = [
        "Document",
        d,
        "DocumentExit"
      ] : v.type === "root" ? y = [
        "Root",
        d,
        "RootExit"
      ] : y = p(v), {
        eventIndex: 0,
        events: y,
        iterator: 0,
        node: v,
        visitorIndex: 0,
        visitors: []
      };
    }
    function b(v) {
      return v[a] = false, v.nodes && v.nodes.forEach((y) => b(y)), v;
    }
    let g = {};
    class w {
      get content() {
        return this.stringify().content;
      }
      get css() {
        return this.stringify().css;
      }
      get map() {
        return this.stringify().map;
      }
      get messages() {
        return this.sync().messages;
      }
      get opts() {
        return this.result.opts;
      }
      get processor() {
        return this.result.processor;
      }
      get root() {
        return this.sync().root;
      }
      get [Symbol.toStringTag]() {
        return "LazyResult";
      }
      constructor(y, x, k) {
        this.stringified = false, this.processed = false;
        let T;
        if (typeof x == "object" && x !== null && (x.type === "root" || x.type === "document")) T = b(x);
        else if (x instanceof w || x instanceof i) T = b(x.root), x.map && (typeof k.map > "u" && (k.map = {}), k.map.inline || (k.map.inline = false), k.map.prev = x.map);
        else {
          let M = r;
          k.syntax && (M = k.syntax.parse), k.parser && (M = k.parser), M.parse && (M = M.parse);
          try {
            T = M(x, k);
          } catch (D) {
            this.processed = true, this.error = D;
          }
          T && !T[u] && n.rebuild(T);
        }
        this.result = new i(y, T, k), this.helpers = {
          ...g,
          postcss: g,
          result: this.result
        }, this.plugins = this.processor.plugins.map((M) => typeof M == "object" && M.prepare ? {
          ...M,
          ...M.prepare(this.result)
        } : M);
      }
      async() {
        return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
      }
      catch(y) {
        return this.async().catch(y);
      }
      finally(y) {
        return this.async().then(y, y);
      }
      getAsyncError() {
        throw new Error("Use process(css).then(cb) to work with async plugins");
      }
      handleError(y, x) {
        let k = this.result.lastPlugin;
        try {
          x && x.addToError(y), this.error = y, y.name === "CssSyntaxError" && !y.plugin ? (y.plugin = k.postcssPlugin, y.setMessage()) : k.postcssVersion;
        } catch (T) {
          console && console.error && console.error(T);
        }
        return y;
      }
      prepareVisitors() {
        this.listeners = {};
        let y = (x, k, T) => {
          this.listeners[k] || (this.listeners[k] = []), this.listeners[k].push([
            x,
            T
          ]);
        };
        for (let x of this.plugins) if (typeof x == "object") for (let k in x) {
          if (!c[k] && /^[A-Z]/.test(k)) throw new Error(`Unknown event ${k} in ${x.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
          if (!h[k]) if (typeof x[k] == "object") for (let T in x[k]) T === "*" ? y(x, k, x[k][T]) : y(x, k + "-" + T.toLowerCase(), x[k][T]);
          else typeof x[k] == "function" && y(x, k, x[k]);
        }
        this.hasListener = Object.keys(this.listeners).length > 0;
      }
      async runAsync() {
        this.plugin = 0;
        for (let y = 0; y < this.plugins.length; y++) {
          let x = this.plugins[y], k = this.runOnRoot(x);
          if (f(k)) try {
            await k;
          } catch (T) {
            throw this.handleError(T);
          }
        }
        if (this.prepareVisitors(), this.hasListener) {
          let y = this.result.root;
          for (; !y[a]; ) {
            y[a] = true;
            let x = [
              m(y)
            ];
            for (; x.length > 0; ) {
              let k = this.visitTick(x);
              if (f(k)) try {
                await k;
              } catch (T) {
                let M = x[x.length - 1].node;
                throw this.handleError(T, M);
              }
            }
          }
          if (this.listeners.OnceExit) for (let [x, k] of this.listeners.OnceExit) {
            this.result.lastPlugin = x;
            try {
              if (y.type === "document") {
                let T = y.nodes.map((M) => k(M, this.helpers));
                await Promise.all(T);
              } else await k(y, this.helpers);
            } catch (T) {
              throw this.handleError(T);
            }
          }
        }
        return this.processed = true, this.stringify();
      }
      runOnRoot(y) {
        this.result.lastPlugin = y;
        try {
          if (typeof y == "object" && y.Once) {
            if (this.result.root.type === "document") {
              let x = this.result.root.nodes.map((k) => y.Once(k, this.helpers));
              return f(x[0]) ? Promise.all(x) : x;
            }
            return y.Once(this.result.root, this.helpers);
          } else if (typeof y == "function") return y(this.result.root, this.result);
        } catch (x) {
          throw this.handleError(x);
        }
      }
      stringify() {
        if (this.error) throw this.error;
        if (this.stringified) return this.result;
        this.stringified = true, this.sync();
        let y = this.result.opts, x = o;
        y.syntax && (x = y.syntax.stringify), y.stringifier && (x = y.stringifier), x.stringify && (x = x.stringify);
        let T = new t(x, this.result.root, this.result.opts).generate();
        return this.result.css = T[0], this.result.map = T[1], this.result;
      }
      sync() {
        if (this.error) throw this.error;
        if (this.processed) return this.result;
        if (this.processed = true, this.processing) throw this.getAsyncError();
        for (let y of this.plugins) {
          let x = this.runOnRoot(y);
          if (f(x)) throw this.getAsyncError();
        }
        if (this.prepareVisitors(), this.hasListener) {
          let y = this.result.root;
          for (; !y[a]; ) y[a] = true, this.walkSync(y);
          if (this.listeners.OnceExit) if (y.type === "document") for (let x of y.nodes) this.visitSync(this.listeners.OnceExit, x);
          else this.visitSync(this.listeners.OnceExit, y);
        }
        return this.result;
      }
      then(y, x) {
        return this.async().then(y, x);
      }
      toString() {
        return this.css;
      }
      visitSync(y, x) {
        for (let [k, T] of y) {
          this.result.lastPlugin = k;
          let M;
          try {
            M = T(x, this.helpers);
          } catch (D) {
            throw this.handleError(D, x.proxyOf);
          }
          if (x.type !== "root" && x.type !== "document" && !x.parent) return true;
          if (f(M)) throw this.getAsyncError();
        }
      }
      visitTick(y) {
        let x = y[y.length - 1], { node: k, visitors: T } = x;
        if (k.type !== "root" && k.type !== "document" && !k.parent) {
          y.pop();
          return;
        }
        if (T.length > 0 && x.visitorIndex < T.length) {
          let [D, I] = T[x.visitorIndex];
          x.visitorIndex += 1, x.visitorIndex === T.length && (x.visitors = [], x.visitorIndex = 0), this.result.lastPlugin = D;
          try {
            return I(k.toProxy(), this.helpers);
          } catch (C) {
            throw this.handleError(C, k);
          }
        }
        if (x.iterator !== 0) {
          let D = x.iterator, I;
          for (; I = k.nodes[k.indexes[D]]; ) if (k.indexes[D] += 1, !I[a]) {
            I[a] = true, y.push(m(I));
            return;
          }
          x.iterator = 0, delete k.indexes[D];
        }
        let M = x.events;
        for (; x.eventIndex < M.length; ) {
          let D = M[x.eventIndex];
          if (x.eventIndex += 1, D === d) {
            k.nodes && k.nodes.length && (k[a] = true, x.iterator = k.getIterator());
            return;
          } else if (this.listeners[D]) {
            x.visitors = this.listeners[D];
            return;
          }
        }
        y.pop();
      }
      walkSync(y) {
        y[a] = true;
        let x = p(y);
        for (let k of x) if (k === d) y.nodes && y.each((T) => {
          T[a] || this.walkSync(T);
        });
        else {
          let T = this.listeners[k];
          if (T && this.visitSync(T, y.toProxy())) return;
        }
      }
      warnings() {
        return this.sync().warnings();
      }
    }
    return w.registerPostcss = (v) => {
      g = v;
    }, su = w, w.default = w, s.registerLazyResult(w), e.registerLazyResult(w), su;
  }
  var ou, Lf;
  function Xk() {
    if (Lf) return ou;
    Lf = 1;
    let n = Y0(), e = Gl();
    const t = Kl();
    let r = Yo();
    class i {
      get content() {
        return this.result.css;
      }
      get css() {
        return this.result.css;
      }
      get map() {
        return this.result.map;
      }
      get messages() {
        return [];
      }
      get opts() {
        return this.result.opts;
      }
      get processor() {
        return this.result.processor;
      }
      get root() {
        if (this._root) return this._root;
        let o, a = e;
        try {
          o = a(this._css, this._opts);
        } catch (u) {
          this.error = u;
        }
        if (this.error) throw this.error;
        return this._root = o, o;
      }
      get [Symbol.toStringTag]() {
        return "NoWorkResult";
      }
      constructor(o, a, u) {
        a = a.toString(), this.stringified = false, this._processor = o, this._css = a, this._opts = u, this._map = void 0;
        let l, c = r;
        this.result = new t(this._processor, l, this._opts), this.result.css = a;
        let h = this;
        Object.defineProperty(this.result, "root", {
          get() {
            return h.root;
          }
        });
        let d = new n(c, l, this._opts, a);
        if (d.isMap()) {
          let [f, p] = d.generate();
          f && (this.result.css = f), p && (this.result.map = p);
        } else d.clearAnnotation(), this.result.css = d.css;
      }
      async() {
        return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
      }
      catch(o) {
        return this.async().catch(o);
      }
      finally(o) {
        return this.async().then(o, o);
      }
      sync() {
        if (this.error) throw this.error;
        return this.result;
      }
      then(o, a) {
        return this.async().then(o, a);
      }
      toString() {
        return this._css;
      }
      warnings() {
        return [];
      }
    }
    return ou = i, i.default = i, ou;
  }
  var au, Bf;
  function Qk() {
    if (Bf) return au;
    Bf = 1;
    let n = Wl(), e = Q0(), t = Xk(), r = ss();
    class i {
      constructor(o = []) {
        this.version = "8.5.3", this.plugins = this.normalize(o);
      }
      normalize(o) {
        let a = [];
        for (let u of o) if (u.postcss === true ? u = u() : u.postcss && (u = u.postcss), typeof u == "object" && Array.isArray(u.plugins)) a = a.concat(u.plugins);
        else if (typeof u == "object" && u.postcssPlugin) a.push(u);
        else if (typeof u == "function") a.push(u);
        else if (!(typeof u == "object" && (u.parse || u.stringify))) throw new Error(u + " is not a PostCSS plugin");
        return a;
      }
      process(o, a = {}) {
        return !this.plugins.length && !a.parser && !a.stringifier && !a.syntax ? new t(this, o, a) : new e(this, o, a);
      }
      use(o) {
        return this.plugins = this.plugins.concat(this.normalize([
          o
        ])), this;
      }
    }
    return au = i, i.default = i, r.registerProcessor(i), n.registerProcessor(i), au;
  }
  var uu, Ff;
  function Zk() {
    if (Ff) return uu;
    Ff = 1;
    var n = {};
    let e = Hl(), t = Qo(), r = Wr(), i = $l(), s = Zo(), o = Wl(), a = Kk(), u = ea(), l = Q0(), c = J0(), h = Xo(), d = Gl(), f = Qk(), p = Kl(), m = ss(), b = Ul(), g = Yo(), w = X0();
    function v(...y) {
      return y.length === 1 && Array.isArray(y[0]) && (y = y[0]), new f(y);
    }
    return v.plugin = function(x, k) {
      let T = false;
      function M(...I) {
        console && console.warn && !T && (T = true, console.warn(x + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`), n.LANG && n.LANG.startsWith("cn") && console.warn(x + `: \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:
https://www.w3ctech.com/topic/2226`));
        let C = k(...I);
        return C.postcssPlugin = x, C.postcssVersion = new f().version, C;
      }
      let D;
      return Object.defineProperty(M, "postcss", {
        get() {
          return D || (D = M()), D;
        }
      }), M.process = function(I, C, O) {
        return v([
          M(O)
        ]).process(I, C);
      }, M;
    }, v.stringify = g, v.parse = d, v.fromJSON = a, v.list = c, v.comment = (y) => new t(y), v.atRule = (y) => new e(y), v.decl = (y) => new s(y), v.rule = (y) => new b(y), v.root = (y) => new m(y), v.document = (y) => new o(y), v.CssSyntaxError = i, v.Declaration = s, v.Container = r, v.Processor = f, v.Document = o, v.Comment = t, v.Warning = w, v.AtRule = e, v.Result = p, v.Input = u, v.Rule = b, v.Root = m, v.Node = h, l.registerPostcss(v), uu = v, v.default = v, uu;
  }
  var lu, zf;
  function eS() {
    if (zf) return lu;
    zf = 1;
    const n = jk(), e = qk(), { isPlainObject: t } = $k(), r = Vk(), i = Wk(), { parse: s } = Zk(), o = [
      "img",
      "audio",
      "video",
      "picture",
      "svg",
      "object",
      "map",
      "iframe",
      "embed"
    ], a = [
      "script",
      "style"
    ];
    function u(b, g) {
      b && Object.keys(b).forEach(function(w) {
        g(b[w], w);
      });
    }
    function l(b, g) {
      return {}.hasOwnProperty.call(b, g);
    }
    function c(b, g) {
      const w = [];
      return u(b, function(v) {
        g(v) && w.push(v);
      }), w;
    }
    function h(b) {
      for (const g in b) if (l(b, g)) return false;
      return true;
    }
    function d(b) {
      return b.map(function(g) {
        if (!g.url) throw new Error("URL missing");
        return g.url + (g.w ? ` ${g.w}w` : "") + (g.h ? ` ${g.h}h` : "") + (g.d ? ` ${g.d}x` : "");
      }).join(", ");
    }
    lu = p;
    const f = /^[^\0\t\n\f\r /<=>]+$/;
    function p(b, g, w) {
      if (b == null) return "";
      typeof b == "number" && (b = b.toString());
      let v = "", y = "";
      function x(P, q) {
        const j = this;
        this.tag = P, this.attribs = q || {}, this.tagPosition = v.length, this.text = "", this.mediaChildren = [], this.updateParentNodeText = function() {
          if (R.length) {
            const U = R[R.length - 1];
            U.text += j.text;
          }
        }, this.updateParentNodeMediaChildren = function() {
          R.length && o.includes(this.tag) && R[R.length - 1].mediaChildren.push(this.tag);
        };
      }
      g = Object.assign({}, p.defaults, g), g.parser = Object.assign({}, m, g.parser);
      const k = function(P) {
        return g.allowedTags === false || (g.allowedTags || []).indexOf(P) > -1;
      };
      a.forEach(function(P) {
        k(P) && !g.allowVulnerableTags && console.warn(`

\u26A0\uFE0F Your \`allowedTags\` option includes, \`${P}\`, which is inherently
vulnerable to XSS attacks. Please remove it from \`allowedTags\`.
Or, to disable this warning, add the \`allowVulnerableTags\` option
and ensure you are accounting for this risk.

`);
      });
      const T = g.nonTextTags || [
        "script",
        "style",
        "textarea",
        "option"
      ];
      let M, D;
      g.allowedAttributes && (M = {}, D = {}, u(g.allowedAttributes, function(P, q) {
        M[q] = [];
        const j = [];
        P.forEach(function(U) {
          typeof U == "string" && U.indexOf("*") >= 0 ? j.push(e(U).replace(/\\\*/g, ".*")) : M[q].push(U);
        }), j.length && (D[q] = new RegExp("^(" + j.join("|") + ")$"));
      }));
      const I = {}, C = {}, O = {};
      u(g.allowedClasses, function(P, q) {
        if (M && (l(M, q) || (M[q] = []), M[q].push("class")), I[q] = P, Array.isArray(P)) {
          const j = [];
          I[q] = [], O[q] = [], P.forEach(function(U) {
            typeof U == "string" && U.indexOf("*") >= 0 ? j.push(e(U).replace(/\\\*/g, ".*")) : U instanceof RegExp ? O[q].push(U) : I[q].push(U);
          }), j.length && (C[q] = new RegExp("^(" + j.join("|") + ")$"));
        }
      });
      const E = {};
      let N;
      u(g.transformTags, function(P, q) {
        let j;
        typeof P == "function" ? j = P : typeof P == "string" && (j = p.simpleTransform(P)), q === "*" ? N = j : E[q] = j;
      });
      let A, R, B, z, L, V, K = false;
      H();
      const pe = new n.Parser({
        onopentag: function(P, q) {
          if (g.enforceHtmlBoundary && P === "html" && H(), L) {
            V++;
            return;
          }
          const j = new x(P, q);
          R.push(j);
          let U = false;
          const ke = !!j.text;
          let Ee;
          if (l(E, P) && (Ee = E[P](P, q), j.attribs = q = Ee.attribs, Ee.text !== void 0 && (j.innerText = Ee.text), P !== Ee.tagName && (j.name = P = Ee.tagName, z[A] = Ee.tagName)), N && (Ee = N(P, q), j.attribs = q = Ee.attribs, P !== Ee.tagName && (j.name = P = Ee.tagName, z[A] = Ee.tagName)), (!k(P) || g.disallowedTagsMode === "recursiveEscape" && !h(B) || g.nestingLimit != null && A >= g.nestingLimit) && (U = true, B[A] = true, (g.disallowedTagsMode === "discard" || g.disallowedTagsMode === "completelyDiscard") && T.indexOf(P) !== -1 && (L = true, V = 1), B[A] = true), A++, U) {
            if (g.disallowedTagsMode === "discard" || g.disallowedTagsMode === "completelyDiscard") {
              if (j.innerText && !ke) {
                const xe = ue(j.innerText);
                g.textFilter ? v += g.textFilter(xe, P) : v += ue(j.innerText), K = true;
              }
              return;
            }
            y = v, v = "";
          }
          v += "<" + P, P === "script" && (g.allowedScriptHostnames || g.allowedScriptDomains) && (j.innerText = ""), (!M || l(M, P) || M["*"]) && u(q, function(xe, ve) {
            if (!f.test(ve)) {
              delete j.attribs[ve];
              return;
            }
            if (xe === "" && !g.allowedEmptyAttributes.includes(ve) && (g.nonBooleanAttributes.includes(ve) || g.nonBooleanAttributes.includes("*"))) {
              delete j.attribs[ve];
              return;
            }
            let Ue = false;
            if (!M || l(M, P) && M[P].indexOf(ve) !== -1 || M["*"] && M["*"].indexOf(ve) !== -1 || l(D, P) && D[P].test(ve) || D["*"] && D["*"].test(ve)) Ue = true;
            else if (M && M[P]) {
              for (const ge of M[P]) if (t(ge) && ge.name && ge.name === ve) {
                Ue = true;
                let me = "";
                if (ge.multiple === true) {
                  const Xe = xe.split(" ");
                  for (const He of Xe) ge.values.indexOf(He) !== -1 && (me === "" ? me = He : me += " " + He);
                } else ge.values.indexOf(xe) >= 0 && (me = xe);
                xe = me;
              }
            }
            if (Ue) {
              if (g.allowedSchemesAppliedToAttributes.indexOf(ve) !== -1 && ne(P, xe)) {
                delete j.attribs[ve];
                return;
              }
              if (P === "script" && ve === "src") {
                let ge = true;
                try {
                  const me = ce(xe);
                  if (g.allowedScriptHostnames || g.allowedScriptDomains) {
                    const Xe = (g.allowedScriptHostnames || []).find(function($e) {
                      return $e === me.url.hostname;
                    }), He = (g.allowedScriptDomains || []).find(function($e) {
                      return me.url.hostname === $e || me.url.hostname.endsWith(`.${$e}`);
                    });
                    ge = Xe || He;
                  }
                } catch {
                  ge = false;
                }
                if (!ge) {
                  delete j.attribs[ve];
                  return;
                }
              }
              if (P === "iframe" && ve === "src") {
                let ge = true;
                try {
                  const me = ce(xe);
                  if (me.isRelativeUrl) ge = l(g, "allowIframeRelativeUrls") ? g.allowIframeRelativeUrls : !g.allowedIframeHostnames && !g.allowedIframeDomains;
                  else if (g.allowedIframeHostnames || g.allowedIframeDomains) {
                    const Xe = (g.allowedIframeHostnames || []).find(function($e) {
                      return $e === me.url.hostname;
                    }), He = (g.allowedIframeDomains || []).find(function($e) {
                      return me.url.hostname === $e || me.url.hostname.endsWith(`.${$e}`);
                    });
                    ge = Xe || He;
                  }
                } catch {
                  ge = false;
                }
                if (!ge) {
                  delete j.attribs[ve];
                  return;
                }
              }
              if (ve === "srcset") try {
                let ge = i(xe);
                if (ge.forEach(function(me) {
                  ne("srcset", me.url) && (me.evil = true);
                }), ge = c(ge, function(me) {
                  return !me.evil;
                }), ge.length) xe = d(c(ge, function(me) {
                  return !me.evil;
                })), j.attribs[ve] = xe;
                else {
                  delete j.attribs[ve];
                  return;
                }
              } catch {
                delete j.attribs[ve];
                return;
              }
              if (ve === "class") {
                const ge = I[P], me = I["*"], Xe = C[P], He = O[P], $e = O["*"], Y = C["*"], ee = [
                  Xe,
                  Y
                ].concat(He, $e).filter(function(ie) {
                  return ie;
                });
                if (ge && me ? xe = W(xe, r(ge, me), ee) : xe = W(xe, ge || me, ee), !xe.length) {
                  delete j.attribs[ve];
                  return;
                }
              }
              if (ve === "style") {
                if (g.parseStyleAttributes) try {
                  const ge = s(P + " {" + xe + "}", {
                    map: false
                  }), me = Z(ge, g.allowedStyles);
                  if (xe = de(me), xe.length === 0) {
                    delete j.attribs[ve];
                    return;
                  }
                } catch {
                  typeof window < "u" && console.warn('Failed to parse "' + P + " {" + xe + `}", If you're running this in a browser, we recommend to disable style parsing: options.parseStyleAttributes: false, since this only works in a node environment due to a postcss dependency, More info: https://github.com/apostrophecms/sanitize-html/issues/547`), delete j.attribs[ve];
                  return;
                }
                else if (g.allowedStyles) throw new Error("allowedStyles option cannot be used together with parseStyleAttributes: false.");
              }
              v += " " + ve, xe && xe.length ? v += '="' + ue(xe, true) + '"' : g.allowedEmptyAttributes.includes(ve) && (v += '=""');
            } else delete j.attribs[ve];
          }), g.selfClosing.indexOf(P) !== -1 ? v += " />" : (v += ">", j.innerText && !ke && !g.textFilter && (v += ue(j.innerText), K = true)), U && (v = y + ue(v), y = "");
        },
        ontext: function(P) {
          if (L) return;
          const q = R[R.length - 1];
          let j;
          if (q && (j = q.tag, P = q.innerText !== void 0 ? q.innerText : P), g.disallowedTagsMode === "completelyDiscard" && !k(j)) P = "";
          else if ((g.disallowedTagsMode === "discard" || g.disallowedTagsMode === "completelyDiscard") && (j === "script" || j === "style")) v += P;
          else {
            const U = ue(P, false);
            g.textFilter && !K ? v += g.textFilter(U, j) : K || (v += U);
          }
          if (R.length) {
            const U = R[R.length - 1];
            U.text += P;
          }
        },
        onclosetag: function(P, q) {
          if (L) if (V--, !V) L = false;
          else return;
          const j = R.pop();
          if (!j) return;
          if (j.tag !== P) {
            R.push(j);
            return;
          }
          L = g.enforceHtmlBoundary ? P === "html" : false, A--;
          const U = B[A];
          if (U) {
            if (delete B[A], g.disallowedTagsMode === "discard" || g.disallowedTagsMode === "completelyDiscard") {
              j.updateParentNodeText();
              return;
            }
            y = v, v = "";
          }
          if (z[A] && (P = z[A], delete z[A]), g.exclusiveFilter && g.exclusiveFilter(j)) {
            v = v.substr(0, j.tagPosition);
            return;
          }
          if (j.updateParentNodeMediaChildren(), j.updateParentNodeText(), g.selfClosing.indexOf(P) !== -1 || q && !k(P) && [
            "escape",
            "recursiveEscape"
          ].indexOf(g.disallowedTagsMode) >= 0) {
            U && (v = y, y = "");
            return;
          }
          v += "</" + P + ">", U && (v = y + ue(v), y = ""), K = false;
        }
      }, g.parser);
      return pe.write(b), pe.end(), v;
      function H() {
        v = "", A = 0, R = [], B = {}, z = {}, L = false, V = 0;
      }
      function ue(P, q) {
        return typeof P != "string" && (P = P + ""), g.parser.decodeEntities && (P = P.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), q && (P = P.replace(/"/g, "&quot;"))), P = P.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), q && (P = P.replace(/"/g, "&quot;")), P;
      }
      function ne(P, q) {
        for (q = q.replace(/[\x00-\x20]+/g, ""); ; ) {
          const ke = q.indexOf("<!--");
          if (ke === -1) break;
          const Ee = q.indexOf("-->", ke + 4);
          if (Ee === -1) break;
          q = q.substring(0, ke) + q.substring(Ee + 3);
        }
        const j = q.match(/^([a-zA-Z][a-zA-Z0-9.\-+]*):/);
        if (!j) return q.match(/^[/\\]{2}/) ? !g.allowProtocolRelative : false;
        const U = j[1].toLowerCase();
        return l(g.allowedSchemesByTag, P) ? g.allowedSchemesByTag[P].indexOf(U) === -1 : !g.allowedSchemes || g.allowedSchemes.indexOf(U) === -1;
      }
      function ce(P) {
        if (P = P.replace(/^(\w+:)?\s*[\\/]\s*[\\/]/, "$1//"), P.startsWith("relative:")) throw new Error("relative: exploit attempt");
        let q = "relative://relative-site";
        for (let ke = 0; ke < 100; ke++) q += `/${ke}`;
        const j = new URL(P, q);
        return {
          isRelativeUrl: j && j.hostname === "relative-site" && j.protocol === "relative:",
          url: j
        };
      }
      function Z(P, q) {
        if (!q) return P;
        const j = P.nodes[0];
        let U;
        return q[j.selector] && q["*"] ? U = r(q[j.selector], q["*"]) : U = q[j.selector] || q["*"], U && (P.nodes[0].nodes = j.nodes.reduce(_(U), [])), P;
      }
      function de(P) {
        return P.nodes[0].nodes.reduce(function(q, j) {
          return q.push(`${j.prop}:${j.value}${j.important ? " !important" : ""}`), q;
        }, []).join(";");
      }
      function _(P) {
        return function(q, j) {
          return l(P, j.prop) && P[j.prop].some(function(ke) {
            return ke.test(j.value);
          }) && q.push(j), q;
        };
      }
      function W(P, q, j) {
        return q ? (P = P.split(/\s+/), P.filter(function(U) {
          return q.indexOf(U) !== -1 || j.some(function(ke) {
            return ke.test(U);
          });
        }).join(" ")) : P;
      }
    }
    const m = {
      decodeEntities: true
    };
    return p.defaults = {
      allowedTags: [
        "address",
        "article",
        "aside",
        "footer",
        "header",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "hgroup",
        "main",
        "nav",
        "section",
        "blockquote",
        "dd",
        "div",
        "dl",
        "dt",
        "figcaption",
        "figure",
        "hr",
        "li",
        "main",
        "ol",
        "p",
        "pre",
        "ul",
        "a",
        "abbr",
        "b",
        "bdi",
        "bdo",
        "br",
        "cite",
        "code",
        "data",
        "dfn",
        "em",
        "i",
        "kbd",
        "mark",
        "q",
        "rb",
        "rp",
        "rt",
        "rtc",
        "ruby",
        "s",
        "samp",
        "small",
        "span",
        "strong",
        "sub",
        "sup",
        "time",
        "u",
        "var",
        "wbr",
        "caption",
        "col",
        "colgroup",
        "table",
        "tbody",
        "td",
        "tfoot",
        "th",
        "thead",
        "tr"
      ],
      nonBooleanAttributes: [
        "abbr",
        "accept",
        "accept-charset",
        "accesskey",
        "action",
        "allow",
        "alt",
        "as",
        "autocapitalize",
        "autocomplete",
        "blocking",
        "charset",
        "cite",
        "class",
        "color",
        "cols",
        "colspan",
        "content",
        "contenteditable",
        "coords",
        "crossorigin",
        "data",
        "datetime",
        "decoding",
        "dir",
        "dirname",
        "download",
        "draggable",
        "enctype",
        "enterkeyhint",
        "fetchpriority",
        "for",
        "form",
        "formaction",
        "formenctype",
        "formmethod",
        "formtarget",
        "headers",
        "height",
        "hidden",
        "high",
        "href",
        "hreflang",
        "http-equiv",
        "id",
        "imagesizes",
        "imagesrcset",
        "inputmode",
        "integrity",
        "is",
        "itemid",
        "itemprop",
        "itemref",
        "itemtype",
        "kind",
        "label",
        "lang",
        "list",
        "loading",
        "low",
        "max",
        "maxlength",
        "media",
        "method",
        "min",
        "minlength",
        "name",
        "nonce",
        "optimum",
        "pattern",
        "ping",
        "placeholder",
        "popover",
        "popovertarget",
        "popovertargetaction",
        "poster",
        "preload",
        "referrerpolicy",
        "rel",
        "rows",
        "rowspan",
        "sandbox",
        "scope",
        "shape",
        "size",
        "sizes",
        "slot",
        "span",
        "spellcheck",
        "src",
        "srcdoc",
        "srclang",
        "srcset",
        "start",
        "step",
        "style",
        "tabindex",
        "target",
        "title",
        "translate",
        "type",
        "usemap",
        "value",
        "width",
        "wrap",
        "onauxclick",
        "onafterprint",
        "onbeforematch",
        "onbeforeprint",
        "onbeforeunload",
        "onbeforetoggle",
        "onblur",
        "oncancel",
        "oncanplay",
        "oncanplaythrough",
        "onchange",
        "onclick",
        "onclose",
        "oncontextlost",
        "oncontextmenu",
        "oncontextrestored",
        "oncopy",
        "oncuechange",
        "oncut",
        "ondblclick",
        "ondrag",
        "ondragend",
        "ondragenter",
        "ondragleave",
        "ondragover",
        "ondragstart",
        "ondrop",
        "ondurationchange",
        "onemptied",
        "onended",
        "onerror",
        "onfocus",
        "onformdata",
        "onhashchange",
        "oninput",
        "oninvalid",
        "onkeydown",
        "onkeypress",
        "onkeyup",
        "onlanguagechange",
        "onload",
        "onloadeddata",
        "onloadedmetadata",
        "onloadstart",
        "onmessage",
        "onmessageerror",
        "onmousedown",
        "onmouseenter",
        "onmouseleave",
        "onmousemove",
        "onmouseout",
        "onmouseover",
        "onmouseup",
        "onoffline",
        "ononline",
        "onpagehide",
        "onpageshow",
        "onpaste",
        "onpause",
        "onplay",
        "onplaying",
        "onpopstate",
        "onprogress",
        "onratechange",
        "onreset",
        "onresize",
        "onrejectionhandled",
        "onscroll",
        "onscrollend",
        "onsecuritypolicyviolation",
        "onseeked",
        "onseeking",
        "onselect",
        "onslotchange",
        "onstalled",
        "onstorage",
        "onsubmit",
        "onsuspend",
        "ontimeupdate",
        "ontoggle",
        "onunhandledrejection",
        "onunload",
        "onvolumechange",
        "onwaiting",
        "onwheel"
      ],
      disallowedTagsMode: "discard",
      allowedAttributes: {
        a: [
          "href",
          "name",
          "target"
        ],
        img: [
          "src",
          "srcset",
          "alt",
          "title",
          "width",
          "height",
          "loading"
        ]
      },
      allowedEmptyAttributes: [
        "alt"
      ],
      selfClosing: [
        "img",
        "br",
        "hr",
        "area",
        "base",
        "basefont",
        "input",
        "link",
        "meta"
      ],
      allowedSchemes: [
        "http",
        "https",
        "ftp",
        "mailto",
        "tel"
      ],
      allowedSchemesByTag: {},
      allowedSchemesAppliedToAttributes: [
        "href",
        "src",
        "cite"
      ],
      allowProtocolRelative: true,
      enforceHtmlBoundary: false,
      parseStyleAttributes: true
    }, p.simpleTransform = function(b, g, w) {
      return w = w === void 0 ? true : w, g = g || {}, function(v, y) {
        let x;
        if (w) for (x in g) y[x] = g[x];
        else y = g;
        return {
          tagName: b,
          attribs: y
        };
      };
    }, lu;
  }
  var tS = eS();
  const nS = gg(tS);
  function rS(n) {
    return nS(Ye.parse(n).replace("<a ", '<a target="_blank" '));
  }
  var iS = ae('<h5 class="uppercase text-gray-300"> </h5> <!>', 1), sS = ae('<menu class="bg-violet-900 p-4 flex flex-col gap-3"></menu>');
  function oS(n, e) {
    Re(e, true);
    let t = Me(0), r = $(e, "items", 7), i = X(() => {
      const u = /* @__PURE__ */ new Set();
      return r().map((l) => u.add(l.category)), u.values().toArray();
    });
    function s(u) {
      r(u);
    }
    function o(u) {
      if (u.repeat) return false;
      switch (u.key) {
        case "ArrowUp":
          return S(t) <= 0 ? te(t, r().length - 1) : sc(t, -1), true;
        case "ArrowDown":
          return S(t) >= r().length - 1 ? te(t, 0) : sc(t), true;
        case "Enter": {
          const l = r()[S(t)];
          return e.callback({
            id: l.value,
            label: l.label
          }), true;
        }
      }
      return false;
    }
    var a = sS();
    return ji(a, 21, () => S(i), Cu, (u, l, c) => {
      var h = iS();
      const d = X(() => c === 0 ? 0 : r().filter((b) => b.category === S(i)[c - 1]).length);
      var f = J(h), p = Se(f, true);
      we(f);
      var m = je(f, 2);
      ji(m, 19, () => r().filter((b) => b.category === S(l)), ({ value: b, label: g, disabled: w }, v) => v + b, (b, g, w) => {
        let v = () => S(g).value, y = () => S(g).label, x = () => S(g).disabled;
        var k = se();
        const T = X(() => S(w) + S(d));
        var M = J(k);
        const D = X(() => [
          S(T) === S(t) && "!border-white",
          "border border-violet-800 px-3 py-2 flex gap-4 bg-violet-800 text-white rounded cursor-pointer"
        ]);
        Le(M, () => yn, (I, C) => {
          C(I, {
            get disabled() {
              return x();
            },
            get class() {
              return S(D);
            },
            onmouseover: () => te(t, S(T)),
            onclick: () => e.callback({
              id: v(),
              label: y()
            }),
            children: (O, E) => {
              kn();
              var N = Qn();
              qe(() => ir(N, y())), F(O, N);
            },
            $$slots: {
              default: true
            }
          });
        }), F(b, k);
      }), qe(() => ir(p, S(l))), F(u, h);
    }), we(a), F(n, a), _e({
      setItems: s,
      onKeyDown: o
    });
  }
  const aS = ({ onEnter: n }) => At.create({
    name: "keyboardShortcutHandler",
    addProseMirrorPlugins() {
      return [
        wp({
          Enter: () => (n(), this.editor.commands.clearContent(), true)
        })
      ];
    }
  });
  function Z0({ items: n, char: e, pluginKey: t }) {
    return {
      char: e,
      pluginKey: new Vt(t),
      items: ({ query: r }) => n.filter((i) => i.label.toLowerCase().startsWith(r.toLowerCase())).slice(0, 5),
      render: () => {
        let r, i;
        return {
          onStart: (s) => {
            r = document.createElement("div"), s.editor.view.dom.parentNode?.appendChild(r), i = hg(oS, {
              target: r,
              props: {
                items: s.items,
                callback: ({ id: o, label: a }) => s.command({
                  id: o,
                  label: a
                })
              }
            });
          },
          onUpdate: (s) => {
            i.setItems(s.items);
          },
          onKeyDown: (s) => i.onKeyDown(s.event),
          onExit: () => {
            fg(i);
          }
        };
      }
    };
  }
  const em = P0.extend({
    name: "userMention",
    renderHTML({ HTMLAttributes: n, node: e }) {
      return [
        "a",
        ot({
          href: `https://${e.attrs.label}`,
          class: "mention !no-underline"
        }, n),
        `@${e.attrs.label}`
      ];
    }
  }), uS = ({ users: n }) => em.configure({
    HTMLAttributes: {
      class: "mention"
    },
    suggestion: Z0({
      items: n,
      char: "@",
      pluginKey: "userMention"
    })
  }), tm = P0.extend({
    name: "channelThreadMention",
    renderHTML({ HTMLAttributes: n, node: e }) {
      const { ulid: t, space: r, type: i } = JSON.parse(e.attrs.id);
      return [
        "a",
        ot({
          href: i === "thread" ? `/space/${r}/thread/${t}` : `/space/${r}/${t}`,
          class: `mention ${i === "thread" ? "thread-mention" : "channel-mention"} !no-underline`
        }, n),
        e.attrs.label
      ];
    }
  }), lS = ({ context: n }) => tm.configure({
    HTMLAttributes: {
      class: "mention"
    },
    suggestion: Z0({
      items: n,
      char: "#",
      pluginKey: "spaceContextMention"
    }),
    renderHTML({ options: e, node: t }) {
      const { type: r } = JSON.parse(t.attrs.id);
      return [
        "span",
        ot({
          class: `mention ${r === "thread" ? "thread-mention" : "channel-mention"} !no-underline`
        }, e.HTMLAttributes),
        t.attrs.label
      ];
    }
  }), nm = [
    N0.configure({
      heading: false
    }),
    em,
    tm
  ];
  T0(nm);
  cu = function(n) {
    try {
      const e = JSON.parse(n);
      return u2(e, nm);
    } catch {
      return rS(n);
    }
  };
  const rm = 6048e5, cS = 864e5, jf = Symbol.for("constructDateFrom");
  function On(n, e) {
    return typeof n == "function" ? n(e) : n && typeof n == "object" && jf in n ? n[jf](e) : n instanceof Date ? new n.constructor(e) : new Date(e);
  }
  function pn(n, e) {
    return On(e || n, n);
  }
  let dS = {};
  function ta() {
    return dS;
  }
  function Yi(n, e) {
    const t = ta(), r = e?.weekStartsOn ?? e?.locale?.options?.weekStartsOn ?? t.weekStartsOn ?? t.locale?.options?.weekStartsOn ?? 0, i = pn(n, e?.in), s = i.getDay(), o = (s < r ? 7 : 0) + s - r;
    return i.setDate(i.getDate() - o), i.setHours(0, 0, 0, 0), i;
  }
  function go(n, e) {
    return Yi(n, {
      ...e,
      weekStartsOn: 1
    });
  }
  function im(n, e) {
    const t = pn(n, e?.in), r = t.getFullYear(), i = On(t, 0);
    i.setFullYear(r + 1, 0, 4), i.setHours(0, 0, 0, 0);
    const s = go(i), o = On(t, 0);
    o.setFullYear(r, 0, 4), o.setHours(0, 0, 0, 0);
    const a = go(o);
    return t.getTime() >= s.getTime() ? r + 1 : t.getTime() >= a.getTime() ? r : r - 1;
  }
  function qf(n) {
    const e = pn(n), t = new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()));
    return t.setUTCFullYear(e.getFullYear()), +n - +t;
  }
  function sm(n, ...e) {
    const t = On.bind(null, e.find((r) => typeof r == "object"));
    return e.map(t);
  }
  function bo(n, e) {
    const t = pn(n, e?.in);
    return t.setHours(0, 0, 0, 0), t;
  }
  function fS(n, e, t) {
    const [r, i] = sm(t?.in, n, e), s = bo(r), o = bo(i), a = +s - qf(s), u = +o - qf(o);
    return Math.round((a - u) / cS);
  }
  function hS(n, e) {
    const t = im(n, e), r = On(n, 0);
    return r.setFullYear(t, 0, 4), r.setHours(0, 0, 0, 0), go(r);
  }
  function pS(n) {
    return On(n, Date.now());
  }
  function mS(n, e, t) {
    const [r, i] = sm(t?.in, n, e);
    return +bo(r) == +bo(i);
  }
  function gS(n) {
    return n instanceof Date || typeof n == "object" && Object.prototype.toString.call(n) === "[object Date]";
  }
  function bS(n) {
    return !(!gS(n) && typeof n != "number" || isNaN(+pn(n)));
  }
  function yS(n, e) {
    const t = pn(n, e?.in);
    return t.setFullYear(t.getFullYear(), 0, 1), t.setHours(0, 0, 0, 0), t;
  }
  const vS = {
    lessThanXSeconds: {
      one: "less than a second",
      other: "less than {{count}} seconds"
    },
    xSeconds: {
      one: "1 second",
      other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
      one: "less than a minute",
      other: "less than {{count}} minutes"
    },
    xMinutes: {
      one: "1 minute",
      other: "{{count}} minutes"
    },
    aboutXHours: {
      one: "about 1 hour",
      other: "about {{count}} hours"
    },
    xHours: {
      one: "1 hour",
      other: "{{count}} hours"
    },
    xDays: {
      one: "1 day",
      other: "{{count}} days"
    },
    aboutXWeeks: {
      one: "about 1 week",
      other: "about {{count}} weeks"
    },
    xWeeks: {
      one: "1 week",
      other: "{{count}} weeks"
    },
    aboutXMonths: {
      one: "about 1 month",
      other: "about {{count}} months"
    },
    xMonths: {
      one: "1 month",
      other: "{{count}} months"
    },
    aboutXYears: {
      one: "about 1 year",
      other: "about {{count}} years"
    },
    xYears: {
      one: "1 year",
      other: "{{count}} years"
    },
    overXYears: {
      one: "over 1 year",
      other: "over {{count}} years"
    },
    almostXYears: {
      one: "almost 1 year",
      other: "almost {{count}} years"
    }
  }, wS = (n, e, t) => {
    let r;
    const i = vS[n];
    return typeof i == "string" ? r = i : e === 1 ? r = i.one : r = i.other.replace("{{count}}", e.toString()), t?.addSuffix ? t.comparison && t.comparison > 0 ? "in " + r : r + " ago" : r;
  };
  function du(n) {
    return (e = {}) => {
      const t = e.width ? String(e.width) : n.defaultWidth;
      return n.formats[t] || n.formats[n.defaultWidth];
    };
  }
  const xS = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
  }, kS = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
  }, SS = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
  }, TS = {
    date: du({
      formats: xS,
      defaultWidth: "full"
    }),
    time: du({
      formats: kS,
      defaultWidth: "full"
    }),
    dateTime: du({
      formats: SS,
      defaultWidth: "full"
    })
  }, ES = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
  }, CS = (n, e, t, r) => ES[n];
  function Ei(n) {
    return (e, t) => {
      const r = t?.context ? String(t.context) : "standalone";
      let i;
      if (r === "formatting" && n.formattingValues) {
        const o = n.defaultFormattingWidth || n.defaultWidth, a = t?.width ? String(t.width) : o;
        i = n.formattingValues[a] || n.formattingValues[o];
      } else {
        const o = n.defaultWidth, a = t?.width ? String(t.width) : n.defaultWidth;
        i = n.values[a] || n.values[o];
      }
      const s = n.argumentCallback ? n.argumentCallback(e) : e;
      return i[s];
    };
  }
  const OS = {
    narrow: [
      "B",
      "A"
    ],
    abbreviated: [
      "BC",
      "AD"
    ],
    wide: [
      "Before Christ",
      "Anno Domini"
    ]
  }, AS = {
    narrow: [
      "1",
      "2",
      "3",
      "4"
    ],
    abbreviated: [
      "Q1",
      "Q2",
      "Q3",
      "Q4"
    ],
    wide: [
      "1st quarter",
      "2nd quarter",
      "3rd quarter",
      "4th quarter"
    ]
  }, MS = {
    narrow: [
      "J",
      "F",
      "M",
      "A",
      "M",
      "J",
      "J",
      "A",
      "S",
      "O",
      "N",
      "D"
    ],
    abbreviated: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ],
    wide: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ]
  }, NS = {
    narrow: [
      "S",
      "M",
      "T",
      "W",
      "T",
      "F",
      "S"
    ],
    short: [
      "Su",
      "Mo",
      "Tu",
      "We",
      "Th",
      "Fr",
      "Sa"
    ],
    abbreviated: [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat"
    ],
    wide: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ]
  }, PS = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    }
  }, DS = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    }
  }, IS = (n, e) => {
    const t = Number(n), r = t % 100;
    if (r > 20 || r < 10) switch (r % 10) {
      case 1:
        return t + "st";
      case 2:
        return t + "nd";
      case 3:
        return t + "rd";
    }
    return t + "th";
  }, RS = {
    ordinalNumber: IS,
    era: Ei({
      values: OS,
      defaultWidth: "wide"
    }),
    quarter: Ei({
      values: AS,
      defaultWidth: "wide",
      argumentCallback: (n) => n - 1
    }),
    month: Ei({
      values: MS,
      defaultWidth: "wide"
    }),
    day: Ei({
      values: NS,
      defaultWidth: "wide"
    }),
    dayPeriod: Ei({
      values: PS,
      defaultWidth: "wide",
      formattingValues: DS,
      defaultFormattingWidth: "wide"
    })
  };
  function Ci(n) {
    return (e, t = {}) => {
      const r = t.width, i = r && n.matchPatterns[r] || n.matchPatterns[n.defaultMatchWidth], s = e.match(i);
      if (!s) return null;
      const o = s[0], a = r && n.parsePatterns[r] || n.parsePatterns[n.defaultParseWidth], u = Array.isArray(a) ? LS(a, (h) => h.test(o)) : _S(a, (h) => h.test(o));
      let l;
      l = n.valueCallback ? n.valueCallback(u) : u, l = t.valueCallback ? t.valueCallback(l) : l;
      const c = e.slice(o.length);
      return {
        value: l,
        rest: c
      };
    };
  }
  function _S(n, e) {
    for (const t in n) if (Object.prototype.hasOwnProperty.call(n, t) && e(n[t])) return t;
  }
  function LS(n, e) {
    for (let t = 0; t < n.length; t++) if (e(n[t])) return t;
  }
  function BS(n) {
    return (e, t = {}) => {
      const r = e.match(n.matchPattern);
      if (!r) return null;
      const i = r[0], s = e.match(n.parsePattern);
      if (!s) return null;
      let o = n.valueCallback ? n.valueCallback(s[0]) : s[0];
      o = t.valueCallback ? t.valueCallback(o) : o;
      const a = e.slice(i.length);
      return {
        value: o,
        rest: a
      };
    };
  }
  const FS = /^(\d+)(th|st|nd|rd)?/i, zS = /\d+/i, jS = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
  }, qS = {
    any: [
      /^b/i,
      /^(a|c)/i
    ]
  }, $S = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
  }, VS = {
    any: [
      /1/i,
      /2/i,
      /3/i,
      /4/i
    ]
  }, HS = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
  }, WS = {
    narrow: [
      /^j/i,
      /^f/i,
      /^m/i,
      /^a/i,
      /^m/i,
      /^j/i,
      /^j/i,
      /^a/i,
      /^s/i,
      /^o/i,
      /^n/i,
      /^d/i
    ],
    any: [
      /^ja/i,
      /^f/i,
      /^mar/i,
      /^ap/i,
      /^may/i,
      /^jun/i,
      /^jul/i,
      /^au/i,
      /^s/i,
      /^o/i,
      /^n/i,
      /^d/i
    ]
  }, US = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
  }, GS = {
    narrow: [
      /^s/i,
      /^m/i,
      /^t/i,
      /^w/i,
      /^t/i,
      /^f/i,
      /^s/i
    ],
    any: [
      /^su/i,
      /^m/i,
      /^tu/i,
      /^w/i,
      /^th/i,
      /^f/i,
      /^sa/i
    ]
  }, KS = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
  }, JS = {
    any: {
      am: /^a/i,
      pm: /^p/i,
      midnight: /^mi/i,
      noon: /^no/i,
      morning: /morning/i,
      afternoon: /afternoon/i,
      evening: /evening/i,
      night: /night/i
    }
  }, YS = {
    ordinalNumber: BS({
      matchPattern: FS,
      parsePattern: zS,
      valueCallback: (n) => parseInt(n, 10)
    }),
    era: Ci({
      matchPatterns: jS,
      defaultMatchWidth: "wide",
      parsePatterns: qS,
      defaultParseWidth: "any"
    }),
    quarter: Ci({
      matchPatterns: $S,
      defaultMatchWidth: "wide",
      parsePatterns: VS,
      defaultParseWidth: "any",
      valueCallback: (n) => n + 1
    }),
    month: Ci({
      matchPatterns: HS,
      defaultMatchWidth: "wide",
      parsePatterns: WS,
      defaultParseWidth: "any"
    }),
    day: Ci({
      matchPatterns: US,
      defaultMatchWidth: "wide",
      parsePatterns: GS,
      defaultParseWidth: "any"
    }),
    dayPeriod: Ci({
      matchPatterns: KS,
      defaultMatchWidth: "any",
      parsePatterns: JS,
      defaultParseWidth: "any"
    })
  }, XS = {
    code: "en-US",
    formatDistance: wS,
    formatLong: TS,
    formatRelative: CS,
    localize: RS,
    match: YS,
    options: {
      weekStartsOn: 0,
      firstWeekContainsDate: 1
    }
  };
  function QS(n, e) {
    const t = pn(n, e?.in);
    return fS(t, yS(t)) + 1;
  }
  function ZS(n, e) {
    const t = pn(n, e?.in), r = +go(t) - +hS(t);
    return Math.round(r / rm) + 1;
  }
  function om(n, e) {
    const t = pn(n, e?.in), r = t.getFullYear(), i = ta(), s = e?.firstWeekContainsDate ?? e?.locale?.options?.firstWeekContainsDate ?? i.firstWeekContainsDate ?? i.locale?.options?.firstWeekContainsDate ?? 1, o = On(e?.in || n, 0);
    o.setFullYear(r + 1, 0, s), o.setHours(0, 0, 0, 0);
    const a = Yi(o, e), u = On(e?.in || n, 0);
    u.setFullYear(r, 0, s), u.setHours(0, 0, 0, 0);
    const l = Yi(u, e);
    return +t >= +a ? r + 1 : +t >= +l ? r : r - 1;
  }
  function e3(n, e) {
    const t = ta(), r = e?.firstWeekContainsDate ?? e?.locale?.options?.firstWeekContainsDate ?? t.firstWeekContainsDate ?? t.locale?.options?.firstWeekContainsDate ?? 1, i = om(n, e), s = On(e?.in || n, 0);
    return s.setFullYear(i, 0, r), s.setHours(0, 0, 0, 0), Yi(s, e);
  }
  function t3(n, e) {
    const t = pn(n, e?.in), r = +Yi(t, e) - +e3(t, e);
    return Math.round(r / rm) + 1;
  }
  function Je(n, e) {
    const t = n < 0 ? "-" : "", r = Math.abs(n).toString().padStart(e, "0");
    return t + r;
  }
  const Un = {
    y(n, e) {
      const t = n.getFullYear(), r = t > 0 ? t : 1 - t;
      return Je(e === "yy" ? r % 100 : r, e.length);
    },
    M(n, e) {
      const t = n.getMonth();
      return e === "M" ? String(t + 1) : Je(t + 1, 2);
    },
    d(n, e) {
      return Je(n.getDate(), e.length);
    },
    a(n, e) {
      const t = n.getHours() / 12 >= 1 ? "pm" : "am";
      switch (e) {
        case "a":
        case "aa":
          return t.toUpperCase();
        case "aaa":
          return t;
        case "aaaaa":
          return t[0];
        case "aaaa":
        default:
          return t === "am" ? "a.m." : "p.m.";
      }
    },
    h(n, e) {
      return Je(n.getHours() % 12 || 12, e.length);
    },
    H(n, e) {
      return Je(n.getHours(), e.length);
    },
    m(n, e) {
      return Je(n.getMinutes(), e.length);
    },
    s(n, e) {
      return Je(n.getSeconds(), e.length);
    },
    S(n, e) {
      const t = e.length, r = n.getMilliseconds(), i = Math.trunc(r * Math.pow(10, t - 3));
      return Je(i, e.length);
    }
  }, Yr = {
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }, $f = {
    G: function(n, e, t) {
      const r = n.getFullYear() > 0 ? 1 : 0;
      switch (e) {
        case "G":
        case "GG":
        case "GGG":
          return t.era(r, {
            width: "abbreviated"
          });
        case "GGGGG":
          return t.era(r, {
            width: "narrow"
          });
        case "GGGG":
        default:
          return t.era(r, {
            width: "wide"
          });
      }
    },
    y: function(n, e, t) {
      if (e === "yo") {
        const r = n.getFullYear(), i = r > 0 ? r : 1 - r;
        return t.ordinalNumber(i, {
          unit: "year"
        });
      }
      return Un.y(n, e);
    },
    Y: function(n, e, t, r) {
      const i = om(n, r), s = i > 0 ? i : 1 - i;
      if (e === "YY") {
        const o = s % 100;
        return Je(o, 2);
      }
      return e === "Yo" ? t.ordinalNumber(s, {
        unit: "year"
      }) : Je(s, e.length);
    },
    R: function(n, e) {
      const t = im(n);
      return Je(t, e.length);
    },
    u: function(n, e) {
      const t = n.getFullYear();
      return Je(t, e.length);
    },
    Q: function(n, e, t) {
      const r = Math.ceil((n.getMonth() + 1) / 3);
      switch (e) {
        case "Q":
          return String(r);
        case "QQ":
          return Je(r, 2);
        case "Qo":
          return t.ordinalNumber(r, {
            unit: "quarter"
          });
        case "QQQ":
          return t.quarter(r, {
            width: "abbreviated",
            context: "formatting"
          });
        case "QQQQQ":
          return t.quarter(r, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return t.quarter(r, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    q: function(n, e, t) {
      const r = Math.ceil((n.getMonth() + 1) / 3);
      switch (e) {
        case "q":
          return String(r);
        case "qq":
          return Je(r, 2);
        case "qo":
          return t.ordinalNumber(r, {
            unit: "quarter"
          });
        case "qqq":
          return t.quarter(r, {
            width: "abbreviated",
            context: "standalone"
          });
        case "qqqqq":
          return t.quarter(r, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return t.quarter(r, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    M: function(n, e, t) {
      const r = n.getMonth();
      switch (e) {
        case "M":
        case "MM":
          return Un.M(n, e);
        case "Mo":
          return t.ordinalNumber(r + 1, {
            unit: "month"
          });
        case "MMM":
          return t.month(r, {
            width: "abbreviated",
            context: "formatting"
          });
        case "MMMMM":
          return t.month(r, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return t.month(r, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    L: function(n, e, t) {
      const r = n.getMonth();
      switch (e) {
        case "L":
          return String(r + 1);
        case "LL":
          return Je(r + 1, 2);
        case "Lo":
          return t.ordinalNumber(r + 1, {
            unit: "month"
          });
        case "LLL":
          return t.month(r, {
            width: "abbreviated",
            context: "standalone"
          });
        case "LLLLL":
          return t.month(r, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return t.month(r, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    w: function(n, e, t, r) {
      const i = t3(n, r);
      return e === "wo" ? t.ordinalNumber(i, {
        unit: "week"
      }) : Je(i, e.length);
    },
    I: function(n, e, t) {
      const r = ZS(n);
      return e === "Io" ? t.ordinalNumber(r, {
        unit: "week"
      }) : Je(r, e.length);
    },
    d: function(n, e, t) {
      return e === "do" ? t.ordinalNumber(n.getDate(), {
        unit: "date"
      }) : Un.d(n, e);
    },
    D: function(n, e, t) {
      const r = QS(n);
      return e === "Do" ? t.ordinalNumber(r, {
        unit: "dayOfYear"
      }) : Je(r, e.length);
    },
    E: function(n, e, t) {
      const r = n.getDay();
      switch (e) {
        case "E":
        case "EE":
        case "EEE":
          return t.day(r, {
            width: "abbreviated",
            context: "formatting"
          });
        case "EEEEE":
          return t.day(r, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return t.day(r, {
            width: "short",
            context: "formatting"
          });
        case "EEEE":
        default:
          return t.day(r, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    e: function(n, e, t, r) {
      const i = n.getDay(), s = (i - r.weekStartsOn + 8) % 7 || 7;
      switch (e) {
        case "e":
          return String(s);
        case "ee":
          return Je(s, 2);
        case "eo":
          return t.ordinalNumber(s, {
            unit: "day"
          });
        case "eee":
          return t.day(i, {
            width: "abbreviated",
            context: "formatting"
          });
        case "eeeee":
          return t.day(i, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return t.day(i, {
            width: "short",
            context: "formatting"
          });
        case "eeee":
        default:
          return t.day(i, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    c: function(n, e, t, r) {
      const i = n.getDay(), s = (i - r.weekStartsOn + 8) % 7 || 7;
      switch (e) {
        case "c":
          return String(s);
        case "cc":
          return Je(s, e.length);
        case "co":
          return t.ordinalNumber(s, {
            unit: "day"
          });
        case "ccc":
          return t.day(i, {
            width: "abbreviated",
            context: "standalone"
          });
        case "ccccc":
          return t.day(i, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return t.day(i, {
            width: "short",
            context: "standalone"
          });
        case "cccc":
        default:
          return t.day(i, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    i: function(n, e, t) {
      const r = n.getDay(), i = r === 0 ? 7 : r;
      switch (e) {
        case "i":
          return String(i);
        case "ii":
          return Je(i, e.length);
        case "io":
          return t.ordinalNumber(i, {
            unit: "day"
          });
        case "iii":
          return t.day(r, {
            width: "abbreviated",
            context: "formatting"
          });
        case "iiiii":
          return t.day(r, {
            width: "narrow",
            context: "formatting"
          });
        case "iiiiii":
          return t.day(r, {
            width: "short",
            context: "formatting"
          });
        case "iiii":
        default:
          return t.day(r, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    a: function(n, e, t) {
      const i = n.getHours() / 12 >= 1 ? "pm" : "am";
      switch (e) {
        case "a":
        case "aa":
          return t.dayPeriod(i, {
            width: "abbreviated",
            context: "formatting"
          });
        case "aaa":
          return t.dayPeriod(i, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "aaaaa":
          return t.dayPeriod(i, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return t.dayPeriod(i, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    b: function(n, e, t) {
      const r = n.getHours();
      let i;
      switch (r === 12 ? i = Yr.noon : r === 0 ? i = Yr.midnight : i = r / 12 >= 1 ? "pm" : "am", e) {
        case "b":
        case "bb":
          return t.dayPeriod(i, {
            width: "abbreviated",
            context: "formatting"
          });
        case "bbb":
          return t.dayPeriod(i, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "bbbbb":
          return t.dayPeriod(i, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return t.dayPeriod(i, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    B: function(n, e, t) {
      const r = n.getHours();
      let i;
      switch (r >= 17 ? i = Yr.evening : r >= 12 ? i = Yr.afternoon : r >= 4 ? i = Yr.morning : i = Yr.night, e) {
        case "B":
        case "BB":
        case "BBB":
          return t.dayPeriod(i, {
            width: "abbreviated",
            context: "formatting"
          });
        case "BBBBB":
          return t.dayPeriod(i, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return t.dayPeriod(i, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    h: function(n, e, t) {
      if (e === "ho") {
        let r = n.getHours() % 12;
        return r === 0 && (r = 12), t.ordinalNumber(r, {
          unit: "hour"
        });
      }
      return Un.h(n, e);
    },
    H: function(n, e, t) {
      return e === "Ho" ? t.ordinalNumber(n.getHours(), {
        unit: "hour"
      }) : Un.H(n, e);
    },
    K: function(n, e, t) {
      const r = n.getHours() % 12;
      return e === "Ko" ? t.ordinalNumber(r, {
        unit: "hour"
      }) : Je(r, e.length);
    },
    k: function(n, e, t) {
      let r = n.getHours();
      return r === 0 && (r = 24), e === "ko" ? t.ordinalNumber(r, {
        unit: "hour"
      }) : Je(r, e.length);
    },
    m: function(n, e, t) {
      return e === "mo" ? t.ordinalNumber(n.getMinutes(), {
        unit: "minute"
      }) : Un.m(n, e);
    },
    s: function(n, e, t) {
      return e === "so" ? t.ordinalNumber(n.getSeconds(), {
        unit: "second"
      }) : Un.s(n, e);
    },
    S: function(n, e) {
      return Un.S(n, e);
    },
    X: function(n, e, t) {
      const r = n.getTimezoneOffset();
      if (r === 0) return "Z";
      switch (e) {
        case "X":
          return Hf(r);
        case "XXXX":
        case "XX":
          return xr(r);
        case "XXXXX":
        case "XXX":
        default:
          return xr(r, ":");
      }
    },
    x: function(n, e, t) {
      const r = n.getTimezoneOffset();
      switch (e) {
        case "x":
          return Hf(r);
        case "xxxx":
        case "xx":
          return xr(r);
        case "xxxxx":
        case "xxx":
        default:
          return xr(r, ":");
      }
    },
    O: function(n, e, t) {
      const r = n.getTimezoneOffset();
      switch (e) {
        case "O":
        case "OO":
        case "OOO":
          return "GMT" + Vf(r, ":");
        case "OOOO":
        default:
          return "GMT" + xr(r, ":");
      }
    },
    z: function(n, e, t) {
      const r = n.getTimezoneOffset();
      switch (e) {
        case "z":
        case "zz":
        case "zzz":
          return "GMT" + Vf(r, ":");
        case "zzzz":
        default:
          return "GMT" + xr(r, ":");
      }
    },
    t: function(n, e, t) {
      const r = Math.trunc(+n / 1e3);
      return Je(r, e.length);
    },
    T: function(n, e, t) {
      return Je(+n, e.length);
    }
  };
  function Vf(n, e = "") {
    const t = n > 0 ? "-" : "+", r = Math.abs(n), i = Math.trunc(r / 60), s = r % 60;
    return s === 0 ? t + String(i) : t + String(i) + e + Je(s, 2);
  }
  function Hf(n, e) {
    return n % 60 === 0 ? (n > 0 ? "-" : "+") + Je(Math.abs(n) / 60, 2) : xr(n, e);
  }
  function xr(n, e = "") {
    const t = n > 0 ? "-" : "+", r = Math.abs(n), i = Je(Math.trunc(r / 60), 2), s = Je(r % 60, 2);
    return t + i + e + s;
  }
  const Wf = (n, e) => {
    switch (n) {
      case "P":
        return e.date({
          width: "short"
        });
      case "PP":
        return e.date({
          width: "medium"
        });
      case "PPP":
        return e.date({
          width: "long"
        });
      case "PPPP":
      default:
        return e.date({
          width: "full"
        });
    }
  }, am = (n, e) => {
    switch (n) {
      case "p":
        return e.time({
          width: "short"
        });
      case "pp":
        return e.time({
          width: "medium"
        });
      case "ppp":
        return e.time({
          width: "long"
        });
      case "pppp":
      default:
        return e.time({
          width: "full"
        });
    }
  }, n3 = (n, e) => {
    const t = n.match(/(P+)(p+)?/) || [], r = t[1], i = t[2];
    if (!i) return Wf(n, e);
    let s;
    switch (r) {
      case "P":
        s = e.dateTime({
          width: "short"
        });
        break;
      case "PP":
        s = e.dateTime({
          width: "medium"
        });
        break;
      case "PPP":
        s = e.dateTime({
          width: "long"
        });
        break;
      case "PPPP":
      default:
        s = e.dateTime({
          width: "full"
        });
        break;
    }
    return s.replace("{{date}}", Wf(r, e)).replace("{{time}}", am(i, e));
  }, r3 = {
    p: am,
    P: n3
  }, i3 = /^D+$/, s3 = /^Y+$/, o3 = [
    "D",
    "DD",
    "YY",
    "YYYY"
  ];
  function a3(n) {
    return i3.test(n);
  }
  function u3(n) {
    return s3.test(n);
  }
  function l3(n, e, t) {
    const r = c3(n, e, t);
    if (console.warn(r), o3.includes(n)) throw new RangeError(r);
  }
  function c3(n, e, t) {
    const r = n[0] === "Y" ? "years" : "days of the month";
    return `Use \`${n.toLowerCase()}\` instead of \`${n}\` (in \`${e}\`) for formatting ${r} to the input \`${t}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
  }
  const d3 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, f3 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, h3 = /^'([^]*?)'?$/, p3 = /''/g, m3 = /[a-zA-Z]/;
  Uf = function(n, e, t) {
    const r = ta(), i = r.locale ?? XS, s = r.firstWeekContainsDate ?? r.locale?.options?.firstWeekContainsDate ?? 1, o = r.weekStartsOn ?? r.locale?.options?.weekStartsOn ?? 0, a = pn(n, t?.in);
    if (!bS(a)) throw new RangeError("Invalid time value");
    let u = e.match(f3).map((c) => {
      const h = c[0];
      if (h === "p" || h === "P") {
        const d = r3[h];
        return d(c, i.formatLong);
      }
      return c;
    }).join("").match(d3).map((c) => {
      if (c === "''") return {
        isToken: false,
        value: "'"
      };
      const h = c[0];
      if (h === "'") return {
        isToken: false,
        value: g3(c)
      };
      if ($f[h]) return {
        isToken: true,
        value: c
      };
      if (h.match(m3)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + h + "`");
      return {
        isToken: false,
        value: c
      };
    });
    i.localize.preprocessor && (u = i.localize.preprocessor(a, u));
    const l = {
      firstWeekContainsDate: s,
      weekStartsOn: o,
      locale: i
    };
    return u.map((c) => {
      if (!c.isToken) return c.value;
      const h = c.value;
      (u3(h) || a3(h)) && l3(h, e, String(n));
      const d = $f[h[0]];
      return d(a, h, i.localize, l);
    }).join("");
  };
  function g3(n) {
    const e = n.match(h3);
    return e ? e[1].replace(p3, "'") : n;
  }
  b3 = function(n, e) {
    return mS(On(n, n), pS(n));
  };
  function Os(n) {
    if (typeof n != "string" || !n) throw new Error("expected a non-empty string, got: " + n);
  }
  function fu(n) {
    if (typeof n != "number") throw new Error("expected a number, got: " + n);
  }
  const y3 = 1, v3 = 1, Ur = "emoji", pi = "keyvalue", Jl = "favorites", w3 = "tokens", um = "tokens", x3 = "unicode", lm = "count", k3 = "group", S3 = "order", cm = "group-order", Ju = "eTag", yo = "url", Gf = "skinTone", gi = "readonly", Yl = "readwrite", dm = "skinUnicodes", T3 = "skinUnicodes", E3 = "https://cdn.jsdelivr.net/npm/emoji-picker-element-data@^1/en/emojibase/data.json", C3 = "en";
  function O3(n, e) {
    const t = /* @__PURE__ */ new Set(), r = [];
    for (const i of n) {
      const s = e(i);
      t.has(s) || (t.add(s), r.push(i));
    }
    return r;
  }
  function Kf(n) {
    return O3(n, (e) => e.unicode);
  }
  function A3(n) {
    function e(t, r, i) {
      const s = r ? n.createObjectStore(t, {
        keyPath: r
      }) : n.createObjectStore(t);
      if (i) for (const [o, [a, u]] of Object.entries(i)) s.createIndex(o, a, {
        multiEntry: u
      });
      return s;
    }
    e(pi), e(Ur, x3, {
      [um]: [
        w3,
        true
      ],
      [cm]: [
        [
          k3,
          S3
        ]
      ],
      [dm]: [
        T3,
        true
      ]
    }), e(Jl, void 0, {
      [lm]: [
        ""
      ]
    });
  }
  const Yu = {}, Us = {}, vo = {};
  function fm(n, e, t) {
    t.onerror = () => e(t.error), t.onblocked = () => e(new Error("IDB blocked")), t.onsuccess = () => n(t.result);
  }
  async function M3(n) {
    const e = await new Promise((t, r) => {
      const i = indexedDB.open(n, y3);
      Yu[n] = i, i.onupgradeneeded = (s) => {
        s.oldVersion < v3 && A3(i.result);
      }, fm(t, r, i);
    });
    return e.onclose = () => Xl(n), e;
  }
  function N3(n) {
    return Us[n] || (Us[n] = M3(n)), Us[n];
  }
  function Hn(n, e, t, r) {
    return new Promise((i, s) => {
      const o = n.transaction(e, t, {
        durability: "relaxed"
      }), a = typeof e == "string" ? o.objectStore(e) : e.map((l) => o.objectStore(l));
      let u;
      r(a, o, (l) => {
        u = l;
      }), o.oncomplete = () => i(u), o.onerror = () => s(o.error);
    });
  }
  function Xl(n) {
    const e = Yu[n], t = e && e.result;
    if (t) {
      t.close();
      const r = vo[n];
      if (r) for (const i of r) i();
    }
    delete Yu[n], delete Us[n], delete vo[n];
  }
  function P3(n) {
    return new Promise((e, t) => {
      Xl(n);
      const r = indexedDB.deleteDatabase(n);
      fm(e, t, r);
    });
  }
  function D3(n, e) {
    let t = vo[n];
    t || (t = vo[n] = []), t.push(e);
  }
  const I3 = /* @__PURE__ */ new Set([
    ":D",
    "XD",
    ":'D",
    "O:)",
    ":X",
    ":P",
    ";P",
    "XP",
    ":L",
    ":Z",
    ":j",
    "8D",
    "XO",
    "8)",
    ":B",
    ":O",
    ":S",
    ":'o",
    "Dx",
    "X(",
    "D:",
    ":C",
    ">0)",
    ":3",
    "</3",
    "<3",
    "\\M/",
    ":E",
    "8#"
  ]);
  function ri(n) {
    return n.split(/[\s_]+/).map((e) => !e.match(/\w/) || I3.has(e) ? e.toLowerCase() : e.replace(/[)(:,]/g, "").replace(//g, "'").toLowerCase()).filter(Boolean);
  }
  const R3 = 2;
  function hm(n) {
    return n.filter(Boolean).map((e) => e.toLowerCase()).filter((e) => e.length >= R3);
  }
  function _3(n) {
    return n.map(({ annotation: t, emoticon: r, group: i, order: s, shortcodes: o, skins: a, tags: u, emoji: l, version: c }) => {
      const h = [
        ...new Set(hm([
          ...(o || []).map(ri).flat(),
          ...(u || []).map(ri).flat(),
          ...ri(t),
          r
        ]))
      ].sort(), d = {
        annotation: t,
        group: i,
        order: s,
        tags: u,
        tokens: h,
        unicode: l,
        version: c
      };
      if (r && (d.emoticon = r), o && (d.shortcodes = o), a) {
        d.skinTones = [], d.skinUnicodes = [], d.skinVersions = [];
        for (const { tone: f, emoji: p, version: m } of a) d.skinTones.push(f), d.skinUnicodes.push(p), d.skinVersions.push(m);
      }
      return d;
    });
  }
  function pm(n, e, t, r) {
    n[e](t).onsuccess = (i) => r && r(i.target.result);
  }
  function $r(n, e, t) {
    pm(n, "get", e, t);
  }
  function mm(n, e, t) {
    pm(n, "getAll", e, t);
  }
  function Ql(n) {
    n.commit && n.commit();
  }
  function L3(n, e) {
    let t = n[0];
    for (let r = 1; r < n.length; r++) {
      const i = n[r];
      e(t) > e(i) && (t = i);
    }
    return t;
  }
  function gm(n, e) {
    const t = L3(n, (i) => i.length), r = [];
    for (const i of t) n.some((s) => s.findIndex((o) => e(o) === e(i)) === -1) || r.push(i);
    return r;
  }
  async function B3(n) {
    return !await Zl(n, pi, yo);
  }
  async function F3(n, e, t) {
    const [r, i] = await Promise.all([
      Ju,
      yo
    ].map((s) => Zl(n, pi, s)));
    return r === t && i === e;
  }
  async function z3(n, e) {
    return Hn(n, Ur, gi, (r, i, s) => {
      let o;
      const a = () => {
        r.getAll(o && IDBKeyRange.lowerBound(o, true), 50).onsuccess = (u) => {
          const l = u.target.result;
          for (const c of l) if (o = c.unicode, e(c)) return s(c);
          if (l.length < 50) return s();
          a();
        };
      };
      a();
    });
  }
  async function bm(n, e, t, r) {
    try {
      const i = _3(e);
      await Hn(n, [
        Ur,
        pi
      ], Yl, ([s, o], a) => {
        let u, l, c = 0;
        function h() {
          ++c === 2 && d();
        }
        function d() {
          if (!(u === r && l === t)) {
            s.clear();
            for (const f of i) s.put(f);
            o.put(r, Ju), o.put(t, yo), Ql(a);
          }
        }
        $r(o, Ju, (f) => {
          u = f, h();
        }), $r(o, yo, (f) => {
          l = f, h();
        });
      });
    } finally {
    }
  }
  async function j3(n, e) {
    return Hn(n, Ur, gi, (t, r, i) => {
      const s = IDBKeyRange.bound([
        e,
        0
      ], [
        e + 1,
        0
      ], false, true);
      mm(t.index(cm), s, i);
    });
  }
  async function ym(n, e) {
    const t = hm(ri(e));
    return t.length ? Hn(n, Ur, gi, (r, i, s) => {
      const o = [], a = () => {
        o.length === t.length && u();
      }, u = () => {
        const l = gm(o, (c) => c.unicode);
        s(l.sort((c, h) => c.order < h.order ? -1 : 1));
      };
      for (let l = 0; l < t.length; l++) {
        const c = t[l], h = l === t.length - 1 ? IDBKeyRange.bound(c, c + "\uFFFF", false, true) : IDBKeyRange.only(c);
        mm(r.index(um), h, (d) => {
          o.push(d), a();
        });
      }
    }) : [];
  }
  async function q3(n, e) {
    const t = await ym(n, e);
    return t.length ? t.filter((r) => (r.shortcodes || []).map((s) => s.toLowerCase()).includes(e.toLowerCase()))[0] || null : await z3(n, (i) => (i.shortcodes || []).includes(e.toLowerCase())) || null;
  }
  async function $3(n, e) {
    return Hn(n, Ur, gi, (t, r, i) => $r(t, e, (s) => {
      if (s) return i(s);
      $r(t.index(dm), e, (o) => i(o || null));
    }));
  }
  function Zl(n, e, t) {
    return Hn(n, e, gi, (r, i, s) => $r(r, t, s));
  }
  function V3(n, e, t, r) {
    return Hn(n, e, Yl, (i, s) => {
      i.put(r, t), Ql(s);
    });
  }
  function H3(n, e) {
    return Hn(n, Jl, Yl, (t, r) => $r(t, e, (i) => {
      t.put((i || 0) + 1, e), Ql(r);
    }));
  }
  function W3(n, e, t) {
    return t === 0 ? [] : Hn(n, [
      Jl,
      Ur
    ], gi, ([r, i], s, o) => {
      const a = [];
      r.index(lm).openCursor(void 0, "prev").onsuccess = (u) => {
        const l = u.target.result;
        if (!l) return o(a);
        function c(f) {
          if (a.push(f), a.length === t) return o(a);
          l.continue();
        }
        const h = l.primaryKey, d = e.byName(h);
        if (d) return c(d);
        $r(i, h, (f) => {
          if (f) return c(f);
          l.continue();
        });
      };
    });
  }
  const As = "";
  function U3(n, e) {
    const t = /* @__PURE__ */ new Map();
    for (const i of n) {
      const s = e(i);
      for (const o of s) {
        let a = t;
        for (let l = 0; l < o.length; l++) {
          const c = o.charAt(l);
          let h = a.get(c);
          h || (h = /* @__PURE__ */ new Map(), a.set(c, h)), a = h;
        }
        let u = a.get(As);
        u || (u = [], a.set(As, u)), u.push(i);
      }
    }
    return (i, s) => {
      let o = t;
      for (let l = 0; l < i.length; l++) {
        const c = i.charAt(l), h = o.get(c);
        if (h) o = h;
        else return [];
      }
      if (s) return o.get(As) || [];
      const a = [], u = [
        o
      ];
      for (; u.length; ) {
        const c = [
          ...u.shift().entries()
        ].sort((h, d) => h[0] < d[0] ? -1 : 1);
        for (const [h, d] of c) h === As ? a.push(...d) : u.push(d);
      }
      return a;
    };
  }
  const G3 = [
    "name",
    "url"
  ];
  function K3(n) {
    const e = n && Array.isArray(n), t = e && n.length && (!n[0] || G3.some((r) => !(r in n[0])));
    if (!e || t) throw new Error("Custom emojis are in the wrong format");
  }
  function Jf(n) {
    K3(n);
    const e = (d, f) => d.name.toLowerCase() < f.name.toLowerCase() ? -1 : 1, t = n.sort(e), i = U3(n, (d) => {
      const f = /* @__PURE__ */ new Set();
      if (d.shortcodes) for (const p of d.shortcodes) for (const m of ri(p)) f.add(m);
      return f;
    }), s = (d) => i(d, true), o = (d) => i(d, false), a = (d) => {
      const f = ri(d), p = f.map((m, b) => (b < f.length - 1 ? s : o)(m));
      return gm(p, (m) => m.name).sort(e);
    }, u = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map();
    for (const d of n) {
      l.set(d.name.toLowerCase(), d);
      for (const f of d.shortcodes || []) u.set(f.toLowerCase(), d);
    }
    return {
      all: t,
      search: a,
      byShortcode: (d) => u.get(d.toLowerCase()),
      byName: (d) => l.get(d.toLowerCase())
    };
  }
  const J3 = typeof wrappedJSObject < "u";
  function Oi(n) {
    if (!n) return n;
    if (J3 && (n = structuredClone(n)), delete n.tokens, n.skinTones) {
      const e = n.skinTones.length;
      n.skins = Array(e);
      for (let t = 0; t < e; t++) n.skins[t] = {
        tone: n.skinTones[t],
        unicode: n.skinUnicodes[t],
        version: n.skinVersions[t]
      };
      delete n.skinTones, delete n.skinUnicodes, delete n.skinVersions;
    }
    return n;
  }
  function vm(n) {
    n || console.warn("emoji-picker-element is more efficient if the dataSource server exposes an ETag header.");
  }
  const Y3 = [
    "annotation",
    "emoji",
    "group",
    "order",
    "version"
  ];
  function X3(n) {
    if (!n || !Array.isArray(n) || !n[0] || typeof n[0] != "object" || Y3.some((e) => !(e in n[0]))) throw new Error("Emoji data is in the wrong format");
  }
  function wm(n, e) {
    if (Math.floor(n.status / 100) !== 2) throw new Error("Failed to fetch: " + e + ":  " + n.status);
  }
  async function Q3(n) {
    const e = await fetch(n, {
      method: "HEAD"
    });
    wm(e, n);
    const t = e.headers.get("etag");
    return vm(t), t;
  }
  async function Xu(n) {
    const e = await fetch(n);
    wm(e, n);
    const t = e.headers.get("etag");
    vm(t);
    const r = await e.json();
    return X3(r), [
      t,
      r
    ];
  }
  function Z3(n) {
    for (var e = "", t = new Uint8Array(n), r = t.byteLength, i = -1; ++i < r; ) e += String.fromCharCode(t[i]);
    return e;
  }
  function eT(n) {
    for (var e = n.length, t = new ArrayBuffer(e), r = new Uint8Array(t), i = -1; ++i < e; ) r[i] = n.charCodeAt(i);
    return t;
  }
  async function xm(n) {
    const e = JSON.stringify(n);
    let t = eT(e);
    const r = await crypto.subtle.digest("SHA-1", t), i = Z3(r);
    return btoa(i);
  }
  async function tT(n, e) {
    let t, r = await Q3(e);
    if (!r) {
      const i = await Xu(e);
      r = i[0], t = i[1], r || (r = await xm(t));
    }
    await F3(n, e, r) || (t || (t = (await Xu(e))[1]), await bm(n, t, e, r));
  }
  async function nT(n, e) {
    let [t, r] = await Xu(e);
    t || (t = await xm(r)), await bm(n, r, e, t);
  }
  class rT {
    constructor({ dataSource: e = E3, locale: t = C3, customEmoji: r = [] } = {}) {
      this.dataSource = e, this.locale = t, this._dbName = `emoji-picker-element-${this.locale}`, this._db = void 0, this._lazyUpdate = void 0, this._custom = Jf(r), this._clear = this._clear.bind(this), this._ready = this._init();
    }
    async _init() {
      const e = this._db = await N3(this._dbName);
      D3(this._dbName, this._clear);
      const t = this.dataSource;
      await B3(e) ? await nT(e, t) : this._lazyUpdate = tT(e, t);
    }
    async ready() {
      const e = async () => (this._ready || (this._ready = this._init()), this._ready);
      await e(), this._db || await e();
    }
    async getEmojiByGroup(e) {
      return fu(e), await this.ready(), Kf(await j3(this._db, e)).map(Oi);
    }
    async getEmojiBySearchQuery(e) {
      Os(e), await this.ready();
      const t = this._custom.search(e), r = Kf(await ym(this._db, e)).map(Oi);
      return [
        ...t,
        ...r
      ];
    }
    async getEmojiByShortcode(e) {
      Os(e), await this.ready();
      const t = this._custom.byShortcode(e);
      return t || Oi(await q3(this._db, e));
    }
    async getEmojiByUnicodeOrName(e) {
      Os(e), await this.ready();
      const t = this._custom.byName(e);
      return t || Oi(await $3(this._db, e));
    }
    async getPreferredSkinTone() {
      return await this.ready(), await Zl(this._db, pi, Gf) || 0;
    }
    async setPreferredSkinTone(e) {
      return fu(e), await this.ready(), V3(this._db, pi, Gf, e);
    }
    async incrementFavoriteEmojiCount(e) {
      return Os(e), await this.ready(), H3(this._db, e);
    }
    async getTopFavoriteEmoji(e) {
      return fu(e), await this.ready(), (await W3(this._db, this._custom, e)).map(Oi);
    }
    set customEmoji(e) {
      this._custom = Jf(e);
    }
    get customEmoji() {
      return this._custom.all;
    }
    async _shutdown() {
      await this.ready();
      try {
        await this._lazyUpdate;
      } catch {
      }
    }
    _clear() {
      this._db = this._ready = this._lazyUpdate = void 0;
    }
    async close() {
      await this._shutdown(), await Xl(this._dbName);
    }
    async delete() {
      await this._shutdown(), await P3(this._dbName);
    }
  }
  const Qu = [
    [
      -1,
      "\u2728",
      "custom"
    ],
    [
      0,
      "\u{1F600}",
      "smileys-emotion"
    ],
    [
      1,
      "\u{1F44B}",
      "people-body"
    ],
    [
      3,
      "\u{1F431}",
      "animals-nature"
    ],
    [
      4,
      "\u{1F34E}",
      "food-drink"
    ],
    [
      5,
      "\u{1F3E0}\uFE0F",
      "travel-places"
    ],
    [
      6,
      "\u26BD",
      "activities"
    ],
    [
      7,
      "\u{1F4DD}",
      "objects"
    ],
    [
      8,
      "\u26D4\uFE0F",
      "symbols"
    ],
    [
      9,
      "\u{1F3C1}",
      "flags"
    ]
  ].map(([n, e, t]) => ({
    id: n,
    emoji: e,
    name: t
  })), hu = Qu.slice(1), iT = 2, Yf = 6, km = typeof requestIdleCallback == "function" ? requestIdleCallback : setTimeout;
  function Xf(n) {
    return n.unicode.includes("\u200D");
  }
  const sT = {
    "\u{1FAE9}": 16,
    "\u{1FAE8}": 15.1,
    "\u{1FAE0}": 14,
    "\u{1F972}": 13.1,
    "\u{1F97B}": 12.1,
    "\u{1F970}": 11,
    "\u{1F929}": 5,
    "\u{1F471}\u200D\u2640\uFE0F": 4,
    "\u{1F923}": 3,
    "\u{1F441}\uFE0F\u200D\u{1F5E8}\uFE0F": 2,
    "\u{1F600}": 1,
    "\u{1F610}\uFE0F": 0.7,
    "\u{1F603}": 0.6
  }, oT = 1e3, aT = "\u{1F590}\uFE0F", uT = 8, lT = [
    "\u{1F60A}",
    "\u{1F612}",
    "\u2764\uFE0F",
    "\u{1F44D}\uFE0F",
    "\u{1F60D}",
    "\u{1F602}",
    "\u{1F62D}",
    "\u263A\uFE0F",
    "\u{1F614}",
    "\u{1F629}",
    "\u{1F60F}",
    "\u{1F495}",
    "\u{1F64C}",
    "\u{1F618}"
  ], Sm = '"Twemoji Mozilla","Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji","EmojiOne Color","Android Emoji",sans-serif', cT = (n, e) => n < e ? -1 : n > e ? 1 : 0, Qf = (n, e) => {
    const t = document.createElement("canvas");
    t.width = t.height = 1;
    const r = t.getContext("2d", {
      willReadFrequently: true
    });
    return r.textBaseline = "top", r.font = `100px ${Sm}`, r.fillStyle = e, r.scale(0.01, 0.01), r.fillText(n, 0, 0), r.getImageData(0, 0, 1, 1).data;
  }, dT = (n, e) => {
    const t = [
      ...n
    ].join(","), r = [
      ...e
    ].join(",");
    return t === r && !t.startsWith("0,0,0,");
  };
  function fT(n) {
    const e = Qf(n, "#000"), t = Qf(n, "#fff");
    return e && t && dT(e, t);
  }
  function hT() {
    const n = Object.entries(sT);
    try {
      for (const [e, t] of n) if (fT(e)) return t;
    } catch {
    } finally {
    }
    return n[0][1];
  }
  let pu;
  const mu = () => (pu || (pu = new Promise((n) => km(() => n(hT())))), pu), Zu = /* @__PURE__ */ new Map(), pT = "\uFE0F", mT = "\uD83C", gT = "\u200D", bT = 127995, yT = 57339;
  function vT(n, e) {
    if (e === 0) return n;
    const t = n.indexOf(gT);
    return t !== -1 ? n.substring(0, t) + String.fromCodePoint(bT + e - 1) + n.substring(t) : (n.endsWith(pT) && (n = n.substring(0, n.length - 1)), n + mT + String.fromCodePoint(yT + e - 1));
  }
  function bn(n) {
    n.preventDefault(), n.stopPropagation();
  }
  function gu(n, e, t) {
    return e += n ? -1 : 1, e < 0 ? e = t.length - 1 : e >= t.length && (e = 0), e;
  }
  function Tm(n, e) {
    const t = /* @__PURE__ */ new Set(), r = [];
    for (const i of n) {
      const s = e(i);
      t.has(s) || (t.add(s), r.push(i));
    }
    return r;
  }
  function wT(n, e) {
    const t = (r) => {
      const i = {};
      for (const s of r) typeof s.tone == "number" && s.version <= e && (i[s.tone] = s.unicode);
      return i;
    };
    return n.map(({ unicode: r, skins: i, shortcodes: s, url: o, name: a, category: u, annotation: l }) => ({
      unicode: r,
      name: a,
      shortcodes: s,
      url: o,
      category: u,
      annotation: l,
      id: r || a,
      skins: i && t(i)
    }));
  }
  const Gs = requestAnimationFrame;
  let xT = typeof ResizeObserver == "function";
  function kT(n, e, t) {
    let r;
    xT ? (r = new ResizeObserver(t), r.observe(n)) : Gs(t), e.addEventListener("abort", () => {
      r && r.disconnect();
    });
  }
  function Zf(n) {
    {
      const e = document.createRange();
      return e.selectNode(n.firstChild), e.getBoundingClientRect().width;
    }
  }
  let bu;
  function ST(n, e, t) {
    let r = true;
    for (const i of n) {
      const s = t(i), o = Zf(s);
      typeof bu > "u" && (bu = Zf(e));
      const a = o / 1.8 < bu;
      Zu.set(i.unicode, a), a || (r = false);
    }
    return r;
  }
  function TT(n) {
    return Tm(n, (e) => e);
  }
  function ET(n) {
    n && (n.scrollTop = 0);
  }
  function Fi(n, e, t) {
    let r = n.get(e);
    return r || (r = t(), n.set(e, r)), r;
  }
  function eh(n) {
    return "" + n;
  }
  function CT(n) {
    const e = document.createElement("template");
    return e.innerHTML = n, e;
  }
  const OT = /* @__PURE__ */ new WeakMap(), AT = /* @__PURE__ */ new WeakMap(), MT = Symbol("un-keyed"), NT = "replaceChildren" in Element.prototype;
  function PT(n, e) {
    NT ? n.replaceChildren(...e) : (n.innerHTML = "", n.append(...e));
  }
  function DT(n, e) {
    let t = n.firstChild, r = 0;
    for (; t; ) {
      if (e[r] !== t) return true;
      t = t.nextSibling, r++;
    }
    return r !== e.length;
  }
  function IT(n, e) {
    const { targetNode: t } = e;
    let { targetParentNode: r } = e, i = false;
    r ? i = DT(r, n) : (i = true, e.targetNode = void 0, e.targetParentNode = r = t.parentNode), i && PT(r, n);
  }
  function RT(n, e) {
    for (const t of e) {
      const { targetNode: r, currentExpression: i, binding: { expressionIndex: s, attributeName: o, attributeValuePre: a, attributeValuePost: u } } = t, l = n[s];
      if (i !== l) if (t.currentExpression = l, o) r.setAttribute(o, a + eh(l) + u);
      else {
        let c;
        Array.isArray(l) ? IT(l, t) : l instanceof Element ? (c = l, r.replaceWith(c)) : r.nodeValue = eh(l), c && (t.targetNode = c);
      }
    }
  }
  function _T(n) {
    let e = "", t = false, r = false, i = -1;
    const s = /* @__PURE__ */ new Map(), o = [];
    for (let u = 0, l = n.length; u < l; u++) {
      const c = n[u];
      if (e += c, u === l - 1) break;
      for (let g = 0; g < c.length; g++) switch (c.charAt(g)) {
        case "<": {
          c.charAt(g + 1) === "/" ? o.pop() : (t = true, o.push(++i));
          break;
        }
        case ">": {
          t = false, r = false;
          break;
        }
        case "=": {
          r = true;
          break;
        }
      }
      const h = o[o.length - 1], d = Fi(s, h, () => []);
      let f, p, m;
      if (r) {
        const g = /(\S+)="?([^"=]*)$/.exec(c);
        f = g[1], p = g[2], m = /^[^">]*/.exec(n[u + 1])[0];
      }
      const b = {
        attributeName: f,
        attributeValuePre: p,
        attributeValuePost: m,
        expressionIndex: u
      };
      d.push(b), !t && !r && (e += " ");
    }
    return {
      template: CT(e),
      elementsToBindings: s
    };
  }
  function th(n, e, t) {
    for (let r = 0; r < n.length; r++) {
      const i = n[r], s = i.attributeName ? e : e.firstChild, o = {
        binding: i,
        targetNode: s,
        targetParentNode: void 0,
        currentExpression: void 0
      };
      t.push(o);
    }
  }
  function LT(n, e) {
    const t = [];
    let r;
    if (e.size === 1 && (r = e.get(0))) th(r, n, t);
    else {
      const i = document.createTreeWalker(n, NodeFilter.SHOW_ELEMENT);
      let s = n, o = -1;
      do {
        const a = e.get(++o);
        a && th(a, s, t);
      } while (s = i.nextNode());
    }
    return t;
  }
  function BT(n) {
    const { template: e, elementsToBindings: t } = Fi(OT, n, () => _T(n)), r = e.cloneNode(true).content.firstElementChild, i = LT(r, t);
    return function(o) {
      return RT(o, i), r;
    };
  }
  function FT(n) {
    const e = Fi(AT, n, () => /* @__PURE__ */ new Map());
    let t = MT;
    function r(s, ...o) {
      const a = Fi(e, s, () => /* @__PURE__ */ new Map());
      return Fi(a, t, () => BT(s))(o);
    }
    function i(s, o, a) {
      return s.map((u, l) => {
        const c = t;
        t = a(u);
        try {
          return o(u, l);
        } finally {
          t = c;
        }
      });
    }
    return {
      map: i,
      html: r
    };
  }
  function zT(n, e, t, r, i, s, o, a, u) {
    const { labelWithSkin: l, titleForEmoji: c, unicodeWithSkin: h } = t, { html: d, map: f } = FT(e);
    function p(w, v, y) {
      return f(w, (x, k) => d`<button role="${v ? "option" : "menuitem"}" aria-selected="${v ? k === e.activeSearchItem : ""}" aria-label="${l(x, e.currentSkinTone)}" title="${c(x)}" class="${"emoji" + (v && k === e.activeSearchItem ? " active" : "") + (x.unicode ? "" : " custom-emoji")}" id="${`${y}-${x.id}`}" style="${x.unicode ? "" : `--custom-emoji-background: url(${JSON.stringify(x.url)})`}">${x.unicode ? h(x, e.currentSkinTone) : ""}</button>`, (x) => `${y}-${x.id}`);
    }
    const b = d`<section data-ref="rootElement" class="picker" aria-label="${e.i18n.regionLabel}" style="${e.pickerStyle || ""}"><div class="pad-top"></div><div class="search-row"><div class="search-wrapper"><input id="search" class="search" type="search" role="combobox" enterkeyhint="search" placeholder="${e.i18n.searchLabel}" autocapitalize="none" autocomplete="off" spellcheck="true" aria-expanded="${!!(e.searchMode && e.currentEmojis.length)}" aria-controls="search-results" aria-describedby="search-description" aria-autocomplete="list" aria-activedescendant="${e.activeSearchItemId ? `emo-${e.activeSearchItemId}` : ""}" data-ref="searchElement" data-on-input="onSearchInput" data-on-keydown="onSearchKeydown"><label class="sr-only" for="search">${e.i18n.searchLabel}</label> <span id="search-description" class="sr-only">${e.i18n.searchDescription}</span></div><div class="skintone-button-wrapper ${e.skinTonePickerExpandedAfterAnimation ? "expanded" : ""}"><button id="skintone-button" class="emoji ${e.skinTonePickerExpanded ? "hide-focus" : ""}" aria-label="${e.skinToneButtonLabel}" title="${e.skinToneButtonLabel}" aria-describedby="skintone-description" aria-haspopup="listbox" aria-expanded="${e.skinTonePickerExpanded}" aria-controls="skintone-list" data-on-click="onClickSkinToneButton">${e.skinToneButtonText || ""}</button></div><span id="skintone-description" class="sr-only">${e.i18n.skinToneDescription}</span><div data-ref="skinToneDropdown" id="skintone-list" class="skintone-list hide-focus ${e.skinTonePickerExpanded ? "" : "hidden no-animate"}" style="transform:translateY(${e.skinTonePickerExpanded ? 0 : "calc(-1 * var(--num-skintones) * var(--total-emoji-size))"})" role="listbox" aria-label="${e.i18n.skinTonesLabel}" aria-activedescendant="skintone-${e.activeSkinTone}" aria-hidden="${!e.skinTonePickerExpanded}" tabIndex="-1" data-on-focusout="onSkinToneOptionsFocusOut" data-on-click="onSkinToneOptionsClick" data-on-keydown="onSkinToneOptionsKeydown" data-on-keyup="onSkinToneOptionsKeyup">${f(e.skinTones, (w, v) => d`<div id="skintone-${v}" class="emoji ${v === e.activeSkinTone ? "active" : ""}" aria-selected="${v === e.activeSkinTone}" role="option" title="${e.i18n.skinTones[v]}" aria-label="${e.i18n.skinTones[v]}">${w}</div>`, (w) => w)}</div></div><div class="nav" role="tablist" style="grid-template-columns:repeat(${e.groups.length},1fr)" aria-label="${e.i18n.categoriesLabel}" data-on-keydown="onNavKeydown" data-on-click="onNavClick">${f(e.groups, (w) => d`<button role="tab" class="nav-button" aria-controls="tab-${w.id}" aria-label="${e.i18n.categories[w.name]}" aria-selected="${!e.searchMode && e.currentGroup.id === w.id}" title="${e.i18n.categories[w.name]}" data-group-id="${w.id}"><div class="nav-emoji emoji">${w.emoji}</div></button>`, (w) => w.id)}</div><div class="indicator-wrapper"><div class="indicator" style="transform:translateX(${(e.isRtl ? -1 : 1) * e.currentGroupIndex * 100}%)"></div></div><div class="message ${e.message ? "" : "gone"}" role="alert" aria-live="polite">${e.message || ""}</div><div data-ref="tabpanelElement" class="tabpanel ${!e.databaseLoaded || e.message ? "gone" : ""}" role="${e.searchMode ? "region" : "tabpanel"}" aria-label="${e.searchMode ? e.i18n.searchResultsLabel : e.i18n.categories[e.currentGroup.name]}" id="${e.searchMode ? "" : `tab-${e.currentGroup.id}`}" tabIndex="0" data-on-click="onEmojiClick"><div data-action="calculateEmojiGridStyle">${f(e.currentEmojisWithCategories, (w, v) => d`<div><div id="menu-label-${v}" class="category ${e.currentEmojisWithCategories.length === 1 && e.currentEmojisWithCategories[0].category === "" ? "gone" : ""}" aria-hidden="true">${e.searchMode ? e.i18n.searchResultsLabel : w.category ? w.category : e.currentEmojisWithCategories.length > 1 ? e.i18n.categories.custom : e.i18n.categories[e.currentGroup.name]}</div><div class="emoji-menu ${v !== 0 && !e.searchMode && e.currentGroup.id === -1 ? "visibility-auto" : ""}" style="${`--num-rows: ${Math.ceil(w.emojis.length / e.numColumns)}`}" data-action="updateOnIntersection" role="${e.searchMode ? "listbox" : "menu"}" aria-labelledby="menu-label-${v}" id="${e.searchMode ? "search-results" : ""}">${p(w.emojis, e.searchMode, "emo")}</div></div>`, (w) => w.category)}</div></div><div class="favorites onscreen emoji-menu ${e.message ? "gone" : ""}" role="menu" aria-label="${e.i18n.favoritesLabel}" data-on-click="onEmojiClick">${p(e.currentFavorites, false, "fav")}</div><button data-ref="baselineEmoji" aria-hidden="true" tabindex="-1" class="abs-pos hidden emoji baseline-emoji"></button></section>`, g = (w, v) => {
      for (const y of n.querySelectorAll(`[${w}]`)) v(y, y.getAttribute(w));
    };
    if (u) {
      n.appendChild(b);
      for (const w of [
        "click",
        "focusout",
        "input",
        "keydown",
        "keyup"
      ]) g(`data-on-${w}`, (v, y) => {
        v.addEventListener(w, r[y]);
      });
      g("data-ref", (w, v) => {
        s[v] = w;
      }), o.addEventListener("abort", () => {
        n.removeChild(b);
      });
    }
    g("data-action", (w, v) => {
      let y = a.get(v);
      y || a.set(v, y = /* @__PURE__ */ new WeakSet()), y.has(w) || (y.add(w), i[v](w));
    });
  }
  const wo = typeof queueMicrotask == "function" ? queueMicrotask : (n) => Promise.resolve().then(n);
  function jT(n) {
    let e = false, t;
    const r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set();
    let s;
    const o = () => {
      if (e) return;
      const l = [
        ...i
      ];
      i.clear();
      try {
        for (const c of l) c();
      } finally {
        s = false, i.size && (s = true, wo(o));
      }
    }, a = new Proxy({}, {
      get(l, c) {
        if (t) {
          let h = r.get(c);
          h || (h = /* @__PURE__ */ new Set(), r.set(c, h)), h.add(t);
        }
        return l[c];
      },
      set(l, c, h) {
        if (l[c] !== h) {
          l[c] = h;
          const d = r.get(c);
          if (d) {
            for (const f of d) i.add(f);
            s || (s = true, wo(o));
          }
        }
        return true;
      }
    }), u = (l) => {
      const c = () => {
        const h = t;
        t = c;
        try {
          return l();
        } finally {
          t = h;
        }
      };
      return c();
    };
    return n.addEventListener("abort", () => {
      e = true;
    }), {
      state: a,
      createEffect: u
    };
  }
  function yu(n, e, t) {
    if (n.length !== e.length) return false;
    for (let r = 0; r < n.length; r++) if (!t(n[r], e[r])) return false;
    return true;
  }
  const nh = /* @__PURE__ */ new WeakMap();
  function qT(n, e, t) {
    {
      const r = n.closest(".tabpanel");
      let i = nh.get(r);
      i || (i = new IntersectionObserver(t, {
        root: r,
        rootMargin: "50% 0px 50% 0px",
        threshold: 0
      }), nh.set(r, i), e.addEventListener("abort", () => {
        i.disconnect();
      })), i.observe(n);
    }
  }
  const vu = [], { assign: Ms } = Object;
  function $T(n, e) {
    const t = {}, r = new AbortController(), i = r.signal, { state: s, createEffect: o } = jT(i), a = /* @__PURE__ */ new Map();
    Ms(s, {
      skinToneEmoji: void 0,
      i18n: void 0,
      database: void 0,
      customEmoji: void 0,
      customCategorySorting: void 0,
      emojiVersion: void 0
    }), Ms(s, e), Ms(s, {
      initialLoad: true,
      currentEmojis: [],
      currentEmojisWithCategories: [],
      rawSearchText: "",
      searchText: "",
      searchMode: false,
      activeSearchItem: -1,
      message: void 0,
      skinTonePickerExpanded: false,
      skinTonePickerExpandedAfterAnimation: false,
      currentSkinTone: 0,
      activeSkinTone: 0,
      skinToneButtonText: void 0,
      pickerStyle: void 0,
      skinToneButtonLabel: "",
      skinTones: [],
      currentFavorites: [],
      defaultFavoriteEmojis: void 0,
      numColumns: uT,
      isRtl: false,
      currentGroupIndex: 0,
      groups: hu,
      databaseLoaded: false,
      activeSearchItemId: void 0
    }), o(() => {
      s.currentGroup !== s.groups[s.currentGroupIndex] && (s.currentGroup = s.groups[s.currentGroupIndex]);
    });
    const u = (_) => {
      n.getElementById(_).focus();
    }, l = (_) => n.getElementById(`emo-${_.id}`), c = (_, W) => {
      t.rootElement.dispatchEvent(new CustomEvent(_, {
        detail: W,
        bubbles: true,
        composed: true
      }));
    }, h = (_, W) => _.id === W.id, d = (_, W) => {
      const { category: P, emojis: q } = _, { category: j, emojis: U } = W;
      return P !== j ? false : yu(q, U, h);
    }, f = (_) => {
      yu(s.currentEmojis, _, h) || (s.currentEmojis = _);
    }, p = (_) => {
      s.searchMode !== _ && (s.searchMode = _);
    }, m = (_) => {
      yu(s.currentEmojisWithCategories, _, d) || (s.currentEmojisWithCategories = _);
    }, b = (_, W) => W && _.skins && _.skins[W] || _.unicode, v = {
      labelWithSkin: (_, W) => TT([
        _.name || b(_, W),
        _.annotation,
        ..._.shortcodes || vu
      ].filter(Boolean)).join(", "),
      titleForEmoji: (_) => _.annotation || (_.shortcodes || vu).join(", "),
      unicodeWithSkin: b
    }, y = {
      onClickSkinToneButton: ue,
      onEmojiClick: K,
      onNavClick: z,
      onNavKeydown: L,
      onSearchKeydown: B,
      onSkinToneOptionsClick: H,
      onSkinToneOptionsFocusOut: Z,
      onSkinToneOptionsKeydown: ne,
      onSkinToneOptionsKeyup: ce,
      onSearchInput: de
    }, x = {
      calculateEmojiGridStyle: M,
      updateOnIntersection: D
    };
    let k = true;
    o(() => {
      zT(n, s, v, y, x, t, i, a, k), k = false;
    }), s.emojiVersion || mu().then((_) => {
      _ || (s.message = s.i18n.emojiUnsupportedMessage);
    }), o(() => {
      async function _() {
        let W = false;
        const P = setTimeout(() => {
          W = true, s.message = s.i18n.loadingMessage;
        }, oT);
        try {
          await s.database.ready(), s.databaseLoaded = true;
        } catch (q) {
          console.error(q), s.message = s.i18n.networkErrorMessage;
        } finally {
          clearTimeout(P), W && (W = false, s.message = "");
        }
      }
      s.database && _();
    }), o(() => {
      s.pickerStyle = `
      --num-groups: ${s.groups.length}; 
      --indicator-opacity: ${s.searchMode ? 0 : 1}; 
      --num-skintones: ${Yf};`;
    }), o(() => {
      s.customEmoji && s.database && T();
    }), o(() => {
      s.customEmoji && s.customEmoji.length ? s.groups !== Qu && (s.groups = Qu) : s.groups !== hu && (s.currentGroupIndex && s.currentGroupIndex--, s.groups = hu);
    }), o(() => {
      async function _() {
        s.databaseLoaded && (s.currentSkinTone = await s.database.getPreferredSkinTone());
      }
      _();
    }), o(() => {
      s.skinTones = Array(Yf).fill().map((_, W) => vT(s.skinToneEmoji, W));
    }), o(() => {
      s.skinToneButtonText = s.skinTones[s.currentSkinTone];
    }), o(() => {
      s.skinToneButtonLabel = s.i18n.skinToneLabel.replace("{skinTone}", s.i18n.skinTones[s.currentSkinTone]);
    }), o(() => {
      async function _() {
        const { database: W } = s, P = (await Promise.all(lT.map((q) => W.getEmojiByUnicodeOrName(q)))).filter(Boolean);
        s.defaultFavoriteEmojis = P;
      }
      s.databaseLoaded && _();
    });
    function T() {
      const { customEmoji: _, database: W } = s, P = _ || vu;
      W.customEmoji !== P && (W.customEmoji = P);
    }
    o(() => {
      async function _() {
        T();
        const { database: W, defaultFavoriteEmojis: P, numColumns: q } = s, j = await W.getTopFavoriteEmoji(q), U = await N(Tm([
          ...j,
          ...P
        ], (ke) => ke.unicode || ke.name).slice(0, q));
        s.currentFavorites = U;
      }
      s.databaseLoaded && s.defaultFavoriteEmojis && _();
    });
    function M(_) {
      kT(_, i, () => {
        {
          const W = getComputedStyle(t.rootElement), P = parseInt(W.getPropertyValue("--num-columns"), 10), q = W.getPropertyValue("direction") === "rtl";
          s.numColumns = P, s.isRtl = q;
        }
      });
    }
    function D(_) {
      qT(_, i, (W) => {
        for (const { target: P, isIntersecting: q } of W) P.classList.toggle("onscreen", q);
      });
    }
    o(() => {
      async function _() {
        const { searchText: W, currentGroup: P, databaseLoaded: q, customEmoji: j } = s;
        if (!q) s.currentEmojis = [], s.searchMode = false;
        else if (W.length >= iT) {
          const U = await R(W);
          s.searchText === W && (f(U), p(true));
        } else {
          const { id: U } = P;
          if (U !== -1 || j && j.length) {
            const ke = await A(U);
            s.currentGroup.id === U && (f(ke), p(false));
          }
        }
      }
      _();
    });
    const I = () => {
      Gs(() => ET(t.tabpanelElement));
    };
    o(() => {
      const { currentEmojis: _, emojiVersion: W } = s, P = _.filter((q) => q.unicode).filter((q) => Xf(q) && !Zu.has(q.unicode));
      if (!W && P.length) f(_), Gs(() => C(P));
      else {
        const q = W ? _ : _.filter(O);
        f(q), I();
      }
    });
    function C(_) {
      ST(_, t.baselineEmoji, l) ? I() : s.currentEmojis = [
        ...s.currentEmojis
      ];
    }
    function O(_) {
      return !_.unicode || !Xf(_) || Zu.get(_.unicode);
    }
    async function E(_) {
      const W = s.emojiVersion || await mu();
      return _.filter(({ version: P }) => !P || P <= W);
    }
    async function N(_) {
      return wT(_, s.emojiVersion || await mu());
    }
    async function A(_) {
      const W = _ === -1 ? s.customEmoji : await s.database.getEmojiByGroup(_);
      return N(await E(W));
    }
    async function R(_) {
      return N(await E(await s.database.getEmojiBySearchQuery(_)));
    }
    o(() => {
    }), o(() => {
      function _() {
        const { searchMode: P, currentEmojis: q } = s;
        if (P) return [
          {
            category: "",
            emojis: q
          }
        ];
        const j = /* @__PURE__ */ new Map();
        for (const U of q) {
          const ke = U.category || "";
          let Ee = j.get(ke);
          Ee || (Ee = [], j.set(ke, Ee)), Ee.push(U);
        }
        return [
          ...j.entries()
        ].map(([U, ke]) => ({
          category: U,
          emojis: ke
        })).sort((U, ke) => s.customCategorySorting(U.category, ke.category));
      }
      const W = _();
      m(W);
    }), o(() => {
      s.activeSearchItemId = s.activeSearchItem !== -1 && s.currentEmojis[s.activeSearchItem].id;
    }), o(() => {
      const { rawSearchText: _ } = s;
      km(() => {
        s.searchText = (_ || "").trim(), s.activeSearchItem = -1;
      });
    });
    function B(_) {
      if (!s.searchMode || !s.currentEmojis.length) return;
      const W = (P) => {
        bn(_), s.activeSearchItem = gu(P, s.activeSearchItem, s.currentEmojis);
      };
      switch (_.key) {
        case "ArrowDown":
          return W(false);
        case "ArrowUp":
          return W(true);
        case "Enter":
          if (s.activeSearchItem === -1) s.activeSearchItem = 0;
          else return bn(_), V(s.currentEmojis[s.activeSearchItem].id);
      }
    }
    function z(_) {
      const { target: W } = _, P = W.closest(".nav-button");
      if (!P) return;
      const q = parseInt(P.dataset.groupId, 10);
      t.searchElement.value = "", s.rawSearchText = "", s.searchText = "", s.activeSearchItem = -1, s.currentGroupIndex = s.groups.findIndex((j) => j.id === q);
    }
    function L(_) {
      const { target: W, key: P } = _, q = (j) => {
        j && (bn(_), j.focus());
      };
      switch (P) {
        case "ArrowLeft":
          return q(W.previousElementSibling);
        case "ArrowRight":
          return q(W.nextElementSibling);
        case "Home":
          return q(W.parentElement.firstElementChild);
        case "End":
          return q(W.parentElement.lastElementChild);
      }
    }
    async function V(_) {
      const W = await s.database.getEmojiByUnicodeOrName(_), P = [
        ...s.currentEmojis,
        ...s.currentFavorites
      ].find((j) => j.id === _), q = P.unicode && b(P, s.currentSkinTone);
      await s.database.incrementFavoriteEmojiCount(_), c("emoji-click", {
        emoji: W,
        skinTone: s.currentSkinTone,
        ...q && {
          unicode: q
        },
        ...P.name && {
          name: P.name
        }
      });
    }
    async function K(_) {
      const { target: W } = _;
      if (!W.classList.contains("emoji")) return;
      bn(_);
      const P = W.id.substring(4);
      V(P);
    }
    function pe(_) {
      s.currentSkinTone = _, s.skinTonePickerExpanded = false, u("skintone-button"), c("skin-tone-change", {
        skinTone: _
      }), s.database.setPreferredSkinTone(_);
    }
    function H(_) {
      const { target: { id: W } } = _, P = W && W.match(/^skintone-(\d)/);
      if (!P) return;
      bn(_);
      const q = parseInt(P[1], 10);
      pe(q);
    }
    function ue(_) {
      s.skinTonePickerExpanded = !s.skinTonePickerExpanded, s.activeSkinTone = s.currentSkinTone, s.skinTonePickerExpanded && (bn(_), Gs(() => u("skintone-list")));
    }
    o(() => {
      s.skinTonePickerExpanded ? t.skinToneDropdown.addEventListener("transitionend", () => {
        s.skinTonePickerExpandedAfterAnimation = true;
      }, {
        once: true
      }) : s.skinTonePickerExpandedAfterAnimation = false;
    });
    function ne(_) {
      if (!s.skinTonePickerExpanded) return;
      const W = async (P) => {
        bn(_), s.activeSkinTone = P;
      };
      switch (_.key) {
        case "ArrowUp":
          return W(gu(true, s.activeSkinTone, s.skinTones));
        case "ArrowDown":
          return W(gu(false, s.activeSkinTone, s.skinTones));
        case "Home":
          return W(0);
        case "End":
          return W(s.skinTones.length - 1);
        case "Enter":
          return bn(_), pe(s.activeSkinTone);
        case "Escape":
          return bn(_), s.skinTonePickerExpanded = false, u("skintone-button");
      }
    }
    function ce(_) {
      if (s.skinTonePickerExpanded) switch (_.key) {
        case " ":
          return bn(_), pe(s.activeSkinTone);
      }
    }
    async function Z(_) {
      const { relatedTarget: W } = _;
      (!W || W.id !== "skintone-list") && (s.skinTonePickerExpanded = false);
    }
    function de(_) {
      s.rawSearchText = _.target.value;
    }
    return {
      $set(_) {
        Ms(s, _);
      },
      $destroy() {
        r.abort();
      }
    };
  }
  const VT = "https://cdn.jsdelivr.net/npm/emoji-picker-element-data@^1/en/emojibase/data.json", HT = "en";
  var WT = {
    categoriesLabel: "Categories",
    emojiUnsupportedMessage: "Your browser does not support color emoji.",
    favoritesLabel: "Favorites",
    loadingMessage: "Loading\u2026",
    networkErrorMessage: "Could not load emoji.",
    regionLabel: "Emoji picker",
    searchDescription: "When search results are available, press up or down to select and enter to choose.",
    searchLabel: "Search",
    searchResultsLabel: "Search results",
    skinToneDescription: "When expanded, press up or down to select and enter to choose.",
    skinToneLabel: "Choose a skin tone (currently {skinTone})",
    skinTonesLabel: "Skin tones",
    skinTones: [
      "Default",
      "Light",
      "Medium-Light",
      "Medium",
      "Medium-Dark",
      "Dark"
    ],
    categories: {
      custom: "Custom",
      "smileys-emotion": "Smileys and emoticons",
      "people-body": "People and body",
      "animals-nature": "Animals and nature",
      "food-drink": "Food and drink",
      "travel-places": "Travel and places",
      activities: "Activities",
      objects: "Objects",
      symbols: "Symbols",
      flags: "Flags"
    }
  }, UT = ':host{--emoji-size:1.375rem;--emoji-padding:0.5rem;--category-emoji-size:var(--emoji-size);--category-emoji-padding:var(--emoji-padding);--indicator-height:3px;--input-border-radius:0.5rem;--input-border-size:1px;--input-font-size:1rem;--input-line-height:1.5;--input-padding:0.25rem;--num-columns:8;--outline-size:2px;--border-size:1px;--border-radius:0;--skintone-border-radius:1rem;--category-font-size:1rem;display:flex;width:min-content;height:400px}:host,:host(.light){color-scheme:light;--background:#fff;--border-color:#e0e0e0;--indicator-color:#385ac1;--input-border-color:#999;--input-font-color:#111;--input-placeholder-color:#999;--outline-color:#999;--category-font-color:#111;--button-active-background:#e6e6e6;--button-hover-background:#d9d9d9}:host(.dark){color-scheme:dark;--background:#222;--border-color:#444;--indicator-color:#5373ec;--input-border-color:#ccc;--input-font-color:#efefef;--input-placeholder-color:#ccc;--outline-color:#fff;--category-font-color:#efefef;--button-active-background:#555555;--button-hover-background:#484848}@media (prefers-color-scheme:dark){:host{color-scheme:dark;--background:#222;--border-color:#444;--indicator-color:#5373ec;--input-border-color:#ccc;--input-font-color:#efefef;--input-placeholder-color:#ccc;--outline-color:#fff;--category-font-color:#efefef;--button-active-background:#555555;--button-hover-background:#484848}}:host([hidden]){display:none}button{margin:0;padding:0;border:0;background:0 0;box-shadow:none;-webkit-tap-highlight-color:transparent}button::-moz-focus-inner{border:0}input{padding:0;margin:0;line-height:1.15;font-family:inherit}input[type=search]{-webkit-appearance:none}:focus{outline:var(--outline-color) solid var(--outline-size);outline-offset:calc(-1*var(--outline-size))}:host([data-js-focus-visible]) :focus:not([data-focus-visible-added]){outline:0}:focus:not(:focus-visible){outline:0}.hide-focus{outline:0}*{box-sizing:border-box}.picker{contain:content;display:flex;flex-direction:column;background:var(--background);border:var(--border-size) solid var(--border-color);border-radius:var(--border-radius);width:100%;height:100%;overflow:hidden;--total-emoji-size:calc(var(--emoji-size) + (2 * var(--emoji-padding)));--total-category-emoji-size:calc(var(--category-emoji-size) + (2 * var(--category-emoji-padding)))}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.hidden{opacity:0;pointer-events:none}.abs-pos{position:absolute;left:0;top:0}.gone{display:none!important}.skintone-button-wrapper,.skintone-list{background:var(--background);z-index:3}.skintone-button-wrapper.expanded{z-index:1}.skintone-list{position:absolute;inset-inline-end:0;top:0;z-index:2;overflow:visible;border-bottom:var(--border-size) solid var(--border-color);border-radius:0 0 var(--skintone-border-radius) var(--skintone-border-radius);will-change:transform;transition:transform .2s ease-in-out;transform-origin:center 0}@media (prefers-reduced-motion:reduce){.skintone-list{transition-duration:.001s}}@supports not (inset-inline-end:0){.skintone-list{right:0}}.skintone-list.no-animate{transition:none}.tabpanel{overflow-y:auto;scrollbar-gutter:stable;-webkit-overflow-scrolling:touch;will-change:transform;min-height:0;flex:1;contain:content}.emoji-menu{display:grid;grid-template-columns:repeat(var(--num-columns),var(--total-emoji-size));justify-content:space-around;align-items:flex-start;width:100%}.emoji-menu.visibility-auto{content-visibility:auto;contain-intrinsic-size:calc(var(--num-columns)*var(--total-emoji-size)) calc(var(--num-rows)*var(--total-emoji-size))}.category{padding:var(--emoji-padding);font-size:var(--category-font-size);color:var(--category-font-color)}.emoji,button.emoji{font-size:var(--emoji-size);display:flex;align-items:center;justify-content:center;border-radius:100%;height:var(--total-emoji-size);width:var(--total-emoji-size);line-height:1;overflow:hidden;font-family:var(--emoji-font-family);cursor:pointer}@media (hover:hover) and (pointer:fine){.emoji:hover,button.emoji:hover{background:var(--button-hover-background)}}.emoji.active,.emoji:active,button.emoji.active,button.emoji:active{background:var(--button-active-background)}.onscreen .custom-emoji::after{content:"";width:var(--emoji-size);height:var(--emoji-size);background-repeat:no-repeat;background-position:center center;background-size:contain;background-image:var(--custom-emoji-background)}.nav,.nav-button{align-items:center}.nav{display:grid;justify-content:space-between;contain:content}.nav-button{display:flex;justify-content:center}.nav-emoji{font-size:var(--category-emoji-size);width:var(--total-category-emoji-size);height:var(--total-category-emoji-size)}.indicator-wrapper{display:flex;border-bottom:1px solid var(--border-color)}.indicator{width:calc(100%/var(--num-groups));height:var(--indicator-height);opacity:var(--indicator-opacity);background-color:var(--indicator-color);will-change:transform,opacity;transition:opacity .1s linear,transform .25s ease-in-out}@media (prefers-reduced-motion:reduce){.indicator{will-change:opacity;transition:opacity .1s linear}}.pad-top,input.search{background:var(--background);width:100%}.pad-top{height:var(--emoji-padding);z-index:3}.search-row{display:flex;align-items:center;position:relative;padding-inline-start:var(--emoji-padding);padding-bottom:var(--emoji-padding)}.search-wrapper{flex:1;min-width:0}input.search{padding:var(--input-padding);border-radius:var(--input-border-radius);border:var(--input-border-size) solid var(--input-border-color);color:var(--input-font-color);font-size:var(--input-font-size);line-height:var(--input-line-height)}input.search::placeholder{color:var(--input-placeholder-color)}.favorites{overflow-y:auto;scrollbar-gutter:stable;display:flex;flex-direction:row;border-top:var(--border-size) solid var(--border-color);contain:content}.message{padding:var(--emoji-padding)}';
  const Em = [
    "customEmoji",
    "customCategorySorting",
    "database",
    "dataSource",
    "i18n",
    "locale",
    "skinToneEmoji",
    "emojiVersion"
  ], GT = `:host{--emoji-font-family:${Sm}}`;
  class Cm extends HTMLElement {
    constructor(e) {
      super(), this.attachShadow({
        mode: "open"
      });
      const t = document.createElement("style");
      t.textContent = UT + GT, this.shadowRoot.appendChild(t), this._ctx = {
        locale: HT,
        dataSource: VT,
        skinToneEmoji: aT,
        customCategorySorting: cT,
        customEmoji: null,
        i18n: WT,
        emojiVersion: null,
        ...e
      };
      for (const r of Em) r !== "database" && Object.prototype.hasOwnProperty.call(this, r) && (this._ctx[r] = this[r], delete this[r]);
      this._dbFlush();
    }
    connectedCallback() {
      this._cmp || (this._cmp = $T(this.shadowRoot, this._ctx));
    }
    disconnectedCallback() {
      wo(() => {
        if (!this.isConnected && this._cmp) {
          this._cmp.$destroy(), this._cmp = void 0;
          const { database: e } = this._ctx;
          e.close().catch((t) => console.error(t));
        }
      });
    }
    static get observedAttributes() {
      return [
        "locale",
        "data-source",
        "skin-tone-emoji",
        "emoji-version"
      ];
    }
    attributeChangedCallback(e, t, r) {
      this._set(e.replace(/-([a-z])/g, (i, s) => s.toUpperCase()), e === "emoji-version" ? parseFloat(r) : r);
    }
    _set(e, t) {
      this._ctx[e] = t, this._cmp && this._cmp.$set({
        [e]: t
      }), [
        "locale",
        "dataSource"
      ].includes(e) && this._dbFlush();
    }
    _dbCreate() {
      const { locale: e, dataSource: t, database: r } = this._ctx;
      (!r || r.locale !== e || r.dataSource !== t) && this._set("database", new rT({
        locale: e,
        dataSource: t
      }));
    }
    _dbFlush() {
      wo(() => this._dbCreate());
    }
  }
  const Om = {};
  for (const n of Em) Om[n] = {
    get() {
      return n === "database" && this._dbCreate(), this._ctx[n];
    },
    set(e) {
      if (n === "database") throw new Error("database is read-only");
      this._set(n, e);
    }
  };
  Object.defineProperties(Cm.prototype, Om);
  customElements.get("emoji-picker") || customElements.define("emoji-picker", Cm);
  function KT(n) {
    return n[n.length - 1];
  }
  function el(n) {
    return Object.keys(n).reduce((e, t) => n[t] === void 0 ? e : e + `${t}:${n[t]};`, "");
  }
  el({
    position: "absolute",
    opacity: 0,
    "pointer-events": "none",
    margin: 0,
    transform: "translateX(-100%)"
  });
  function JT(n) {
    if (n !== null) return "";
  }
  function rh(n) {
    function e(t) {
      return t(n), () => {
      };
    }
    return {
      subscribe: e
    };
  }
  const Ns = (n) => new Proxy(n, {
    get(e, t, r) {
      return Reflect.get(e, t, r);
    },
    ownKeys(e) {
      return Reflect.ownKeys(e).filter((t) => t !== "action");
    }
  }), ih = (n) => typeof n == "function";
  Jn("empty");
  function Jn(n, e) {
    const { stores: t, action: r, returned: i } = e ?? {}, s = (() => {
      if (t && i) return an(t, (a) => {
        const u = i(a);
        if (ih(u)) {
          const l = (...c) => Ns({
            ...u(...c),
            [`data-melt-${n}`]: "",
            action: r ?? ht
          });
          return l.action = r ?? ht, l;
        }
        return Ns({
          ...u,
          [`data-melt-${n}`]: "",
          action: r ?? ht
        });
      });
      {
        const u = i?.();
        if (ih(u)) {
          const l = (...c) => Ns({
            ...u(...c),
            [`data-melt-${n}`]: "",
            action: r ?? ht
          });
          return l.action = r ?? ht, rh(l);
        }
        return rh(Ns({
          ...u,
          [`data-melt-${n}`]: "",
          action: r ?? ht
        }));
      }
    })(), o = r ?? (() => {
    });
    return o.subscribe = s.subscribe, o;
  }
  function YT(n) {
    const e = (s) => s ? `${n}-${s}` : n, t = (s) => `data-melt-${n}${s ? `-${s}` : ""}`, r = (s) => `[data-melt-${n}${s ? `-${s}` : ""}]`;
    return {
      name: e,
      attribute: t,
      selector: r,
      getEl: (s) => document.querySelector(r(s))
    };
  }
  const XT = typeof document < "u", Am = (n) => typeof n == "function";
  function ec(n) {
    return n instanceof Element;
  }
  function fr(n) {
    return n instanceof HTMLElement;
  }
  function QT(n) {
    return n !== null && typeof n == "object";
  }
  function ZT(n) {
    return QT(n) && "subscribe" in n;
  }
  function ii(...n) {
    return (...e) => {
      for (const t of n) typeof t == "function" && t(...e);
    };
  }
  function ht() {
  }
  function Bn(n, e, t, r) {
    const i = Array.isArray(e) ? e : [
      e
    ];
    return i.forEach((s) => n.addEventListener(s, t, r)), () => {
      i.forEach((s) => n.removeEventListener(s, t, r));
    };
  }
  function Ps(n, e, t, r) {
    const i = Array.isArray(e) ? e : [
      e
    ];
    if (typeof t == "function") {
      const s = t6((o) => t(o));
      return i.forEach((o) => n.addEventListener(o, s, r)), () => {
        i.forEach((o) => n.removeEventListener(o, s, r));
      };
    }
    return () => void 0;
  }
  function e6(n) {
    const e = n.currentTarget;
    if (!fr(e)) return null;
    const t = new CustomEvent(`m-${n.type}`, {
      detail: {
        originalEvent: n
      },
      cancelable: true
    });
    return e.dispatchEvent(t), t;
  }
  function t6(n) {
    return (e) => {
      if (!e6(e)?.defaultPrevented) return n(e);
    };
  }
  const n6 = (n) => {
    try {
      Xi(n);
    } catch {
      return n;
    }
  };
  function Mm(n, ...e) {
    const t = {};
    for (const r of Object.keys(n)) e.includes(r) || (t[r] = n[r]);
    return t;
  }
  function as(n) {
    return {
      ...n,
      get: () => Q(n)
    };
  }
  as.writable = function(n) {
    const e = bt(n);
    let t = n;
    return {
      subscribe: e.subscribe,
      set(r) {
        e.set(r), t = r;
      },
      update(r) {
        const i = r(t);
        e.set(i), t = i;
      },
      get() {
        return t;
      }
    };
  };
  as.derived = function(n, e) {
    const t = /* @__PURE__ */ new Map(), r = () => {
      const s = Array.isArray(n) ? n.map((o) => o.get()) : n.get();
      return e(s);
    };
    return {
      get: r,
      subscribe: (s) => {
        const o = [];
        return (Array.isArray(n) ? n : [
          n
        ]).forEach((u) => {
          o.push(u.subscribe(() => {
            s(r());
          }));
        }), s(r()), t.set(s, o), () => {
          const u = t.get(s);
          if (u) for (const l of u) l();
          t.delete(s);
        };
      }
    };
  };
  const r6 = (n, e) => {
    const t = as(n), r = (s, o) => {
      t.update((a) => {
        const u = s(a);
        let l = u;
        return e && (l = e({
          curr: a,
          next: u
        })), o?.(l), l;
      });
    };
    return {
      ...t,
      update: r,
      set: (s) => {
        r(() => s);
      }
    };
  };
  function Nm(n) {
    return new Promise((e) => setTimeout(e, n));
  }
  let i6 = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", s6 = (n = 21) => {
    let e = "", t = n | 0;
    for (; t--; ) e += i6[Math.random() * 64 | 0];
    return e;
  };
  function o6() {
    return s6(10);
  }
  function a6(n) {
    return n.reduce((e, t) => (e[t] = o6(), e), {});
  }
  const Ii = {
    ENTER: "Enter",
    ESCAPE: "Escape",
    SPACE: " "
  }, Pm = () => typeof window < "u";
  function u6() {
    return navigator.userAgentData?.platform ?? navigator.platform;
  }
  const Dm = (n) => Pm() && n.test(u6().toLowerCase()), l6 = () => Pm() && !!navigator.maxTouchPoints, c6 = () => Dm(/^mac/) && !l6(), d6 = () => Dm(/mac|iphone|ipad|ipod/i), f6 = () => d6() && !c6(), wu = "data-melt-scroll-lock";
  function sh(n, e) {
    if (!n) return;
    const t = n.style.cssText;
    return Object.assign(n.style, e), () => {
      n.style.cssText = t;
    };
  }
  function h6(n, e, t) {
    if (!n) return;
    const r = n.style.getPropertyValue(e);
    return n.style.setProperty(e, t), () => {
      r ? n.style.setProperty(e, r) : n.style.removeProperty(e);
    };
  }
  function p6(n) {
    const e = n.getBoundingClientRect().left;
    return Math.round(e) + n.scrollLeft ? "paddingLeft" : "paddingRight";
  }
  function m6(n) {
    const e = document, t = e.defaultView ?? window, { documentElement: r, body: i } = e;
    if (i.hasAttribute(wu)) return ht;
    i.setAttribute(wu, "");
    const o = t.innerWidth - r.clientWidth, a = () => h6(r, "--scrollbar-width", `${o}px`), u = p6(r), l = t.getComputedStyle(i)[u], c = () => sh(i, {
      overflow: "hidden",
      [u]: `calc(${l} + ${o}px)`
    }), h = () => {
      const { scrollX: f, scrollY: p, visualViewport: m } = t, b = m?.offsetLeft ?? 0, g = m?.offsetTop ?? 0, w = sh(i, {
        position: "fixed",
        overflow: "hidden",
        top: `${-(p - Math.floor(g))}px`,
        left: `${-(f - Math.floor(b))}px`,
        right: "0",
        [u]: `calc(${l} + ${o}px)`
      });
      return () => {
        w?.(), t.scrollTo(f, p);
      };
    }, d = [
      a(),
      f6() ? h() : c()
    ];
    return () => {
      d.forEach((f) => f?.()), i.removeAttribute(wu);
    };
  }
  function kr(n, e) {
    let t;
    const r = an(n, (s) => {
      t?.(), t = e(s);
    }).subscribe(ht), i = () => {
      r(), t?.();
    };
    return n6(i), i;
  }
  function oh(n) {
    const e = {};
    return Object.keys(n).forEach((t) => {
      const r = t, i = n[r];
      e[r] = as(bt(i));
    }), e;
  }
  function g6(n) {
    let e = n.parentElement;
    for (; fr(e) && !e.hasAttribute("data-portal"); ) e = e.parentElement;
    return e || "body";
  }
  function b6(n, e) {
    return e !== void 0 ? e : g6(n) === "body" ? document.body : null;
  }
  async function ah(n) {
    const { prop: e, defaultEl: t } = n;
    if (await Promise.all([
      Nm(1),
      Co
    ]), e === void 0) {
      t?.focus();
      return;
    }
    const r = Am(e) ? e(t) : e;
    if (typeof r == "string") {
      const i = document.querySelector(r);
      if (!fr(i)) return;
      i.focus();
    } else fr(r) && r.focus();
  }
  Nr(void 0, (n) => {
    function e(r) {
      n(r), n(void 0);
    }
    return Bn(document, "pointerup", e, {
      passive: false,
      capture: true
    });
  });
  const y6 = Nr(void 0, (n) => {
    function e(r) {
      r && r.key === Ii.ESCAPE && n(r), n(void 0);
    }
    return Bn(document, "keydown", e, {
      passive: false
    });
  }), uh = (n, e = {}) => {
    let t = ht;
    function r(i = {}) {
      t();
      const s = {
        enabled: true,
        ...i
      }, o = ZT(s.enabled) ? s.enabled : Nr(s.enabled);
      t = ii(y6.subscribe((a) => {
        if (!a || !Q(o)) return;
        const u = a.target;
        if (!(!fr(u) || u.closest("[data-escapee]") !== n)) {
          if (a.preventDefault(), s.ignore) {
            if (Am(s.ignore)) {
              if (s.ignore(a)) return;
            } else if (Array.isArray(s.ignore) && s.ignore.length > 0 && s.ignore.some((l) => l && u === l)) return;
          }
          s.handler?.(a);
        }
      }), kr(o, (a) => {
        a ? n.dataset.escapee = "" : delete n.dataset.escapee;
      }));
    }
    return r(e), {
      update: r,
      destroy() {
        n.removeAttribute("data-escapee"), t();
      }
    };
  };
  function tl(n, e) {
    (e == null || e > n.length) && (e = n.length);
    for (var t = 0, r = Array(e); t < e; t++) r[t] = n[t];
    return r;
  }
  function v6(n) {
    if (Array.isArray(n)) return tl(n);
  }
  function w6(n, e, t) {
    return (e = E6(e)) in n ? Object.defineProperty(n, e, {
      value: t,
      enumerable: true,
      configurable: true,
      writable: true
    }) : n[e] = t, n;
  }
  function x6(n) {
    if (typeof Symbol < "u" && n[Symbol.iterator] != null || n["@@iterator"] != null) return Array.from(n);
  }
  function k6() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function lh(n, e) {
    var t = Object.keys(n);
    if (Object.getOwnPropertySymbols) {
      var r = Object.getOwnPropertySymbols(n);
      e && (r = r.filter(function(i) {
        return Object.getOwnPropertyDescriptor(n, i).enumerable;
      })), t.push.apply(t, r);
    }
    return t;
  }
  function ch(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e] != null ? arguments[e] : {};
      e % 2 ? lh(Object(t), true).forEach(function(r) {
        w6(n, r, t[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : lh(Object(t)).forEach(function(r) {
        Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
      });
    }
    return n;
  }
  function S6(n) {
    return v6(n) || x6(n) || C6(n) || k6();
  }
  function T6(n, e) {
    if (typeof n != "object" || !n) return n;
    var t = n[Symbol.toPrimitive];
    if (t !== void 0) {
      var r = t.call(n, e);
      if (typeof r != "object") return r;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (e === "string" ? String : Number)(n);
  }
  function E6(n) {
    var e = T6(n, "string");
    return typeof e == "symbol" ? e : e + "";
  }
  function C6(n, e) {
    if (n) {
      if (typeof n == "string") return tl(n, e);
      var t = {}.toString.call(n).slice(8, -1);
      return t === "Object" && n.constructor && (t = n.constructor.name), t === "Map" || t === "Set" ? Array.from(n) : t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? tl(n, e) : void 0;
    }
  }
  var dh = {
    activateTrap: function(e, t) {
      if (e.length > 0) {
        var r = e[e.length - 1];
        r !== t && r._setPausedState(true);
      }
      var i = e.indexOf(t);
      i === -1 || e.splice(i, 1), e.push(t);
    },
    deactivateTrap: function(e, t) {
      var r = e.indexOf(t);
      r !== -1 && e.splice(r, 1), e.length > 0 && !e[e.length - 1]._isManuallyPaused() && e[e.length - 1]._setPausedState(false);
    }
  }, O6 = function(e) {
    return e.tagName && e.tagName.toLowerCase() === "input" && typeof e.select == "function";
  }, A6 = function(e) {
    return e?.key === "Escape" || e?.key === "Esc" || e?.keyCode === 27;
  }, zi = function(e) {
    return e?.key === "Tab" || e?.keyCode === 9;
  }, M6 = function(e) {
    return zi(e) && !e.shiftKey;
  }, N6 = function(e) {
    return zi(e) && e.shiftKey;
  }, fh = function(e) {
    return setTimeout(e, 0);
  }, Ai = function(e) {
    for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) r[i - 1] = arguments[i];
    return typeof e == "function" ? e.apply(void 0, r) : e;
  }, Ds = function(e) {
    return e.target.shadowRoot && typeof e.composedPath == "function" ? e.composedPath()[0] : e.target;
  }, P6 = [], D6 = function(e, t) {
    var r = t?.document || document, i = t?.trapStack || P6, s = ch({
      returnFocusOnDeactivate: true,
      escapeDeactivates: true,
      delayInitialFocus: true,
      isKeyForward: M6,
      isKeyBackward: N6
    }, t), o = {
      containers: [],
      containerGroups: [],
      tabbableGroups: [],
      nodeFocusedBeforeActivation: null,
      mostRecentlyFocusedNode: null,
      active: false,
      paused: false,
      manuallyPaused: false,
      delayInitialFocusTimer: void 0,
      recentNavEvent: void 0
    }, a, u = function(E, N, A) {
      return E && E[N] !== void 0 ? E[N] : s[A || N];
    }, l = function(E, N) {
      var A = typeof N?.composedPath == "function" ? N.composedPath() : void 0;
      return o.containerGroups.findIndex(function(R) {
        var B = R.container, z = R.tabbableNodes;
        return B.contains(E) || A?.includes(B) || z.find(function(L) {
          return L === E;
        });
      });
    }, c = function(E) {
      var N = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, A = N.hasFallback, R = A === void 0 ? false : A, B = N.params, z = B === void 0 ? [] : B, L = s[E];
      if (typeof L == "function" && (L = L.apply(void 0, S6(z))), L === true && (L = void 0), !L) {
        if (L === void 0 || L === false) return L;
        throw new Error("`".concat(E, "` was specified but was not a node, or did not return a node"));
      }
      var V = L;
      if (typeof L == "string") {
        try {
          V = r.querySelector(L);
        } catch (K) {
          throw new Error("`".concat(E, '` appears to be an invalid selector; error="').concat(K.message, '"'));
        }
        if (!V && !R) throw new Error("`".concat(E, "` as selector refers to no known node"));
      }
      return V;
    }, h = function() {
      var E = c("initialFocus", {
        hasFallback: true
      });
      if (E === false) return false;
      if (E === void 0 || E && !ra(E, s.tabbableOptions)) if (l(r.activeElement) >= 0) E = r.activeElement;
      else {
        var N = o.tabbableGroups[0], A = N && N.firstTabbableNode;
        E = A || c("fallbackFocus");
      }
      else E === null && (E = c("fallbackFocus"));
      if (!E) throw new Error("Your focus-trap needs to have at least one focusable element");
      return E;
    }, d = function() {
      if (o.containerGroups = o.containers.map(function(E) {
        var N = ag(E, s.tabbableOptions), A = ug(E, s.tabbableOptions), R = N.length > 0 ? N[0] : void 0, B = N.length > 0 ? N[N.length - 1] : void 0, z = A.find(function(K) {
          return Gr(K);
        }), L = A.slice().reverse().find(function(K) {
          return Gr(K);
        }), V = !!N.find(function(K) {
          return vi(K) > 0;
        });
        return {
          container: E,
          tabbableNodes: N,
          focusableNodes: A,
          posTabIndexesFound: V,
          firstTabbableNode: R,
          lastTabbableNode: B,
          firstDomTabbableNode: z,
          lastDomTabbableNode: L,
          nextTabbableNode: function(pe) {
            var H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, ue = N.indexOf(pe);
            return ue < 0 ? H ? A.slice(A.indexOf(pe) + 1).find(function(ne) {
              return Gr(ne);
            }) : A.slice(0, A.indexOf(pe)).reverse().find(function(ne) {
              return Gr(ne);
            }) : N[ue + (H ? 1 : -1)];
          }
        };
      }), o.tabbableGroups = o.containerGroups.filter(function(E) {
        return E.tabbableNodes.length > 0;
      }), o.tabbableGroups.length <= 0 && !c("fallbackFocus")) throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
      if (o.containerGroups.find(function(E) {
        return E.posTabIndexesFound;
      }) && o.containerGroups.length > 1) throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
    }, f = function(E) {
      var N = E.activeElement;
      if (N) return N.shadowRoot && N.shadowRoot.activeElement !== null ? f(N.shadowRoot) : N;
    }, p = function(E) {
      if (E !== false && E !== f(document)) {
        if (!E || !E.focus) {
          p(h());
          return;
        }
        E.focus({
          preventScroll: !!s.preventScroll
        }), o.mostRecentlyFocusedNode = E, O6(E) && E.select();
      }
    }, m = function(E) {
      var N = c("setReturnFocus", {
        params: [
          E
        ]
      });
      return N || (N === false ? false : E);
    }, b = function(E) {
      var N = E.target, A = E.event, R = E.isBackward, B = R === void 0 ? false : R;
      N = N || Ds(A), d();
      var z = null;
      if (o.tabbableGroups.length > 0) {
        var L = l(N, A), V = L >= 0 ? o.containerGroups[L] : void 0;
        if (L < 0) B ? z = o.tabbableGroups[o.tabbableGroups.length - 1].lastTabbableNode : z = o.tabbableGroups[0].firstTabbableNode;
        else if (B) {
          var K = o.tabbableGroups.findIndex(function(Z) {
            var de = Z.firstTabbableNode;
            return N === de;
          });
          if (K < 0 && (V.container === N || ra(N, s.tabbableOptions) && !Gr(N, s.tabbableOptions) && !V.nextTabbableNode(N, false)) && (K = L), K >= 0) {
            var pe = K === 0 ? o.tabbableGroups.length - 1 : K - 1, H = o.tabbableGroups[pe];
            z = vi(N) >= 0 ? H.lastTabbableNode : H.lastDomTabbableNode;
          } else zi(A) || (z = V.nextTabbableNode(N, false));
        } else {
          var ue = o.tabbableGroups.findIndex(function(Z) {
            var de = Z.lastTabbableNode;
            return N === de;
          });
          if (ue < 0 && (V.container === N || ra(N, s.tabbableOptions) && !Gr(N, s.tabbableOptions) && !V.nextTabbableNode(N)) && (ue = L), ue >= 0) {
            var ne = ue === o.tabbableGroups.length - 1 ? 0 : ue + 1, ce = o.tabbableGroups[ne];
            z = vi(N) >= 0 ? ce.firstTabbableNode : ce.firstDomTabbableNode;
          } else zi(A) || (z = V.nextTabbableNode(N));
        }
      } else z = c("fallbackFocus");
      return z;
    }, g = function(E) {
      var N = Ds(E);
      if (!(l(N, E) >= 0)) {
        if (Ai(s.clickOutsideDeactivates, E)) {
          a.deactivate({
            returnFocus: s.returnFocusOnDeactivate
          });
          return;
        }
        Ai(s.allowOutsideClick, E) || E.preventDefault();
      }
    }, w = function(E) {
      var N = Ds(E), A = l(N, E) >= 0;
      if (A || N instanceof Document) A && (o.mostRecentlyFocusedNode = N);
      else {
        E.stopImmediatePropagation();
        var R, B = true;
        if (o.mostRecentlyFocusedNode) if (vi(o.mostRecentlyFocusedNode) > 0) {
          var z = l(o.mostRecentlyFocusedNode), L = o.containerGroups[z].tabbableNodes;
          if (L.length > 0) {
            var V = L.findIndex(function(K) {
              return K === o.mostRecentlyFocusedNode;
            });
            V >= 0 && (s.isKeyForward(o.recentNavEvent) ? V + 1 < L.length && (R = L[V + 1], B = false) : V - 1 >= 0 && (R = L[V - 1], B = false));
          }
        } else o.containerGroups.some(function(K) {
          return K.tabbableNodes.some(function(pe) {
            return vi(pe) > 0;
          });
        }) || (B = false);
        else B = false;
        B && (R = b({
          target: o.mostRecentlyFocusedNode,
          isBackward: s.isKeyBackward(o.recentNavEvent)
        })), p(R || o.mostRecentlyFocusedNode || h());
      }
      o.recentNavEvent = void 0;
    }, v = function(E) {
      var N = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      o.recentNavEvent = E;
      var A = b({
        event: E,
        isBackward: N
      });
      A && (zi(E) && E.preventDefault(), p(A));
    }, y = function(E) {
      (s.isKeyForward(E) || s.isKeyBackward(E)) && v(E, s.isKeyBackward(E));
    }, x = function(E) {
      A6(E) && Ai(s.escapeDeactivates, E) !== false && (E.preventDefault(), a.deactivate());
    }, k = function(E) {
      var N = Ds(E);
      l(N, E) >= 0 || Ai(s.clickOutsideDeactivates, E) || Ai(s.allowOutsideClick, E) || (E.preventDefault(), E.stopImmediatePropagation());
    }, T = function() {
      if (o.active) return dh.activateTrap(i, a), o.delayInitialFocusTimer = s.delayInitialFocus ? fh(function() {
        p(h());
      }) : p(h()), r.addEventListener("focusin", w, true), r.addEventListener("mousedown", g, {
        capture: true,
        passive: false
      }), r.addEventListener("touchstart", g, {
        capture: true,
        passive: false
      }), r.addEventListener("click", k, {
        capture: true,
        passive: false
      }), r.addEventListener("keydown", y, {
        capture: true,
        passive: false
      }), r.addEventListener("keydown", x), a;
    }, M = function() {
      if (o.active) return r.removeEventListener("focusin", w, true), r.removeEventListener("mousedown", g, true), r.removeEventListener("touchstart", g, true), r.removeEventListener("click", k, true), r.removeEventListener("keydown", y, true), r.removeEventListener("keydown", x), a;
    }, D = function(E) {
      var N = E.some(function(A) {
        var R = Array.from(A.removedNodes);
        return R.some(function(B) {
          return B === o.mostRecentlyFocusedNode;
        });
      });
      N && p(h());
    }, I = typeof window < "u" && "MutationObserver" in window ? new MutationObserver(D) : void 0, C = function() {
      I && (I.disconnect(), o.active && !o.paused && o.containers.map(function(E) {
        I.observe(E, {
          subtree: true,
          childList: true
        });
      }));
    };
    return a = {
      get active() {
        return o.active;
      },
      get paused() {
        return o.paused;
      },
      activate: function(E) {
        if (o.active) return this;
        var N = u(E, "onActivate"), A = u(E, "onPostActivate"), R = u(E, "checkCanFocusTrap");
        R || d(), o.active = true, o.paused = false, o.nodeFocusedBeforeActivation = r.activeElement, N?.();
        var B = function() {
          R && d(), T(), C(), A?.();
        };
        return R ? (R(o.containers.concat()).then(B, B), this) : (B(), this);
      },
      deactivate: function(E) {
        if (!o.active) return this;
        var N = ch({
          onDeactivate: s.onDeactivate,
          onPostDeactivate: s.onPostDeactivate,
          checkCanReturnFocus: s.checkCanReturnFocus
        }, E);
        clearTimeout(o.delayInitialFocusTimer), o.delayInitialFocusTimer = void 0, M(), o.active = false, o.paused = false, C(), dh.deactivateTrap(i, a);
        var A = u(N, "onDeactivate"), R = u(N, "onPostDeactivate"), B = u(N, "checkCanReturnFocus"), z = u(N, "returnFocus", "returnFocusOnDeactivate");
        A?.();
        var L = function() {
          fh(function() {
            z && p(m(o.nodeFocusedBeforeActivation)), R?.();
          });
        };
        return z && B ? (B(m(o.nodeFocusedBeforeActivation)).then(L, L), this) : (L(), this);
      },
      pause: function(E) {
        return o.active ? (o.manuallyPaused = true, this._setPausedState(true, E)) : this;
      },
      unpause: function(E) {
        return o.active ? (o.manuallyPaused = false, i[i.length - 1] !== this ? this : this._setPausedState(false, E)) : this;
      },
      updateContainerElements: function(E) {
        var N = [].concat(E).filter(Boolean);
        return o.containers = N.map(function(A) {
          return typeof A == "string" ? r.querySelector(A) : A;
        }), o.active && d(), C(), this;
      }
    }, Object.defineProperties(a, {
      _isManuallyPaused: {
        value: function() {
          return o.manuallyPaused;
        }
      },
      _setPausedState: {
        value: function(E, N) {
          if (o.paused === E) return this;
          if (o.paused = E, E) {
            var A = u(N, "onPause"), R = u(N, "onPostPause");
            A?.(), M(), C(), R?.();
          } else {
            var B = u(N, "onUnpause"), z = u(N, "onPostUnpause");
            B?.(), d(), T(), C(), z?.();
          }
          return this;
        }
      }
    }), a.updateContainerElements(e), a;
  };
  function I6(n = {}) {
    let e;
    const { immediate: t, ...r } = n, i = bt(false), s = bt(false), o = (h) => e?.activate(h), a = (h) => {
      e?.deactivate(h);
    }, u = () => {
      e && (e.pause(), s.set(true));
    }, l = () => {
      e && (e.unpause(), s.set(false));
    };
    return {
      useFocusTrap: (h) => (e = D6(h, {
        ...r,
        onActivate() {
          i.set(true), n.onActivate?.();
        },
        onDeactivate() {
          i.set(false), n.onDeactivate?.();
        }
      }), t && o(), {
        destroy() {
          a(), e = void 0;
        }
      }),
      hasFocus: lc(i),
      isPaused: lc(s),
      activate: o,
      deactivate: a,
      pause: u,
      unpause: l
    };
  }
  const Is = [], R6 = (n, e) => {
    let t = ht;
    function r() {
      const s = Is.indexOf(n);
      s >= 0 && Is.splice(s, 1);
    }
    function i(s) {
      t();
      const { open: o, onClose: a, shouldCloseOnInteractOutside: u, closeOnInteractOutside: l } = s;
      Nm(100).then(() => {
        o ? Is.push(n) : r();
      });
      function c() {
        return KT(Is) === n;
      }
      function h() {
        c() && a && (a(), r());
      }
      function d(p) {
        const m = p.target;
        ec(m) && m && c() && (p.preventDefault(), p.stopPropagation(), p.stopImmediatePropagation());
      }
      function f(p) {
        u?.(p) && c() && (p.preventDefault(), p.stopPropagation(), p.stopImmediatePropagation(), h());
      }
      t = L6(n, {
        onInteractOutsideStart: d,
        onInteractOutside: l ? f : void 0,
        enabled: o
      }).destroy;
    }
    return i(e), {
      update: i,
      destroy() {
        r(), t();
      }
    };
  }, _6 = (n, e = "body") => {
    let t;
    if (!fr(e) && typeof e != "string") return {
      destroy: ht
    };
    async function r(s) {
      if (e = s, typeof e == "string") {
        if (t = document.querySelector(e), t === null && (await Co(), t = document.querySelector(e)), t === null) throw new Error(`No element found matching css selector: "${e}"`);
      } else if (e instanceof HTMLElement) t = e;
      else throw new TypeError(`Unknown portal target type: ${e === null ? "null" : typeof e}. Allowed types: string (CSS selector) or HTMLElement.`);
      n.dataset.portal = "", t.appendChild(n), n.hidden = false;
    }
    function i() {
      n.remove();
    }
    return r(e), {
      update: r,
      destroy: i
    };
  }, L6 = (n, e) => {
    let t = ht, r = ht, i = false, s = false, o = false;
    function a(c) {
      t(), r();
      const { onInteractOutside: h, onInteractOutsideStart: d, enabled: f } = c;
      if (!f) return;
      function p(g) {
        h && hh(g, n) && d?.(g);
        const w = g.target;
        ec(w) && Im(n, w) && (s = true), i = true;
      }
      function m(g) {
        h?.(g);
      }
      const b = B6(n);
      if (typeof PointerEvent < "u") {
        const g = (w) => {
          r();
          const v = (y) => {
            u(y) && m(y), l();
          };
          if (w.pointerType === "touch") {
            r = Bn(b, "click", v, {
              capture: true,
              once: true
            });
            return;
          }
          v(w);
        };
        t = ii(Bn(b, "pointerdown", p, true), Bn(b, "pointerup", g, true));
      } else {
        const g = (v) => {
          o ? o = false : u(v) && m(v), l();
        }, w = (v) => {
          o = true, u(v) && m(v), l();
        };
        t = ii(Bn(b, "mousedown", p, true), Bn(b, "mouseup", g, true), Bn(b, "touchstart", p, true), Bn(b, "touchend", w, true));
      }
    }
    function u(c) {
      return !!(i && !s && hh(c, n));
    }
    function l() {
      i = false, s = false;
    }
    return a(e), {
      update: a,
      destroy() {
        t(), r();
      }
    };
  };
  function hh(n, e) {
    if ("button" in n && n.button > 0) return false;
    const t = n.target;
    if (!ec(t)) return false;
    const r = t.ownerDocument;
    return !r || !r.documentElement.contains(t) ? false : e && !Im(e, t);
  }
  function Im(n, e) {
    return n === e || n.contains(e);
  }
  function B6(n) {
    return n?.ownerDocument ?? document;
  }
  Nr(false), Nr(false), Nr(void 0);
  const F6 = {
    isDateDisabled: void 0,
    isDateUnavailable: void 0,
    value: void 0,
    preventDeselect: false,
    numberOfMonths: 1,
    pagedNavigation: false,
    weekStartsOn: 0,
    fixedWeeks: false,
    calendarLabel: "Event Date",
    locale: "en",
    minValue: void 0,
    maxValue: void 0,
    disabled: false,
    readonly: false,
    weekdayFormat: "narrow"
  };
  ({
    ...Mm(F6, "isDateDisabled", "isDateUnavailable", "value", "locale", "disabled", "readonly", "minValue", "maxValue", "weekdayFormat")
  });
  const { name: vr } = YT("dialog"), z6 = {
    preventScroll: true,
    closeOnEscape: true,
    closeOnOutsideClick: true,
    role: "dialog",
    defaultOpen: false,
    portal: void 0,
    forceVisible: false,
    openFocus: void 0,
    closeFocus: void 0,
    onOutsideClick: void 0
  }, j6 = [
    "content",
    "title",
    "description"
  ];
  function q6(n) {
    const e = {
      ...z6,
      ...n
    }, t = oh(Mm(e, "ids")), { preventScroll: r, closeOnEscape: i, closeOnOutsideClick: s, role: o, portal: a, forceVisible: u, openFocus: l, closeFocus: c, onOutsideClick: h } = t, d = as.writable(null), f = oh({
      ...a6(j6),
      ...e.ids
    }), p = e.open ?? bt(e.defaultOpen), m = r6(p, e?.onOpenChange), b = an([
      m,
      u
    ], ([C, O]) => C || O);
    let g = ht;
    function w(C) {
      const O = C.currentTarget, E = C.currentTarget;
      !fr(O) || !fr(E) || (m.set(true), d.set(E));
    }
    function v() {
      m.set(false), ah({
        prop: c.get(),
        defaultEl: d.get()
      });
    }
    const y = Jn(vr("trigger"), {
      stores: [
        m
      ],
      returned: ([C]) => ({
        "aria-haspopup": "dialog",
        "aria-expanded": C,
        type: "button"
      }),
      action: (C) => ({
        destroy: ii(Ps(C, "click", (E) => {
          w(E);
        }), Ps(C, "keydown", (E) => {
          E.key !== Ii.ENTER && E.key !== Ii.SPACE || (E.preventDefault(), w(E));
        }))
      })
    }), x = Jn(vr("overlay"), {
      stores: [
        b,
        m
      ],
      returned: ([C, O]) => ({
        hidden: C ? void 0 : true,
        tabindex: -1,
        style: el({
          display: C ? void 0 : "none"
        }),
        "aria-hidden": true,
        "data-state": O ? "open" : "closed"
      }),
      action: (C) => {
        let O = ht;
        if (i.get()) {
          const E = uh(C, {
            handler: () => {
              v();
            }
          });
          E && E.destroy && (O = E.destroy);
        }
        return {
          destroy() {
            O();
          }
        };
      }
    }), k = Jn(vr("content"), {
      stores: [
        b,
        f.content,
        f.description,
        f.title,
        m
      ],
      returned: ([C, O, E, N, A]) => ({
        id: O,
        role: o.get(),
        "aria-describedby": E,
        "aria-labelledby": N,
        "aria-modal": C ? "true" : void 0,
        "data-state": A ? "open" : "closed",
        tabindex: -1,
        hidden: C ? void 0 : true,
        style: el({
          display: C ? void 0 : "none"
        })
      }),
      action: (C) => {
        let O = ht, E = ht;
        const N = ii(kr([
          m,
          s,
          i
        ], ([A, R, B]) => {
          if (!A) return;
          const z = I6({
            immediate: false,
            escapeDeactivates: B,
            clickOutsideDeactivates: R,
            allowOutsideClick: true,
            returnFocusOnDeactivate: false,
            fallbackFocus: C
          });
          O = z.activate, E = z.deactivate;
          const L = z.useFocusTrap(C);
          return L && L.destroy ? L.destroy : z.deactivate;
        }), kr([
          s,
          m
        ], ([A, R]) => R6(C, {
          open: R,
          closeOnInteractOutside: A,
          onClose() {
            v();
          },
          shouldCloseOnInteractOutside(B) {
            return h.get()?.(B), !B.defaultPrevented;
          }
        }).destroy), kr([
          i
        ], ([A]) => A ? uh(C, {
          handler: v
        }).destroy : ht), kr([
          b
        ], ([A]) => {
          Co().then(() => {
            A ? O() : E();
          });
        }));
        return {
          destroy: () => {
            g(), N();
          }
        };
      }
    }), T = Jn(vr("portalled"), {
      stores: a,
      returned: (C) => ({
        "data-portal": JT(C)
      }),
      action: (C) => {
        const O = kr([
          a
        ], ([E]) => {
          if (E === null) return ht;
          const N = b6(C, E);
          return N === null ? ht : _6(C, N).destroy;
        });
        return {
          destroy() {
            O();
          }
        };
      }
    }), M = Jn(vr("title"), {
      stores: [
        f.title
      ],
      returned: ([C]) => ({
        id: C
      })
    }), D = Jn(vr("description"), {
      stores: [
        f.description
      ],
      returned: ([C]) => ({
        id: C
      })
    }), I = Jn(vr("close"), {
      returned: () => ({
        type: "button"
      }),
      action: (C) => ({
        destroy: ii(Ps(C, "click", () => {
          v();
        }), Ps(C, "keydown", (E) => {
          E.key !== Ii.SPACE && E.key !== Ii.ENTER || (E.preventDefault(), v());
        }))
      })
    });
    return kr([
      m,
      r
    ], ([C, O]) => {
      if (XT) {
        if (O && C && (g = m6()), C) {
          const E = document.getElementById(f.content.get());
          ah({
            prop: l.get(),
            defaultEl: E
          });
        }
        return () => {
          u.get() || g();
        };
      }
    }), {
      ids: f,
      elements: {
        content: k,
        trigger: y,
        title: M,
        description: D,
        overlay: x,
        close: I,
        portalled: T
      },
      states: {
        open: m
      },
      options: t
    };
  }
  function $6(n, e) {
    const t = {};
    return e.forEach((r) => {
      t[r] = {
        [`data-${n}-${r}`]: ""
      };
    }), (r) => t[r];
  }
  function V6() {
    const n = bg();
    return (e) => {
      const { originalEvent: t } = e.detail, { cancelable: r } = e, i = t.type;
      n(i, {
        originalEvent: t,
        currentTarget: t.currentTarget
      }, {
        cancelable: r
      }) || e.preventDefault();
    };
  }
  function H6(n) {
    const e = {};
    for (const t in n) {
      const r = n[t];
      r !== void 0 && (e[t] = r);
    }
    return e;
  }
  function W6(n) {
    return function(e, t) {
      if (t === void 0) return;
      const r = n[e];
      r && r.set(t);
    };
  }
  function Rm() {
    return {
      NAME: "dialog",
      PARTS: [
        "close",
        "content",
        "description",
        "overlay",
        "portal",
        "title",
        "trigger"
      ]
    };
  }
  function U6(n) {
    const { NAME: e, PARTS: t } = Rm(), r = $6(e, t), i = {
      ...q6({
        ...H6(n),
        role: "dialog",
        forceVisible: true
      }),
      getAttrs: r
    };
    return il(e, i), {
      ...i,
      updateOption: W6(i.options)
    };
  }
  function bi() {
    const { NAME: n } = Rm();
    return sn(n);
  }
  function G6(n, e) {
    Re(e, false);
    const [t, r] = An(), i = () => dt(g, "$idValues", t);
    let s = $(e, "preventScroll", 24, () => {
    }), o = $(e, "closeOnEscape", 24, () => {
    }), a = $(e, "closeOnOutsideClick", 24, () => {
    }), u = $(e, "portal", 24, () => {
    }), l = $(e, "open", 28, () => {
    }), c = $(e, "onOpenChange", 24, () => {
    }), h = $(e, "openFocus", 24, () => {
    }), d = $(e, "closeFocus", 24, () => {
    }), f = $(e, "onOutsideClick", 24, () => {
    });
    const { states: { open: p }, updateOption: m, ids: b } = U6({
      closeOnEscape: o(),
      preventScroll: s(),
      closeOnOutsideClick: a(),
      portal: u(),
      forceVisible: true,
      defaultOpen: l(),
      openFocus: h(),
      closeFocus: d(),
      onOutsideClick: f(),
      onOpenChange: ({ next: y }) => (l() !== y && (c()?.(y), l(y)), y)
    }), g = an([
      b.content,
      b.description,
      b.title
    ], ([y, x, k]) => ({
      content: y,
      description: x,
      title: k
    }));
    ze(() => nt(l()), () => {
      l() !== void 0 && p.set(l());
    }), ze(() => nt(s()), () => {
      m("preventScroll", s());
    }), ze(() => nt(o()), () => {
      m("closeOnEscape", o());
    }), ze(() => nt(a()), () => {
      m("closeOnOutsideClick", a());
    }), ze(() => nt(u()), () => {
      m("portal", u());
    }), ze(() => nt(h()), () => {
      m("openFocus", h());
    }), ze(() => nt(d()), () => {
      m("closeFocus", d());
    }), ze(() => nt(f()), () => {
      m("onOutsideClick", f());
    }), fn(), $t();
    var w = se(), v = J(w);
    lt(v, e, "default", {
      get ids() {
        return i();
      }
    }), F(n, w), _e(), r();
  }
  function K6(n, e) {
    const t = gt(e, [
      "children",
      "$$slots",
      "$$events",
      "$$legacy"
    ]), r = gt(t, [
      "level",
      "asChild",
      "id",
      "el"
    ]);
    Re(e, false);
    const [i, s] = An(), o = () => dt(d, "$title", i), a = $n();
    let u = $(e, "level", 8, "h2"), l = $(e, "asChild", 8, false), c = $(e, "id", 24, () => {
    }), h = $(e, "el", 28, () => {
    });
    const { elements: { title: d }, ids: f, getAttrs: p } = bi(), m = p("title");
    ze(() => nt(c()), () => {
      c() && f.title.set(c());
    }), ze(() => o(), () => {
      te(a, o());
    }), ze(() => S(a), () => {
      Object.assign(S(a), m);
    }), fn(), $t();
    var b = se(), g = J(b);
    {
      var w = (y) => {
        var x = se(), k = J(x);
        lt(k, e, "default", {
          get builder() {
            return S(a);
          }
        }), F(y, x);
      }, v = (y) => {
        var x = se(), k = J(x);
        ol(k, u, false, (T, M) => {
          ct(T, (O) => h(O), () => h()), zt(T, (O) => S(a).action?.(O));
          let D;
          qe(() => D = Ge(T, D, {
            ...S(a),
            ...r
          }));
          var I = se(), C = J(I);
          lt(C, e, "default", {
            get builder() {
              return S(a);
            }
          }), F(M, I);
        }), F(y, x);
      };
      be(g, (y) => {
        l() ? y(w) : y(v, false);
      });
    }
    F(n, b), _e(), s();
  }
  var J6 = ae("<div><!></div>");
  function Y6(n, e) {
    const t = gt(e, [
      "children",
      "$$slots",
      "$$events",
      "$$legacy"
    ]), r = gt(t, [
      "asChild",
      "el"
    ]);
    Re(e, false);
    const [i, s] = An(), o = () => dt(c, "$portalled", i), a = $n();
    let u = $(e, "asChild", 8, false), l = $(e, "el", 28, () => {
    });
    const { elements: { portalled: c }, getAttrs: h } = bi(), d = h("portal");
    ze(() => o(), () => {
      te(a, o());
    }), ze(() => S(a), () => {
      Object.assign(S(a), d);
    }), fn(), $t();
    var f = se(), p = J(f);
    {
      var m = (g) => {
        var w = se(), v = J(w);
        lt(v, e, "default", {
          get builder() {
            return S(a);
          }
        }), F(g, w);
      }, b = (g) => {
        var w = J6();
        let v;
        var y = Se(w);
        lt(y, e, "default", {
          get builder() {
            return S(a);
          }
        }), we(w), ct(w, (x) => l(x), () => l()), zt(w, (x) => S(a).action?.(x)), qe(() => v = Ge(w, v, {
          ...S(a),
          ...r
        })), F(g, w);
      };
      be(p, (g) => {
        u() ? g(m) : g(b, false);
      });
    }
    F(n, f), _e(), s();
  }
  var X6 = ae("<div><!></div>"), Q6 = ae("<div><!></div>"), Z6 = ae("<div><!></div>"), eE = ae("<div><!></div>"), tE = ae("<div><!></div>");
  function nE(n, e) {
    const t = gt(e, [
      "children",
      "$$slots",
      "$$events",
      "$$legacy"
    ]), r = gt(t, [
      "transition",
      "transitionConfig",
      "inTransition",
      "inTransitionConfig",
      "outTransition",
      "outTransitionConfig",
      "asChild",
      "id",
      "el"
    ]);
    Re(e, false);
    const [i, s] = An(), o = () => dt(w, "$content", i), a = () => dt(v, "$open", i), u = $n();
    let l = $(e, "transition", 24, () => {
    }), c = $(e, "transitionConfig", 24, () => {
    }), h = $(e, "inTransition", 24, () => {
    }), d = $(e, "inTransitionConfig", 24, () => {
    }), f = $(e, "outTransition", 24, () => {
    }), p = $(e, "outTransitionConfig", 24, () => {
    }), m = $(e, "asChild", 8, false), b = $(e, "id", 24, () => {
    }), g = $(e, "el", 28, () => {
    });
    const { elements: { content: w }, states: { open: v }, ids: y, getAttrs: x } = bi(), k = x("content");
    ze(() => nt(b()), () => {
      b() && y.content.set(b());
    }), ze(() => o(), () => {
      te(u, o());
    }), ze(() => S(u), () => {
      Object.assign(S(u), k);
    }), fn(), $t();
    var T = se(), M = J(T);
    {
      var D = (C) => {
        var O = se(), E = J(O);
        lt(E, e, "default", {
          get builder() {
            return S(u);
          }
        }), F(C, O);
      }, I = (C, O) => {
        {
          var E = (A) => {
            var R = X6();
            let B;
            var z = Se(R);
            lt(z, e, "default", {
              get builder() {
                return S(u);
              }
            }), we(R), ct(R, (L) => g(L), () => g()), zt(R, (L) => S(u).action?.(L)), Pe(() => Oe("pointerdown", R, function(L) {
              Ae.call(this, e, L);
            })), Pe(() => Oe("pointermove", R, function(L) {
              Ae.call(this, e, L);
            })), Pe(() => Oe("pointerup", R, function(L) {
              Ae.call(this, e, L);
            })), Pe(() => Oe("touchcancel", R, function(L) {
              Ae.call(this, e, L);
            })), Pe(() => Oe("touchend", R, function(L) {
              Ae.call(this, e, L);
            })), Pe(() => Oe("touchmove", R, function(L) {
              Ae.call(this, e, L);
            }, void 0, false)), Pe(() => Oe("touchstart", R, function(L) {
              Ae.call(this, e, L);
            }, void 0, false)), qe(() => B = Ge(R, B, {
              ...S(u),
              ...r
            })), Sn(3, R, l, c), F(A, R);
          }, N = (A, R) => {
            {
              var B = (L) => {
                var V = Q6();
                let K;
                var pe = Se(V);
                lt(pe, e, "default", {
                  get builder() {
                    return S(u);
                  }
                }), we(V), ct(V, (H) => g(H), () => g()), zt(V, (H) => S(u).action?.(H)), Pe(() => Oe("pointerdown", V, function(H) {
                  Ae.call(this, e, H);
                })), Pe(() => Oe("pointermove", V, function(H) {
                  Ae.call(this, e, H);
                })), Pe(() => Oe("pointerup", V, function(H) {
                  Ae.call(this, e, H);
                })), Pe(() => Oe("touchcancel", V, function(H) {
                  Ae.call(this, e, H);
                })), Pe(() => Oe("touchend", V, function(H) {
                  Ae.call(this, e, H);
                })), Pe(() => Oe("touchmove", V, function(H) {
                  Ae.call(this, e, H);
                }, void 0, false)), Pe(() => Oe("touchstart", V, function(H) {
                  Ae.call(this, e, H);
                }, void 0, false)), qe(() => K = Ge(V, K, {
                  ...S(u),
                  ...r
                })), Sn(1, V, h, d), Sn(2, V, f, p), F(L, V);
              }, z = (L, V) => {
                {
                  var K = (H) => {
                    var ue = Z6();
                    let ne;
                    var ce = Se(ue);
                    lt(ce, e, "default", {
                      get builder() {
                        return S(u);
                      }
                    }), we(ue), ct(ue, (Z) => g(Z), () => g()), zt(ue, (Z) => S(u).action?.(Z)), Pe(() => Oe("pointerdown", ue, function(Z) {
                      Ae.call(this, e, Z);
                    })), Pe(() => Oe("pointermove", ue, function(Z) {
                      Ae.call(this, e, Z);
                    })), Pe(() => Oe("pointerup", ue, function(Z) {
                      Ae.call(this, e, Z);
                    })), Pe(() => Oe("touchcancel", ue, function(Z) {
                      Ae.call(this, e, Z);
                    })), Pe(() => Oe("touchend", ue, function(Z) {
                      Ae.call(this, e, Z);
                    })), Pe(() => Oe("touchmove", ue, function(Z) {
                      Ae.call(this, e, Z);
                    }, void 0, false)), Pe(() => Oe("touchstart", ue, function(Z) {
                      Ae.call(this, e, Z);
                    }, void 0, false)), qe(() => ne = Ge(ue, ne, {
                      ...S(u),
                      ...r
                    })), Sn(1, ue, h, d), F(H, ue);
                  }, pe = (H, ue) => {
                    {
                      var ne = (Z) => {
                        var de = eE();
                        let _;
                        var W = Se(de);
                        lt(W, e, "default", {
                          get builder() {
                            return S(u);
                          }
                        }), we(de), ct(de, (P) => g(P), () => g()), zt(de, (P) => S(u).action?.(P)), Pe(() => Oe("pointerdown", de, function(P) {
                          Ae.call(this, e, P);
                        })), Pe(() => Oe("pointermove", de, function(P) {
                          Ae.call(this, e, P);
                        })), Pe(() => Oe("pointerup", de, function(P) {
                          Ae.call(this, e, P);
                        })), Pe(() => Oe("touchcancel", de, function(P) {
                          Ae.call(this, e, P);
                        })), Pe(() => Oe("touchend", de, function(P) {
                          Ae.call(this, e, P);
                        })), Pe(() => Oe("touchmove", de, function(P) {
                          Ae.call(this, e, P);
                        }, void 0, false)), Pe(() => Oe("touchstart", de, function(P) {
                          Ae.call(this, e, P);
                        }, void 0, false)), qe(() => _ = Ge(de, _, {
                          ...S(u),
                          ...r
                        })), Sn(2, de, f, p), F(Z, de);
                      }, ce = (Z, de) => {
                        {
                          var _ = (W) => {
                            var P = tE();
                            let q;
                            var j = Se(P);
                            lt(j, e, "default", {
                              get builder() {
                                return S(u);
                              }
                            }), we(P), ct(P, (U) => g(U), () => g()), zt(P, (U) => S(u).action?.(U)), Pe(() => Oe("pointerdown", P, function(U) {
                              Ae.call(this, e, U);
                            })), Pe(() => Oe("pointermove", P, function(U) {
                              Ae.call(this, e, U);
                            })), Pe(() => Oe("pointerup", P, function(U) {
                              Ae.call(this, e, U);
                            })), Pe(() => Oe("touchcancel", P, function(U) {
                              Ae.call(this, e, U);
                            })), Pe(() => Oe("touchend", P, function(U) {
                              Ae.call(this, e, U);
                            })), Pe(() => Oe("touchmove", P, function(U) {
                              Ae.call(this, e, U);
                            }, void 0, false)), Pe(() => Oe("touchstart", P, function(U) {
                              Ae.call(this, e, U);
                            }, void 0, false)), qe(() => q = Ge(P, q, {
                              ...S(u),
                              ...r
                            })), F(W, P);
                          };
                          be(Z, (W) => {
                            a() && W(_);
                          }, de);
                        }
                      };
                      be(H, (Z) => {
                        f() && a() ? Z(ne) : Z(ce, false);
                      }, ue);
                    }
                  };
                  be(L, (H) => {
                    h() && a() ? H(K) : H(pe, false);
                  }, V);
                }
              };
              be(A, (L) => {
                h() && f() && a() ? L(B) : L(z, false);
              }, R);
            }
          };
          be(C, (A) => {
            l() && a() ? A(E) : A(N, false);
          }, O);
        }
      };
      be(M, (C) => {
        m() && a() ? C(D) : C(I, false);
      });
    }
    F(n, T), _e(), s();
  }
  var rE = ae("<div></div>"), iE = ae("<div></div>"), sE = ae("<div></div>"), oE = ae("<div></div>"), aE = ae("<div></div>");
  function uE(n, e) {
    const t = gt(e, [
      "children",
      "$$slots",
      "$$events",
      "$$legacy"
    ]), r = gt(t, [
      "transition",
      "transitionConfig",
      "inTransition",
      "inTransitionConfig",
      "outTransition",
      "outTransitionConfig",
      "asChild",
      "el"
    ]);
    Re(e, false);
    const [i, s] = An(), o = () => dt(g, "$overlay", i), a = () => dt(w, "$open", i), u = $n();
    let l = $(e, "transition", 24, () => {
    }), c = $(e, "transitionConfig", 24, () => {
    }), h = $(e, "inTransition", 24, () => {
    }), d = $(e, "inTransitionConfig", 24, () => {
    }), f = $(e, "outTransition", 24, () => {
    }), p = $(e, "outTransitionConfig", 24, () => {
    }), m = $(e, "asChild", 8, false), b = $(e, "el", 28, () => {
    });
    const { elements: { overlay: g }, states: { open: w }, getAttrs: v } = bi(), y = v("overlay");
    ze(() => o(), () => {
      te(u, o());
    }), ze(() => S(u), () => {
      Object.assign(S(u), y);
    }), fn(), $t();
    var x = se(), k = J(x);
    {
      var T = (D) => {
        var I = se(), C = J(I);
        lt(C, e, "default", {
          get builder() {
            return S(u);
          }
        }), F(D, I);
      }, M = (D, I) => {
        {
          var C = (E) => {
            var N = rE();
            let A;
            Pe(() => Oe("mouseup", N, function(R) {
              Ae.call(this, e, R);
            })), ct(N, (R) => b(R), () => b()), zt(N, (R) => S(u).action?.(R)), qe(() => A = Ge(N, A, {
              ...S(u),
              ...r
            })), Sn(3, N, l, c), F(E, N);
          }, O = (E, N) => {
            {
              var A = (B) => {
                var z = iE();
                let L;
                ct(z, (V) => b(V), () => b()), zt(z, (V) => S(u).action?.(V)), Pe(() => Oe("mouseup", z, function(V) {
                  Ae.call(this, e, V);
                })), qe(() => L = Ge(z, L, {
                  ...S(u),
                  ...r
                })), Sn(1, z, h, d), Sn(2, z, f, p), F(B, z);
              }, R = (B, z) => {
                {
                  var L = (K) => {
                    var pe = sE();
                    let H;
                    ct(pe, (ue) => b(ue), () => b()), zt(pe, (ue) => S(u).action?.(ue)), Pe(() => Oe("mouseup", pe, function(ue) {
                      Ae.call(this, e, ue);
                    })), qe(() => H = Ge(pe, H, {
                      ...S(u),
                      ...r
                    })), Sn(1, pe, h, d), F(K, pe);
                  }, V = (K, pe) => {
                    {
                      var H = (ne) => {
                        var ce = oE();
                        let Z;
                        ct(ce, (de) => b(de), () => b()), zt(ce, (de) => S(u).action?.(de)), Pe(() => Oe("mouseup", ce, function(de) {
                          Ae.call(this, e, de);
                        })), qe(() => Z = Ge(ce, Z, {
                          ...S(u),
                          ...r
                        })), Sn(2, ce, f, p), F(ne, ce);
                      }, ue = (ne, ce) => {
                        {
                          var Z = (de) => {
                            var _ = aE();
                            let W;
                            ct(_, (P) => b(P), () => b()), zt(_, (P) => S(u).action?.(P)), Pe(() => Oe("mouseup", _, function(P) {
                              Ae.call(this, e, P);
                            })), qe(() => W = Ge(_, W, {
                              ...S(u),
                              ...r
                            })), F(de, _);
                          };
                          be(ne, (de) => {
                            a() && de(Z);
                          }, ce);
                        }
                      };
                      be(K, (ne) => {
                        f() && a() ? ne(H) : ne(ue, false);
                      }, pe);
                    }
                  };
                  be(B, (K) => {
                    h() && a() ? K(L) : K(V, false);
                  }, z);
                }
              };
              be(E, (B) => {
                h() && f() && a() ? B(A) : B(R, false);
              }, N);
            }
          };
          be(D, (E) => {
            l() && a() ? E(C) : E(O, false);
          }, I);
        }
      };
      be(k, (D) => {
        m() && a() ? D(T) : D(M, false);
      });
    }
    F(n, x), _e(), s();
  }
  var lE = ae("<button><!></button>");
  function ph(n, e) {
    const t = gt(e, [
      "children",
      "$$slots",
      "$$events",
      "$$legacy"
    ]), r = gt(t, [
      "asChild",
      "el"
    ]);
    Re(e, false);
    const [i, s] = An(), o = () => dt(c, "$trigger", i), a = $n();
    let u = $(e, "asChild", 8, false), l = $(e, "el", 28, () => {
    });
    const { elements: { trigger: c }, getAttrs: h } = bi(), d = V6(), f = h("trigger");
    ze(() => o(), () => {
      te(a, o());
    }), ze(() => S(a), () => {
      Object.assign(S(a), f);
    }), fn(), $t();
    var p = se(), m = J(p);
    {
      var b = (w) => {
        var v = se(), y = J(v);
        lt(y, e, "default", {
          get builder() {
            return S(a);
          }
        }), F(w, v);
      }, g = (w) => {
        var v = lE();
        let y;
        var x = Se(v);
        lt(x, e, "default", {
          get builder() {
            return S(a);
          }
        }), we(v), ct(v, (k) => l(k), () => l()), zt(v, (k) => S(a).action?.(k)), Pe(() => Oe("m-click", v, d)), Pe(() => Oe("m-keydown", v, d)), qe(() => y = Ge(v, y, {
          ...S(a),
          type: "button",
          ...r
        })), F(w, v);
      };
      be(m, (w) => {
        u() ? w(b) : w(g, false);
      });
    }
    F(n, p), _e(), s();
  }
  var cE = ae("<div><!></div>");
  function dE(n, e) {
    const t = gt(e, [
      "children",
      "$$slots",
      "$$events",
      "$$legacy"
    ]), r = gt(t, [
      "asChild",
      "id",
      "el"
    ]);
    Re(e, false);
    const [i, s] = An(), o = () => dt(h, "$description", i), a = $n();
    let u = $(e, "asChild", 8, false), l = $(e, "id", 24, () => {
    }), c = $(e, "el", 28, () => {
    });
    const { elements: { description: h }, ids: d, getAttrs: f } = bi(), p = f("description");
    ze(() => nt(l()), () => {
      l() && d.description.set(l());
    }), ze(() => o(), () => {
      te(a, o());
    }), ze(() => S(a), () => {
      Object.assign(S(a), p);
    }), fn(), $t();
    var m = se(), b = J(m);
    {
      var g = (v) => {
        var y = se(), x = J(y);
        lt(x, e, "default", {
          get builder() {
            return S(a);
          }
        }), F(v, y);
      }, w = (v) => {
        var y = cE();
        let x;
        var k = Se(y);
        lt(k, e, "default", {
          get builder() {
            return S(a);
          }
        }), we(y), ct(y, (T) => c(T), () => c()), zt(y, (T) => S(a).action?.(T)), qe(() => x = Ge(y, x, {
          ...S(a),
          ...r
        })), F(v, y);
      };
      be(b, (v) => {
        u() ? v(g) : v(w, false);
      });
    }
    F(n, m), _e(), s();
  }
  function fE(n) {
    return function(e, t) {
      if (t === void 0) return;
      const r = n[e];
      r && r.set(t);
    };
  }
  const Qe = {
    DURATION: 0.5,
    EASE: [
      0.32,
      0.72,
      0,
      1
    ]
  }, _m = 0.4;
  function on(n, e) {
    if (typeof document > "u") return () => {
    };
    const t = hE(n, (r, i) => ({
      stores: r,
      onUnsubscribe: i
    })).subscribe(({ stores: r, onUnsubscribe: i }) => {
      const s = e(r);
      s && i(s);
    });
    return Lm(t), t;
  }
  function hE(n, e) {
    let t = [];
    const r = (a) => {
      t.push(a);
    }, i = () => {
      t.forEach((a) => a()), t = [];
    }, s = an(n, (a) => (i(), e(a, r)));
    return Lm(i), {
      ...s,
      subscribe: (...a) => {
        const u = s.subscribe(...a);
        return () => {
          u(), i();
        };
      }
    };
  }
  const Lm = (n) => {
    try {
      Xi(n);
    } catch {
      return n();
    }
  }, mh = (n, e) => {
    const t = (i, s) => {
      n.update((o) => {
        const a = i(o);
        let u = a;
        return e && (u = e({
          curr: o,
          next: a
        })), s?.(u), u;
      });
    };
    return {
      ...n,
      update: t,
      set: (i) => {
        t(() => i);
      }
    };
  };
  function pE(n) {
    const e = {};
    return Object.keys(n).forEach((t) => {
      const r = t, i = n[r];
      e[r] = bt(i);
    }), e;
  }
  function mE(n, ...e) {
    const t = {};
    for (const r of Object.keys(n)) e.includes(r) || (t[r] = n[r]);
    return t;
  }
  function gE(n) {
    const e = {};
    for (const t in n) {
      const r = n[t];
      r !== void 0 && (e[t] = r);
    }
    return e;
  }
  const Bm = /* @__PURE__ */ new WeakMap();
  function tt(n, e, t = false) {
    if (!n || !(n instanceof HTMLElement) || !e) return;
    const r = {};
    Object.entries(e).forEach(([i, s]) => {
      if (i.startsWith("--")) {
        n.style.setProperty(i, s);
        return;
      }
      r[i] = n.style[i], n.style[i] = s;
    }), !t && Bm.set(n, r);
  }
  function Mi(n, e) {
    if (!n || !(n instanceof HTMLElement)) return;
    const t = Bm.get(n);
    t && (e ? n.style[e] = t[e] : Object.entries(t).forEach(([r, i]) => {
      n.style[r] = i;
    }));
  }
  function Rs(n, e) {
    const t = window.getComputedStyle(n), r = t.transform || t.webkitTransform || t.mozTransform;
    let i = r.match(/^matrix3d\((.+)\)$/);
    return i ? parseFloat(i[1].split(", ")[yt(e) ? 13 : 12]) : (i = r.match(/^matrix\((.+)\)$/), i ? parseFloat(i[1].split(", ")[yt(e) ? 5 : 4]) : null);
  }
  function bE(n) {
    return Object.keys(n).reduce((e, t) => n[t] === void 0 ? e : e + `${t}:${n[t]};`, "");
  }
  function nl() {
  }
  function er(n, e, t, r) {
    const i = Array.isArray(e) ? e : [
      e
    ];
    return i.forEach((s) => n.addEventListener(s, t, r)), () => {
      i.forEach((s) => n.removeEventListener(s, t, r));
    };
  }
  const yE = /* @__PURE__ */ new Set([
    "checkbox",
    "radio",
    "range",
    "color",
    "file",
    "image",
    "button",
    "submit",
    "reset"
  ]), vE = typeof document < "u";
  function xo(n) {
    return n instanceof HTMLInputElement && !yE.has(n.type) || n instanceof HTMLTextAreaElement || n instanceof HTMLElement && n.isContentEditable;
  }
  function yt(n) {
    return n === "top" || n === "bottom";
  }
  function gh(n) {
    return n === "bottom" || n === "right";
  }
  function ko(...n) {
    return (...e) => {
      for (const t of n) typeof t == "function" && t(...e);
    };
  }
  function wE(n) {
    return new Promise((e) => setTimeout(e, n));
  }
  function xE({ activeSnapPoint: n, snapPoints: e, drawerRef: t, overlayRef: r, fadeFromIndex: i, openTime: s, direction: o }) {
    const a = an([
      e,
      n
    ], ([g, w]) => w === g?.[g.length - 1]), u = an([
      e,
      i,
      n
    ], ([g, w, v]) => g && g.length > 0 && (w || w === 0) && !Number.isNaN(w) && g[w] === v || !g), l = an([
      e,
      n
    ], ([g, w]) => g?.findIndex((v) => v === w) ?? null), c = an(e, (g) => g ? g.map((w) => {
      const v = typeof window < "u", y = typeof w == "string";
      let x = 0;
      y && (x = parseInt(w, 10));
      const k = Q(o);
      if (yt(k)) {
        const M = y ? x : v ? w * window.innerHeight : 0;
        return v ? k === "bottom" ? window.innerHeight - M : window.innerHeight + M : M;
      }
      const T = y ? x : v ? w * window.innerWidth : 0;
      return v ? k === "right" ? window.innerWidth - T : window.innerWidth + T : T;
    }) : []), h = an([
      c,
      l
    ], ([g, w]) => w !== null ? g?.[w] : null);
    on([
      n,
      t
    ], ([g, w]) => {
      if (g && w) {
        const v = Q(e), y = Q(c), x = v?.findIndex((k) => k === g) ?? -1;
        y && x !== -1 && typeof y[x] == "number" && d(y[x]);
      }
    });
    function d(g) {
      Co().then(() => {
        const w = Q(c), v = w?.findIndex((M) => M === g) ?? null, y = Q(t), x = Q(o);
        b(v), tt(y, {
          transition: `transform ${Qe.DURATION}s cubic-bezier(${Qe.EASE.join(",")})`,
          transform: yt(x) ? `translate3d(0, ${g}px, 0)` : `translate3d(${g}px, 0, 0)`
        });
        const k = Q(i), T = Q(r);
        c && v !== w.length - 1 && v !== k ? tt(T, {
          transition: `opacity ${Qe.DURATION}s cubic-bezier(${Qe.EASE.join(",")})`,
          opacity: "0"
        }) : tt(T, {
          transition: `opacity ${Qe.DURATION}s cubic-bezier(${Qe.EASE.join(",")})`,
          opacity: "1"
        }), n.update(() => {
          const M = Q(e);
          return v === null || !M ? null : M[v];
        });
      });
    }
    function f({ draggedDistance: g, closeDrawer: w, velocity: v, dismissible: y }) {
      const x = Q(i);
      if (x === void 0) return;
      const k = Q(h), T = Q(l), M = Q(r), D = Q(c), I = Q(e), C = Q(o), O = C === "bottom" || C === "right" ? (k ?? 0) - g : (k ?? 0) + g, E = T === x - 1, N = T === 0, A = g > 0;
      if (E && tt(M, {
        transition: `opacity ${Qe.DURATION}s cubic-bezier(${Qe.EASE.join(",")})`
      }), v > 2 && !A) {
        y ? w() : d(D[0]);
        return;
      }
      if (v > 2 && A && D && I) {
        d(D[I.length - 1]);
        return;
      }
      const R = D?.reduce((z, L) => typeof z != "number" || typeof L != "number" ? z : Math.abs(L - O) < Math.abs(z - O) ? L : z), B = yt(C) ? window.innerHeight : window.innerWidth;
      if (v > _m && Math.abs(g) < B * 0.4) {
        const z = A ? 1 : -1;
        if (z > 0 && Q(a) && I) {
          d(D[I.length - 1]);
          return;
        }
        if (N && z < 0 && y && w(), T === null) return;
        d(D[T + z]);
        return;
      }
      d(R);
    }
    function p({ draggedDistance: g }) {
      const w = Q(t), v = Q(h);
      if (v === null) return;
      const y = Q(c), x = Q(o), k = x === "bottom" || x === "right" ? v - g : v + g, T = y[y.length - 1];
      gh(x) && k < T || !gh(x) && k > T || tt(w, {
        transform: yt(x) ? `translate3d(0, ${k}px, 0)` : `translate3d(${k}px, 0, 0)`
      });
    }
    function m(g, w) {
      const v = Q(l), y = Q(c), x = Q(e), k = Q(i);
      if (!x || typeof v != "number" || !y || k === void 0) return null;
      const T = v === k - 1;
      if (v >= k && w) return 0;
      if (T && !w) return 1;
      if (!Q(u) && !T) return null;
      const D = T ? v + 1 : v - 1, I = T ? y[D] - y[D - 1] : y[D + 1] - y[D], C = g / Math.abs(I);
      return T ? 1 - C : C;
    }
    function b(g) {
      const w = Q(e), v = Q(c);
      w && g === v.length - 1 && s.set(/* @__PURE__ */ new Date());
    }
    return {
      isLastSnapPoint: a,
      shouldFade: u,
      getPercentageDragged: m,
      activeSnapPointIndex: l,
      onRelease: f,
      onDrag: p,
      snapPointsOffset: c
    };
  }
  function kE() {
    return tc(/^Mac/);
  }
  function SE() {
    return tc(/^iPhone/);
  }
  function TE() {
    return tc(/^iPad/) || kE() && navigator.maxTouchPoints > 1;
  }
  function Fm() {
    return SE() || TE();
  }
  function tc(n) {
    return typeof window < "u" && window.navigator != null ? n.test(window.navigator.platform) : void 0;
  }
  const xu = typeof document < "u" && window.visualViewport;
  function bh(n) {
    const e = window.getComputedStyle(n);
    return /(auto|scroll)/.test(e.overflow + e.overflowX + e.overflowY);
  }
  function zm(n) {
    for (bh(n) && (n = n.parentElement); n && !bh(n); ) n = n.parentElement;
    return n || document.scrollingElement || document.documentElement;
  }
  let _s = 0, ku;
  function EE() {
    return typeof document > "u" ? () => {
    } : (_s++, _s === 1 && (Fm() ? ku = ME() : ku = AE()), () => {
      _s--, _s === 0 && ku();
    });
  }
  function CE(n) {
    const e = n.getBoundingClientRect().left;
    return Math.round(e) + n.scrollLeft ? "paddingLeft" : "paddingRight";
  }
  function OE(n, e, t) {
    if (!n) return;
    const r = n.style.getPropertyValue(e);
    return n.style.setProperty(e, t), () => {
      r ? n.style.setProperty(e, r) : n.style.removeProperty(e);
    };
  }
  function AE() {
    if (typeof document > "u") return () => {
    };
    const n = document.defaultView ?? window, { documentElement: e, body: t } = document, r = n.innerWidth - e.clientWidth, i = () => OE(e, "--scrollbar-width", `${r}px`), s = CE(e), o = n.getComputedStyle(t)[s];
    return ko(i(), So(t, s, `calc(${o} + ${r}px)`), So(t, "overflow", "hidden"));
  }
  function ME() {
    let n, e = 0;
    const { documentElement: t, body: r, activeElement: i } = document;
    function s(p) {
      n = zm(p.target), !(n === t && n === r) && (e = p.changedTouches[0].pageY);
    }
    function o(p) {
      if (!n || n === t || n === r) {
        p.preventDefault();
        return;
      }
      const m = p.changedTouches[0].pageY, b = n.scrollTop, g = n.scrollHeight - n.clientHeight;
      g !== 0 && ((b <= 0 && m > e || b >= g && m < e) && p.preventDefault(), e = m);
    }
    function a(p) {
      const m = p.target;
      xo(m) && m !== i && (p.preventDefault(), m.style.transform = "translateY(-2000px)", m.focus(), requestAnimationFrame(() => {
        m.style.transform = "";
      }));
    }
    function u(p) {
      const m = p.target;
      xo(m) && (m.style.transform = "translateY(-2000px)", requestAnimationFrame(() => {
        m.style.transform = "", xu && (xu.height < window.innerHeight ? requestAnimationFrame(() => {
          yh(m);
        }) : xu.addEventListener("resize", () => yh(m), {
          once: true
        }));
      }));
    }
    function l() {
      window.scrollTo(0, 0);
    }
    const c = window.pageXOffset, h = window.pageYOffset, d = ko(So(t, "paddingRight", `${window.innerWidth - t.clientWidth}px`), So(t, "overflow", "hidden"));
    window.scrollTo(0, 0);
    const f = ko(er(document, "touchstart", s, {
      passive: false,
      capture: true
    }), er(document, "touchmove", o, {
      passive: false,
      capture: true
    }), er(document, "touchend", a, {
      passive: false,
      capture: true
    }), er(document, "focus", u, true), er(window, "scroll", l));
    return () => {
      d(), f(), window.scrollTo(c, h);
    };
  }
  function So(n, e, t) {
    const r = n.style[e];
    return n.style[e] = t, () => {
      n.style[e] = r;
    };
  }
  function yh(n) {
    const { documentElement: e, body: t, scrollingElement: r } = document, i = r || e;
    for (; n && n !== i; ) {
      const s = zm(n);
      if (s !== e && s !== t && s !== n) {
        const o = s.getBoundingClientRect().top, a = n.getBoundingClientRect().top, u = n.getBoundingClientRect().bottom, l = s.getBoundingClientRect().bottom;
        u > l && (s.scrollTop += a - o);
      }
      n = s.parentElement;
    }
  }
  const NE = Nr(void 0, (n) => {
    function e(r) {
      r && r.key === "Escape" && n(r), n(void 0);
    }
    return er(document, "keydown", e, {
      passive: false
    });
  });
  function PE(n, e) {
    let t = nl;
    function r(i) {
      t(), t = ko(NE.subscribe((s) => {
        if (!s) return;
        const o = s.target;
        !DE(o) || o.closest("[data-escapee]") !== n || (s.preventDefault(), i(s));
      })), n.setAttribute("data-escapee", "");
    }
    return r(e), () => {
      t(), n.removeAttribute("data-escapee");
    };
  }
  function DE(n) {
    return n instanceof HTMLElement;
  }
  let Gn = null;
  function IE({ isOpen: n, modal: e, nested: t, hasBeenOpened: r }) {
    const i = bt(typeof window < "u" ? window.location.href : "");
    let s = 0;
    function o(u) {
      if (!(Gn === null && u)) return;
      Gn = {
        position: document.body.style.position,
        top: document.body.style.top,
        left: document.body.style.left,
        height: document.body.style.height
      };
      const { scrollX: l, innerHeight: c } = window;
      document.body.style.setProperty("position", "fixed", "important"), document.body.style.top = `${-s}px`, document.body.style.left = `${-l}px`, document.body.style.right = "0px", document.body.style.height = "auto", setTimeout(() => requestAnimationFrame(() => {
        const h = c - window.innerHeight;
        h && s >= c && (document.body.style.top = `${-(s + h)}px`);
      }), 300);
    }
    function a() {
      if (Gn === null) return;
      const u = Q(i), l = -parseInt(document.body.style.top, 10), c = -parseInt(document.body.style.left, 10);
      document.body.style.position = Gn.position, document.body.style.top = Gn.top, document.body.style.left = Gn.left, document.body.style.height = Gn.height, document.body.style.right = "unset", requestAnimationFrame(() => {
        if (u !== window.location.href) {
          i.set(window.location.href);
          return;
        }
        window.scrollTo(c, l);
      }), Gn = null;
    }
    return Ao(() => {
      function u() {
        s = window.scrollY;
      }
      return u(), er(window, "scroll", u), () => {
      };
    }), on([
      n,
      i
    ], ([u, l]) => {
      typeof document > "u" || Q(t) || !Q(r) || (u ? (o(u), Q(e) || setTimeout(() => {
        a();
      }, 500)) : a());
    }), {
      restorePositionSetting: a
    };
  }
  const RE = 0.25, _E = 100, vh = 8, Ls = 16, jm = 26, wh = "vaul-dragging", Su = bt([]), LE = {
    closeThreshold: RE,
    shouldScaleBackground: true,
    scrollLockTimeout: _E,
    onDrag: void 0,
    onRelease: void 0,
    snapPoints: void 0,
    fadeFromIndex: void 0,
    defaultActiveSnapPoint: void 0,
    onActiveSnapPointChange: void 0,
    defaultOpen: false,
    onOpenChange: void 0,
    fixed: void 0,
    dismissible: true,
    modal: true,
    nested: false,
    onClose: void 0,
    direction: "bottom"
  }, BE = [
    "defaultOpen",
    "onOpenChange",
    "defaultActiveSnapPoint",
    "onActiveSnapPointChange",
    "onDrag",
    "onRelease",
    "onClose"
  ];
  function FE(n) {
    const { snapPoints: e, fadeFromIndex: t = e && e.length - 1, ...r } = {
      ...LE,
      ...gE(n)
    }, i = pE(mE({
      ...r,
      snapPoints: e,
      fadeFromIndex: t
    }, ...BE)), s = bt(void 0), { onDrag: o, onRelease: a, onClose: u, onOpenChange: l } = r, { snapPoints: c, fadeFromIndex: h, fixed: d, dismissible: f, modal: p, nested: m, shouldScaleBackground: b, scrollLockTimeout: g, closeThreshold: w, direction: v } = i, y = bt(r.defaultOpen), x = mh(y, r.onOpenChange), k = bt(false), T = bt(false), M = bt(false), D = bt(void 0), I = bt(null), C = bt(false), O = bt(void 0), E = bt(void 0);
    let N = false, A = null, R = false, B = 0, z = null, L = null, V = false, K = Q(O)?.getBoundingClientRect().height || 0, pe = 0, H = 0, ue = null;
    const ne = mh(bt(r.defaultActiveSnapPoint), r.onActiveSnapPointChange), { activeSnapPointIndex: ce, getPercentageDragged: Z, onDrag: de, onRelease: _, shouldFade: W, snapPointsOffset: P } = xE({
      snapPoints: c,
      activeSnapPoint: ne,
      drawerRef: O,
      fadeFromIndex: h,
      overlayRef: D,
      openTime: I,
      direction: v
    }), q = an([
      P
    ], ([Y]) => (ee = "") => {
      if (Y && Y.length > 0) {
        const ie = bE({
          "--snap-point-height": `${Y[0]}px`
        });
        return ee + ie;
      }
      return ee;
    });
    on([
      O
    ], ([Y]) => {
      Y && E.set(Y.id);
    }), on([
      x
    ], ([Y]) => {
      wE(100).then(() => {
        const ee = Q(E);
        Y && ee ? Su.update((ie) => (ie.includes(ee) || ie.push(ee), ie)) : Su.update((ie) => ie.filter((fe) => fe !== fe));
      });
    }), on([
      x
    ], ([Y]) => {
      if (!Y && Q(b)) {
        const ee = setTimeout(() => {
          Mi(document.body, "background");
        }, 200);
        return () => clearTimeout(ee);
      }
    }), on([
      x
    ], ([Y]) => {
      let ee = () => {
      };
      return Y && (ee = EE()), ee;
    });
    const { restorePositionSetting: j } = IE({
      isOpen: x,
      modal: p,
      nested: m,
      hasBeenOpened: k
    });
    on([
      O
    ], ([Y]) => {
      let ee = nl;
      return Y && (ee = PE(Y, () => {
        Ue(true);
      })), () => {
        ee();
      };
    });
    function U() {
      R || (k.set(true), x.set(true));
    }
    function ke(Y) {
      const ee = Q(O);
      !Q(f) && !Q(c) || ee && !ee.contains(Y.target) || (K = ee?.getBoundingClientRect().height || 0, N = true, A = /* @__PURE__ */ new Date(), Fm() && window.addEventListener("touchend", () => V = false, {
        once: true
      }), Y.target.setPointerCapture(Y.pointerId), B = yt(Q(v)) ? Y.screenY : Y.screenX);
    }
    function Ee(Y, ee) {
      const ie = Q(O);
      let fe = Y;
      const he = window.getSelection()?.toString(), le = Q(v), Ce = ie ? Rs(ie, le) : null, We = /* @__PURE__ */ new Date();
      if (fe.hasAttribute("data-vaul-no-drag") || fe.closest("[data-vaul-no-drag]")) return false;
      const Ve = Q(I);
      if (Ve && We.getTime() - Ve.getTime() < 500) return false;
      if (Ce !== null && (le === "bottom" || le === "right" ? Ce > 0 : Ce < 0) || Ce !== null && Ce > 0) return true;
      if (he && he.length > 0) return false;
      const et = Q(g);
      if (L && We.getTime() - L.getTime() < et && Ce === 0 || ee) return L = We, false;
      for (; fe; ) {
        if (fe.scrollHeight > fe.clientHeight) {
          if (fe.scrollTop !== 0) return L = /* @__PURE__ */ new Date(), false;
          if (fe.getAttribute("role") === "dialog") return true;
        }
        fe = fe.parentNode;
      }
      return true;
    }
    function xe(Y) {
      const ee = Q(O);
      if (!ee || !N) return;
      const ie = Q(v), fe = kh(ie), he = xh(B, ie, Y) * fe, le = he > 0, Ce = Q(ce), We = Q(c);
      if (We && Ce === 0 && !Q(f) || !V && !Ee(Y.target, le)) return;
      ee.classList.add(wh), V = true, tt(ee, {
        transition: "none"
      });
      const Ve = Q(D);
      if (tt(Ve, {
        transition: "none"
      }), We && de({
        draggedDistance: he
      }), le && !We) {
        const Nn = zE(he), ls = Math.min(Nn * -1, 0) * fe;
        tt(ee, {
          transform: yt(ie) ? `translate3d(0, ${ls}px, 0)` : `translate3d(${ls}px, 0, 0)`
        });
        return;
      }
      const et = Math.abs(he);
      let ft = et / K;
      const Qt = Z(et, le);
      Qt !== null && (ft = Qt);
      const Zt = 1 - ft, Mn = Q(h);
      (Q(W) || Mn && Ce === Mn - 1) && (o?.(Y, ft), tt(Ve, {
        opacity: `${Zt}`,
        transition: "none"
      }, true));
      const yi = document.querySelector("[data-vaul-drawer-wrapper]");
      if (yi && Ve && Q(b)) {
        const Nn = Math.min(Xr() + ft * (1 - Xr()), 1), ls = 8 - ft * 8, ic = Math.max(0, 14 - ft * 14);
        tt(yi, {
          borderRadius: `${ls}px`,
          transform: yt(ie) ? `scale(${Nn}) translate3d(0, ${ic}px, 0)` : `scale(${Nn}) translate3d(${ic}px, 0, 0)`,
          transition: "none"
        }, true);
      }
      if (!We) {
        const Nn = et * fe;
        tt(ee, {
          transform: yt(ie) ? `translate3d(0, ${Nn}px, 0)` : `translate3d(${Nn}px, 0, 0)`
        });
      }
    }
    function ve(Y, ee = "black") {
      const ie = document.querySelector("[data-vaul-drawer-wrapper]");
      if (!ie || !Q(b)) return;
      const fe = Q(v);
      Y ? (tt(document.body, {
        background: document.body.style.backgroundColor || document.body.style.background
      }), tt(document.body, {
        background: ee
      }, true), tt(ie, {
        borderRadius: `${vh}px`,
        overflow: "hidden",
        ...yt(fe) ? {
          transform: `scale(${Xr()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,
          transformOrigin: "top"
        } : {
          transform: `scale(${Xr()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,
          transformOrigin: "left"
        },
        transitionProperty: "transform, border-radius",
        transitionDuration: `${Qe.DURATION}s`,
        transitionTimingFunction: `cubic-bezier(${Qe.EASE.join(",")})`
      })) : (Mi(ie, "overflow"), Mi(ie, "transform"), Mi(ie, "borderRadius"), tt(ie, {
        transitionProperty: "transform, border-radius",
        transitionDuration: `${Qe.DURATION}s`,
        transitionTimingFunction: `cubic-bezier(${Qe.EASE.join(",")})`
      }));
    }
    on([
      ce,
      c,
      P
    ], ([Y, ee, ie]) => {
      function fe() {
        const le = Q(O);
        if (!le) return;
        const Ce = Q(C), We = document.activeElement;
        if (xo(We) || Ce) {
          const Ve = window.visualViewport?.height || 0;
          let et = window.innerHeight - Ve;
          const ft = le.getBoundingClientRect().height || 0;
          H || (H = ft);
          const Qt = le.getBoundingClientRect().top;
          if (Math.abs(pe - et) > 60 && C.set(!Ce), ee && ee.length > 0 && ie && Y) {
            const Zt = ie[Y] || 0;
            et += Zt;
          }
          if (pe = et, ft > Ve || Ce) {
            const Zt = le.getBoundingClientRect().height;
            let Mn = Zt;
            Zt > Ve && (Mn = Ve - jm), Q(d) ? le.style.height = `${Zt - Math.max(et, 0)}px` : le.style.height = `${Math.max(Mn, Ve - Qt)}px`;
          } else le.style.height = `${H}px`;
          ee && ee.length > 0 && !Ce ? le.style.bottom = "0px" : le.style.bottom = `${Math.max(et, 0)}px`;
        }
      }
      let he = nl;
      return window.visualViewport && (he = er(window.visualViewport, "resize", fe)), () => {
        he();
      };
    });
    function Ue(Y = false) {
      if (R) return;
      const ee = Q(O);
      if (!ee) return;
      const ie = Q(v);
      u?.(), tt(ee, {
        transform: yt(ie) ? `translate3d(0, ${ie === "bottom" ? "100%" : "-100%"}, 0)` : `translate3d(${ie === "right" ? "100%" : "-100%"}, 0, 0)`,
        transition: `transform ${Qe.DURATION}s cubic-bezier(${Qe.EASE.join(",")})`
      }), tt(Q(D), {
        opacity: "0",
        transition: `opacity ${Qe.DURATION}s cubic-bezier(${Qe.EASE.join(",")})`
      }), ve(false), R = true, setTimeout(() => {
        T.set(false), x.set(false), R = false, Y && Q(s)?.focus();
      }, 300);
      const fe = Q(c);
      setTimeout(() => {
        Mi(document.documentElement, "scrollBehavior"), fe && ne.set(fe[0]);
      }, Qe.DURATION * 1e3);
    }
    on([
      x
    ], ([Y]) => {
      Y ? k.set(true) : Ue();
    });
    function ge() {
      const Y = Q(O);
      if (!Y) return;
      const ee = Q(D), ie = document.querySelector("[data-vaul-drawer-wrapper]"), fe = Q(v), he = Rs(Y, fe);
      tt(Y, {
        transform: "translate3d(0, 0, 0)",
        transition: `transform ${Qe.DURATION}s cubic-bezier(${Qe.EASE.join(",")})`
      }), tt(ee, {
        transition: `opacity ${Qe.DURATION}s cubic-bezier(${Qe.EASE.join(",")})`,
        opacity: "1"
      });
      const le = Q(b), Ce = Q(x);
      le && he && he > 0 && Ce && tt(ie, {
        borderRadius: `${vh}px`,
        overflow: "hidden",
        ...yt(fe) ? {
          transform: `scale(${Xr()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,
          transformOrigin: "top"
        } : {
          transform: `scale(${Xr()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,
          transformOrigin: "left"
        },
        transitionProperty: "transform, border-radius",
        transitionDuration: `${Qe.DURATION}s`,
        transitionTimingFunction: `cubic-bezier(${Qe.EASE.join(",")})`
      }, true);
    }
    function me(Y) {
      const ee = Q(O);
      if (!N || !ee) return;
      V && xo(Y.target) && Y.target.blur(), ee.classList.remove(wh), V = false, N = false, z = /* @__PURE__ */ new Date();
      const ie = Q(v), fe = Rs(ee, ie);
      if (Y.target && !Ee(Y.target, false) || !fe || Number.isNaN(fe) || A === null) return;
      const he = z.getTime() - A.getTime(), le = xh(B, ie, Y), Ce = Math.abs(le) / he;
      if (Ce > 0.05 && (M.set(true), setTimeout(() => {
        M.set(false);
      }, 200)), Q(c)) {
        _({
          draggedDistance: le * kh(ie),
          closeDrawer: Ue,
          velocity: Ce,
          dismissible: Q(f)
        }), a?.(Y, true);
        return;
      }
      if (ie === "bottom" || ie === "right" ? le > 0 : le < 0) {
        ge(), a?.(Y, true);
        return;
      }
      if (Ce > _m) {
        Ue(), a?.(Y, false);
        return;
      }
      const We = Math.min(Q(O)?.getBoundingClientRect().height ?? 0, window.innerHeight);
      if (fe >= We * Q(w)) {
        Ue(), a?.(Y, false);
        return;
      }
      a?.(Y, true), ge();
    }
    on([
      x
    ], ([Y]) => {
      Y && (vE && tt(document.documentElement, {
        scrollBehavior: "auto"
      }), I.set(/* @__PURE__ */ new Date()), ve(true, n.backgroundColor));
    }), on([
      T
    ], ([Y]) => {
      if (!Y) return;
      const ee = Q(O);
      if (!ee) return;
      ee.querySelectorAll("*").forEach((fe) => {
        const he = fe;
        (he.scrollHeight > he.clientHeight || he.scrollWidth > he.clientWidth) && he.classList.add("vaul-scrollable");
      });
    });
    function Xe(Y) {
      const ee = Q(O), ie = Y ? (window.innerWidth - Ls) / window.innerWidth : 1, fe = Y ? -16 : 0;
      ue && window.clearTimeout(ue), tt(ee, {
        transition: `transform ${Qe.DURATION}s cubic-bezier(${Qe.EASE.join(",")})`,
        transform: `scale(${ie}) translate3d(0, ${fe}px, 0)`
      }), !Y && ee && (ue = setTimeout(() => {
        const he = Q(v), le = Rs(ee, he);
        tt(ee, {
          transition: "none",
          transform: yt(he) ? `translate3d(0, ${le}px, 0)` : `translate3d(${le}px, 0, 0)`
        });
      }, 500));
    }
    function He(Y, ee) {
      if (ee < 0) return;
      const ie = (window.innerWidth - Ls) / window.innerWidth, fe = ie + ee * (1 - ie), he = -16 + ee * Ls, le = Q(v);
      tt(Q(O), {
        transform: yt(le) ? `scale(${fe}) translate3d(0, ${he}px, 0)` : `scale(${fe}) translate3d(${he}px, 0, 0)`,
        transition: "none"
      });
    }
    function $e(Y, ee) {
      const ie = Q(v), fe = yt(ie) ? window.innerHeight : window.innerWidth, he = ee ? (fe - Ls) / fe : 1, le = ee ? -16 : 0;
      ee && tt(Q(O), {
        transition: `transform ${Qe.DURATION}s cubic-bezier(${Qe.EASE.join(",")})`,
        transform: yt(ie) ? `scale(${he}) translate3d(0, ${le}px, 0)` : `scale(${he}) translate3d(${le}px, 0, 0)`
      });
    }
    return {
      states: {
        isOpen: x,
        hasBeenOpened: k,
        snapPoints: c,
        activeSnapPoint: ne,
        snapPointsOffset: P,
        keyboardIsOpen: C,
        shouldFade: W,
        visible: T,
        drawerId: E,
        openDrawerIds: Su
      },
      helpers: {
        getContentStyle: q
      },
      methods: {
        closeDrawer: Ue,
        onOpenChange: l,
        onPress: ke,
        onRelease: me,
        onDrag: xe,
        scaleBackground: ve,
        onNestedDrag: He,
        onNestedOpenChange: Xe,
        onNestedRelease: $e,
        restorePositionSetting: j,
        openDrawer: U
      },
      refs: {
        drawerRef: O,
        overlayRef: D,
        triggerRef: s
      },
      options: i
    };
  }
  function zE(n) {
    return 8 * (Math.log(n + 1) - 2);
  }
  function Xr() {
    return (window.innerWidth - jm) / window.innerWidth;
  }
  function xh(n, e, t) {
    return t.type.startsWith("touch") ? qE(n, e, t) : jE(n, e, t);
  }
  function jE(n, e, t) {
    return n - (yt(e) ? t.screenY : t.screenX);
  }
  function qE(n, e, t) {
    return n - (yt(e) ? t.changedTouches[0].screenY : t.changedTouches[0].screenX);
  }
  function kh(n) {
    return n === "bottom" || n === "right" ? 1 : -1;
  }
  const qm = Symbol("VAUL_ROOT");
  function $E(n = {}) {
    const e = FE(n), t = fE(e.options);
    return il(qm, {
      ...e,
      updateOption: t
    }), {
      ...e,
      updateOption: t
    };
  }
  function us() {
    return sn(qm);
  }
  function VE(n, e) {
    const t = gt(e, [
      "children",
      "$$slots",
      "$$events",
      "$$legacy"
    ]), r = gt(t, [
      "open",
      "onOpenChange",
      "closeThreshold",
      "scrollLockTimeout",
      "snapPoints",
      "fadeFromIndex",
      "openFocus",
      "onOutsideClick",
      "closeOnOutsideClick",
      "backgroundColor",
      "nested",
      "shouldScaleBackground",
      "activeSnapPoint",
      "onActiveSnapPointChange",
      "onRelease",
      "onDrag",
      "onClose",
      "dismissible",
      "direction"
    ]);
    Re(e, false);
    const [i, s] = An(), o = () => dt(R, "$isOpen", i), a = () => dt(O, "$keyboardIsOpen", i), u = () => dt(L, "$localDismissible", i);
    let l = $(e, "open", 12, false), c = $(e, "onOpenChange", 24, () => {
    }), h = $(e, "closeThreshold", 24, () => {
    }), d = $(e, "scrollLockTimeout", 24, () => {
    }), f = $(e, "snapPoints", 24, () => {
    }), p = $(e, "fadeFromIndex", 24, () => {
    }), m = $(e, "openFocus", 24, () => {
    }), b = $(e, "onOutsideClick", 24, () => {
    }), g = $(e, "closeOnOutsideClick", 8, true), w = $(e, "backgroundColor", 8, "black"), v = $(e, "nested", 8, false), y = $(e, "shouldScaleBackground", 8, false), x = $(e, "activeSnapPoint", 28, () => {
    }), k = $(e, "onActiveSnapPointChange", 24, () => {
    }), T = $(e, "onRelease", 24, () => {
    }), M = $(e, "onDrag", 24, () => {
    }), D = $(e, "onClose", 24, () => {
    }), I = $(e, "dismissible", 24, () => {
    }), C = $(e, "direction", 8, "bottom");
    const { states: { keyboardIsOpen: O, activeSnapPoint: E, drawerId: N, openDrawerIds: A, isOpen: R }, methods: { closeDrawer: B, openDrawer: z }, options: { dismissible: L }, updateOption: V } = $E({
      defaultOpen: l(),
      defaultActiveSnapPoint: x(),
      onOpenChange: ({ next: K }) => (l() !== K && (c()?.(K), l(K)), K),
      onActiveSnapPointChange: ({ next: K }) => {
        if (K === void 0 && f() && x() !== K) {
          const pe = f()[0];
          return k()?.(pe), x(pe), pe;
        }
        return x() !== K && (k()?.(K), x(K)), K;
      },
      closeThreshold: h(),
      scrollLockTimeout: d(),
      snapPoints: f(),
      fadeFromIndex: p(),
      nested: v(),
      onDrag: M(),
      onClose: D(),
      onRelease: T(),
      shouldScaleBackground: y(),
      backgroundColor: w(),
      dismissible: I(),
      direction: C()
    });
    ze(() => nt(x()), () => {
      x() !== void 0 && E.set(x());
    }), ze(() => nt(h()), () => {
      V("closeThreshold", h());
    }), ze(() => nt(d()), () => {
      V("scrollLockTimeout", d());
    }), ze(() => nt(f()), () => {
      V("snapPoints", f());
    }), ze(() => nt(p()), () => {
      V("fadeFromIndex", p());
    }), ze(() => nt(m()), () => {
      V("openFocus", m());
    }), ze(() => nt(y()), () => {
      V("shouldScaleBackground", y());
    }), ze(() => nt(w()), () => {
      V("backgroundColor", w());
    }), ze(() => nt(I()), () => {
      V("dismissible", I());
    }), ze(() => nt(C()), () => {
      V("direction", C());
    }), ze(() => (nt(l()), o()), () => {
      l() && !o() && z();
    }), ze(() => (nt(l()), o()), () => {
      !l() && o() && B();
    }), fn(), $t(), G6(n, it({
      get closeOnOutsideClick() {
        return g();
      },
      closeOnEscape: false,
      preventScroll: false,
      onOpenChange: (K) => {
        c()?.(K), K ? K && z() : B();
      },
      onOutsideClick: (K) => {
        if (!g() || (b()?.(K), K?.defaultPrevented) || (a() && O.set(false), K.preventDefault(), !u())) return;
        const pe = Q(A);
        pe[pe.length - 1] === Q(N) && (c()?.(false), B());
      }
    }, () => r, {
      get open() {
        return l();
      },
      set open(K) {
        l(K);
      },
      children: (K, pe) => {
        var H = se(), ue = J(H);
        lt(ue, e, "default", {}), F(K, H);
      },
      $$slots: {
        default: true
      },
      $$legacy: true
    })), _e(), s();
  }
  function HE(n, e) {
    Re(e, false);
    const { states: { visible: t }, methods: { scaleBackground: r, restorePositionSetting: i } } = us();
    Ao(() => (t.set(true), () => {
      r(false), i();
    })), $t(), _e();
  }
  var WE = ae("<!> <!>", 1);
  function UE(n, e) {
    const t = gt(e, [
      "children",
      "$$slots",
      "$$events",
      "$$legacy"
    ]), r = gt(t, [
      "style"
    ]);
    Re(e, false);
    const [i, s] = An(), o = () => dt(c, "$drawerRef", i), a = () => dt(d, "$getContentStyle", i), u = () => dt(b, "$direction", i), l = () => dt(h, "$visible", i), { refs: { drawerRef: c }, states: { visible: h }, helpers: { getContentStyle: d }, methods: { onPress: f, onDrag: p, onRelease: m }, options: { direction: b } } = us();
    let g = $(e, "style", 8, "");
    $t();
    const w = cn(() => a()(g())), v = cn(() => l() ? "true" : "false");
    nE(n, it({
      get style() {
        return S(w);
      },
      "data-vaul-drawer": "",
      get "data-vaul-drawer-direction"() {
        return u();
      },
      get "data-vaul-drawer-visible"() {
        return S(v);
      }
    }, () => r, {
      get el() {
        return Ph(), o();
      },
      set el(y) {
        Nh(c, y);
      },
      $$events: {
        pointerdown: (y) => {
          f(y);
        },
        pointerup: (y) => {
          m(y);
        },
        pointermove: (y) => {
          p(y);
        },
        touchend: (y) => {
          m(y);
        },
        touchmove: (y) => {
          p(y);
        }
      },
      children: (y, x) => {
        var k = WE(), T = J(k);
        HE(T, {});
        var M = je(T, 2);
        lt(M, e, "default", {}), F(y, k);
      },
      $$slots: {
        default: true
      },
      $$legacy: true
    })), _e(), s();
  }
  function GE(n, e) {
    const t = gt(e, [
      "children",
      "$$slots",
      "$$events",
      "$$legacy"
    ]), r = gt(t, []);
    Re(e, false);
    const [i, s] = An(), o = () => dt(m, "$snapPoints", i), a = () => dt(d, "$overlayRef", i), u = () => dt(p, "$visible", i), l = () => dt(f, "$isOpen", i), c = () => dt(b, "$shouldFade", i), h = $n(), { refs: { overlayRef: d }, states: { isOpen: f, visible: p, snapPoints: m, shouldFade: b }, methods: { onRelease: g } } = us();
    ze(() => o(), () => {
      te(h, o() && o().length > 0);
    }), fn(), $t();
    const w = cn(() => u() ? "true" : "false"), v = cn(() => l() && S(h) ? "true" : "false"), y = cn(() => l() && c() ? "true" : "false");
    uE(n, it({
      get "data-vaul-drawer-visible"() {
        return S(w);
      },
      "data-vaul-overlay": "",
      get "data-vaul-snap-points"() {
        return S(v);
      },
      get "data-vaul-snap-points-overlay"() {
        return S(y);
      }
    }, () => r, {
      get el() {
        return Ph(), a();
      },
      set el(x) {
        Nh(d, x);
      },
      $$events: {
        mouseup: g
      },
      $$legacy: true
    })), _e(), s();
  }
  function KE(n, e) {
    Re(e, false);
    const t = $n(), r = $n();
    let i = $(e, "meltBuilder", 8);
    const { refs: { triggerRef: s } } = us(), o = (l) => (s.set(l), S(t)(l));
    ze(() => (S(t), S(r), nt(i())), () => {
      ((l) => (te(t, l.action), te(r, Xm(l, [
        "action"
      ]))))(i());
    }), ze(() => S(r), () => {
      Object.assign(S(r), {
        action: o
      });
    }), fn(), $t();
    var a = se(), u = J(a);
    lt(u, e, "default", {
      get newBuilder() {
        return S(r);
      }
    }), F(n, a), _e();
  }
  function JE(n, e) {
    const t = gt(e, [
      "children",
      "$$slots",
      "$$events",
      "$$legacy"
    ]), r = gt(t, [
      "el",
      "asChild"
    ]);
    Re(e, false);
    const { refs: { triggerRef: i } } = us();
    let s = $(e, "el", 28, () => {
    }), o = $(e, "asChild", 8, false);
    ze(() => nt(s()), () => {
      s() && i.set(s());
    }), fn(), $t();
    var a = se(), u = J(a);
    {
      var l = (h) => {
        ph(h, it({
          get asChild() {
            return o();
          }
        }, () => r, {
          get el() {
            return s();
          },
          set el(d) {
            s(d);
          },
          $$events: {
            click(d) {
              Ae.call(this, e, d);
            },
            keydown(d) {
              Ae.call(this, e, d);
            }
          },
          children: na,
          $$slots: {
            default: (d, f) => {
              const p = cn(() => f.builder);
              KE(d, {
                get meltBuilder() {
                  return S(p);
                },
                children: na,
                $$slots: {
                  default: (m, b) => {
                    const g = cn(() => b.newBuilder);
                    var w = se(), v = J(w);
                    lt(v, e, "default", {
                      get builder() {
                        return S(g);
                      }
                    }), F(m, w);
                  }
                }
              });
            }
          },
          $$legacy: true
        }));
      }, c = (h) => {
        ph(h, it(() => r, {
          get el() {
            return s();
          },
          set el(d) {
            s(d);
          },
          $$events: {
            click(d) {
              Ae.call(this, e, d);
            },
            keydown(d) {
              Ae.call(this, e, d);
            }
          },
          children: na,
          $$slots: {
            default: (d, f) => {
              const p = cn(() => f.builder);
              var m = se(), b = J(m);
              lt(b, e, "default", {
                get builder() {
                  return S(p);
                }
              }), F(d, m);
            }
          },
          $$legacy: true
        }));
      };
      be(u, (h) => {
        o() ? h(l) : h(c, false);
      });
    }
    F(n, a), _e();
  }
  const YE = Y6, XE = K6, QE = dE;
  var ZE = ae('<div class="bg-base-300 h-fit min-h-32 rounded-t-xl px-4 py-8"><!> <!> <!></div>'), eC = ae("<!> <!>", 1), tC = ae("<!> <!>", 1);
  function nC(n, e) {
    Re(e, true);
    let t = $(e, "isDrawerOpen", 15, false);
    var r = se(), i = J(r);
    Le(i, () => VE, (s, o) => {
      o(s, {
        get open() {
          return t();
        },
        set open(a) {
          t(a);
        },
        children: (a, u) => {
          var l = tC(), c = J(l);
          {
            var h = (f) => {
              var p = se(), m = J(p);
              Le(m, () => JE, (b, g) => {
                g(b, {
                  children: (w, v) => {
                    var y = se(), x = J(y);
                    rt(x, () => e.drawerTrigger ?? pt), F(w, y);
                  },
                  $$slots: {
                    default: true
                  }
                });
              }), F(f, p);
            };
            be(c, (f) => {
              e.drawerTrigger && f(h);
            });
          }
          var d = je(c, 2);
          Le(d, () => YE, (f, p) => {
            p(f, {
              children: (m, b) => {
                var g = eC(), w = J(g);
                Le(w, () => GE, (y, x) => {
                  x(y, {
                    class: "fixed inset-0 bg-black/40"
                  });
                });
                var v = je(w, 2);
                Le(v, () => UE, (y, x) => {
                  x(y, {
                    class: "flex flex-col mt-24 fixed bottom-0 left-0 right-0",
                    children: (k, T) => {
                      var M = ZE(), D = Se(M);
                      {
                        var I = (N) => {
                          var A = se(), R = J(A);
                          Le(R, () => XE, (B, z) => {
                            z(B, {
                              children: (L, V) => {
                                kn();
                                var K = Qn();
                                qe(() => ir(K, e.title)), F(L, K);
                              },
                              $$slots: {
                                default: true
                              }
                            });
                          }), F(N, A);
                        };
                        be(D, (N) => {
                          e.title && N(I);
                        });
                      }
                      var C = je(D, 2);
                      {
                        var O = (N) => {
                          var A = se(), R = J(A);
                          Le(R, () => QE, (B, z) => {
                            z(B, {
                              children: (L, V) => {
                                kn();
                                var K = Qn();
                                qe(() => ir(K, e.description)), F(L, K);
                              },
                              $$slots: {
                                default: true
                              }
                            });
                          }), F(N, A);
                        };
                        be(C, (N) => {
                          e.description && N(O);
                        });
                      }
                      var E = je(C, 2);
                      rt(E, () => e.children), we(M), F(k, M);
                    },
                    $$slots: {
                      default: true
                    }
                  });
                }), F(m, g);
              },
              $$slots: {
                default: true
              }
            });
          }), F(a, l);
        },
        $$slots: {
          default: true
        }
      });
    }), F(n, r), _e();
  }
  const Tu = (n, e = pt) => {
    var t = kC();
    const r = X(() => lg(e())), i = X(() => b3(S(r)) ? "Today" : Uf(S(r), "P"));
    var s = Se(t);
    we(t), qe((o) => ir(s, `${S(i) ?? ""}, ${o ?? ""}`), [
      () => Uf(S(r), "pp")
    ]), F(n, t);
  };
  var rC = ae('<section class="flex items-center gap-2 flex-wrap w-fit"><!></section> <p class="text-sm italic prose-invert prose min-w-0 max-w-full overflow-hidden text-ellipsis"><!></p>', 1), iC = ae('<!> <p class="text-sm italic prose-invert chat min-w-0 max-w-full overflow-hidden text-ellipsis"><!></p> <!>', 1), sC = ae('<!> <div class="flex items-start gap-4"><!></div>', 1), oC = ae('<!> <div class="flex flex-col gap-4"><!></div>', 1), aC = ae('<img class="max-w-md max-h-64 rounded-lg object-cover" loading="lazy">'), uC = ae('<div class="flex flex-wrap gap-2 mt-2"></div>'), lC = ae('<section class="flex items-center gap-2 flex-wrap w-fit"><a target="_blank" class="text-primary hover:underline"><h5 class="font-bold"> </h5></a> <!></section> <span class="prose select-text"><!></span> <!>', 1), cC = ae('<!> <div class="flex gap-4"><a target="_blank"><!></a> <!></div>', 1), dC = ae("<emoji-picker></emoji-picker>", 2), fC = ae("<!> <!>", 1), hC = ae("<!> Reply", 1), pC = ae("<!> Delete", 1), mC = ae('<div class="join join-vertical w-full"><!> <!></div>'), gC = ae('<div class="flex gap-4 justify-center mb-4"><!> <!> <!></div> <!>', 1), bC = ae("<emoji-picker></emoji-picker>", 2), yC = ae("<!> <!>", 1), vC = ae("<!> <!> <!> <!> <!>", 1), wC = ae('<div class="border border-primary bg-base-100 text-primary-content size-4 rounded items-center cursor-pointer"><!></div>'), xC = ae("<!> <!>", 1), kC = ae('<time class="text-xs"> </time>'), SC = ae("<!> <!>", 1), TC = ae('<div class="flex basis-1/2 md:basis-auto gap-2 items-center"><!> <!> <h5 class="text-secondary-content font-medium text-ellipsis"> </h5></div> <p class="line-clamp-1 basis-1/2 md:basis-auto overflow-hidden italic"><!></p>', 1), EC = ae("<!> <!>", 1), CC = ae("<emoji-picker></emoji-picker>", 2), OC = ae("<!> <!>", 1), AC = ae('<div class="flex gap-2 flex-wrap"><!> <!></div>'), MC = ae('<li><div class="relative group w-full h-fit flex flex-col gap-4 px-2 py-2.5 hover:bg-white/5 transition-all duration-75"><!> <!></div></li>');
  function NC(n, e) {
    Re(e, true);
    const t = (ne) => {
      var ce = oC();
      const Z = X(() => e.message);
      var de = J(ce);
      i(de);
      var _ = je(de, 2), W = Se(_);
      {
        var P = (j) => {
          var U = se(), ke = J(U);
          Le(ke, () => yn, (Ee, xe) => {
            xe(Ee, {
              onclick: () => {
                S(l) && te(c, true);
              },
              class: "flex flex-col text-start gap-2 w-full min-w-0",
              children: (ve, Ue) => {
                var ge = rC(), me = J(ge), Xe = Se(me);
                Tu(Xe, () => e.id), we(me);
                var He = je(me, 2), $e = Se(He);
                cs($e, () => B(S(Z)), false, false), we(He), F(ve, ge);
              },
              $$slots: {
                default: true
              }
            });
          }), F(j, U);
        }, q = (j, U) => {
          {
            var ke = (Ee) => {
              var xe = sC();
              const ve = X(() => a.value.view.messages[S(Z).relatedMessages[0]]);
              var Ue = J(xe);
              Le(Ue, () => yn, (Xe, He) => {
                He(Xe, {
                  onclick: () => {
                    S(l) && te(c, true);
                  },
                  class: "cursor-pointer flex gap-2 text-start w-full items-center text-info-content px-4 py-1 bg-info rounded-t",
                  children: ($e, Y) => {
                    var ee = iC(), ie = J(ee);
                    mn(ie, {
                      icon: "prime:reply",
                      width: "12px",
                      height: "12px"
                    });
                    var fe = je(ie, 2), he = Se(fe);
                    cs(he, () => B(S(Z)), false, false), we(fe);
                    var le = je(fe, 2);
                    Tu(le, () => e.id), F($e, ee);
                  },
                  $$slots: {
                    default: true
                  }
                });
              });
              var ge = je(Ue, 2), me = Se(ge);
              r(me, () => S(Z).relatedMessages[0], () => S(ve)), we(ge), F(Ee, xe);
            };
            be(j, (Ee) => {
              S(Z).kind === "messageMoved" && Ee(ke);
            }, U);
          }
        };
        be(W, (j) => {
          S(Z).kind === "threadCreated" ? j(P) : j(q, false);
        });
      }
      we(_), F(ne, ce);
    }, r = (ne, ce = pt, Z = pt) => {
      var de = cC();
      const _ = X(() => ia(Z().author));
      var W = J(de);
      i(W, () => S(_));
      var P = je(W, 2), q = Se(P), j = Se(q);
      Sg(j, {
        get handle() {
          return S(_).handle;
        },
        get avatarUrl() {
          return S(_).avatarUrl;
        }
      }), we(q);
      var U = je(q, 2);
      Le(U, () => yn, (ke, Ee) => {
        Ee(ke, {
          onclick: () => {
            S(l) && te(c, true);
          },
          class: "flex flex-col text-start gap-2 w-full min-w-0",
          children: (xe, ve) => {
            var Ue = lC(), ge = J(Ue), me = Se(ge), Xe = Se(me), He = Se(Xe, true);
            we(Xe), we(me);
            var $e = je(me, 2);
            Tu($e, ce), we(ge);
            var Y = je(ge, 2), ee = Se(Y);
            cs(ee, () => cu(Z().content), false, false), we(Y);
            var ie = je(Y, 2);
            {
              var fe = (he) => {
                var le = uC();
                ji(le, 21, () => Z().images, Cu, (Ce, We) => {
                  var Ve = aC();
                  qe(() => {
                    wi(Ve, "src", S(We).source), wi(Ve, "alt", S(We).alt || "");
                  }), F(Ce, Ve);
                }), we(le), F(he, le);
              };
              be(ie, (he) => {
                Z().images?.length && he(fe);
              });
            }
            qe(() => {
              wi(me, "href", `https://bsky.app/profile/${S(_).handle}`), ir(He, S(_).handle);
            }), F(xe, Ue);
          },
          $$slots: {
            default: true
          }
        });
      }), we(P), qe(() => wi(q, "href", `https://bsky.app/profile/${S(_).handle}`)), F(ne, de);
    }, i = (ne, ce = pt) => {
      var Z = xC(), de = J(Z);
      {
        var _ = (j) => {
          nC(j, {
            get isDrawerOpen() {
              return S(c);
            },
            set isDrawerOpen(U) {
              te(c, Be(U));
            },
            children: (U, ke) => {
              var Ee = gC(), xe = J(Ee), ve = Se(xe);
              Le(ve, () => yn, (He, $e) => {
                $e(He, {
                  onclick: () => {
                    D(e.id, "\u{1F44D}"), te(c, false);
                  },
                  class: "btn btn-circle",
                  children: (Y, ee) => {
                    kn();
                    var ie = Qn("\u{1F44D}");
                    F(Y, ie);
                  },
                  $$slots: {
                    default: true
                  }
                });
              });
              var Ue = je(ve, 2);
              Le(Ue, () => yn, (He, $e) => {
                $e(He, {
                  onclick: () => {
                    D(e.id, "\u{1F602}"), te(c, false);
                  },
                  class: "btn btn-circle",
                  children: (Y, ee) => {
                    kn();
                    var ie = Qn("\u{1F602}");
                    F(Y, ie);
                  },
                  $$slots: {
                    default: true
                  }
                });
              });
              var ge = je(Ue, 2);
              Le(ge, () => ua, (He, $e) => {
                $e(He, {
                  get open() {
                    return S(b);
                  },
                  set open(Y) {
                    te(b, Be(Y));
                  },
                  children: (Y, ee) => {
                    var ie = fC(), fe = J(ie);
                    Le(fe, () => aa, (le, Ce) => {
                      Ce(le, {
                        class: "btn btn-circle",
                        children: (We, Ve) => {
                          mn(We, {
                            icon: "lucide:smile-plus"
                          });
                        },
                        $$slots: {
                          default: true
                        }
                      });
                    });
                    var he = je(fe, 2);
                    Le(he, () => oa, (le, Ce) => {
                      Ce(le, {
                        children: (We, Ve) => {
                          var et = dC();
                          ct(et, (ft) => te(f, ft), () => S(f)), F(We, et);
                        },
                        $$slots: {
                          default: true
                        }
                      });
                    }), F(Y, ie);
                  },
                  $$slots: {
                    default: true
                  }
                });
              }), we(xe);
              var me = je(xe, 2);
              {
                var Xe = (He) => {
                  var $e = mC(), Y = Se($e);
                  Le(Y, () => yn, (fe, he) => {
                    he(fe, {
                      onclick: () => {
                        M({
                          id: e.id,
                          authorProfile: ce(),
                          content: e.message.content
                        }), te(c, false);
                      },
                      class: "join-item btn w-full",
                      children: (le, Ce) => {
                        var We = hC(), Ve = J(We);
                        mn(Ve, {
                          icon: "fa6-solid:reply"
                        }), kn(), F(le, We);
                      },
                      $$slots: {
                        default: true
                      }
                    });
                  });
                  var ee = je(Y, 2);
                  {
                    var ie = (fe) => {
                      var he = se(), le = J(he);
                      Le(le, () => yn, (Ce, We) => {
                        We(Ce, {
                          onclick: () => k(e.id),
                          class: "join-item btn btn-error w-full",
                          children: (Ve, et) => {
                            var ft = pC(), Qt = J(ft);
                            mn(Qt, {
                              icon: "tabler:trash"
                            }), kn(), F(Ve, ft);
                          },
                          $$slots: {
                            default: true
                          }
                        });
                      }), F(fe, he);
                    };
                    be(ee, (fe) => {
                      S(y) && fe(ie);
                    });
                  }
                  we($e), F(He, $e);
                };
                be(me, (He) => {
                  ce() && He(Xe);
                });
              }
              F(U, Ee);
            },
            $$slots: {
              default: true
            }
          });
        }, W = (j) => {
          var U = se(), ke = J(U);
          const Ee = X(() => `${!S(g) && "hidden"} group-hover:flex absolute -top-2 right-0 bg-base-300 p-1 rounded items-center`);
          Le(ke, () => Xb, (xe, ve) => {
            ve(xe, {
              get class() {
                return S(Ee);
              },
              children: (Ue, ge) => {
                var me = vC(), Xe = J(me);
                Le(Xe, () => ds, (he, le) => {
                  le(he, {
                    onclick: () => D(e.id, "\u{1F44D}"),
                    class: "btn btn-ghost btn-square",
                    children: (Ce, We) => {
                      kn();
                      var Ve = Qn("\u{1F44D}");
                      F(Ce, Ve);
                    },
                    $$slots: {
                      default: true
                    }
                  });
                });
                var He = je(Xe, 2);
                Le(He, () => ds, (he, le) => {
                  le(he, {
                    onclick: () => D(e.id, "\u{1F602}"),
                    class: "btn btn-ghost btn-square",
                    children: (Ce, We) => {
                      kn();
                      var Ve = Qn("\u{1F602}");
                      F(Ce, Ve);
                    },
                    $$slots: {
                      default: true
                    }
                  });
                });
                var $e = je(He, 2);
                Le($e, () => ua, (he, le) => {
                  le(he, {
                    get open() {
                      return S(g);
                    },
                    set open(Ce) {
                      te(g, Be(Ce));
                    },
                    children: (Ce, We) => {
                      var Ve = yC(), et = J(Ve);
                      Le(et, () => aa, (Qt, Zt) => {
                        Zt(Qt, {
                          class: "btn btn-ghost btn-square",
                          children: (Mn, rc) => {
                            mn(Mn, {
                              icon: "lucide:smile-plus"
                            });
                          },
                          $$slots: {
                            default: true
                          }
                        });
                      });
                      var ft = je(et, 2);
                      Le(ft, () => oa, (Qt, Zt) => {
                        Zt(Qt, {
                          children: (Mn, rc) => {
                            var yi = bC();
                            ct(yi, (Nn) => te(p, Nn), () => S(p)), F(Mn, yi);
                          },
                          $$slots: {
                            default: true
                          }
                        });
                      }), F(Ce, Ve);
                    },
                    $$slots: {
                      default: true
                    }
                  });
                });
                var Y = je($e, 2);
                {
                  var ee = (he) => {
                    var le = se(), Ce = J(le);
                    Le(Ce, () => ds, (We, Ve) => {
                      Ve(We, {
                        onclick: () => k(e.id),
                        class: "btn btn-ghost btn-square",
                        children: (et, ft) => {
                          mn(et, {
                            icon: "tabler:trash",
                            color: "red"
                          });
                        },
                        $$slots: {
                          default: true
                        }
                      });
                    }), F(he, le);
                  };
                  be(Y, (he) => {
                    S(N) && S(y) && he(ee);
                  });
                }
                var ie = je(Y, 2);
                {
                  var fe = (he) => {
                    var le = se(), Ce = J(le);
                    Le(Ce, () => ds, (We, Ve) => {
                      Ve(We, {
                        onclick: () => M({
                          id: e.id,
                          authorProfile: ce(),
                          content: e.message.content
                        }),
                        class: "btn btn-ghost btn-square",
                        children: (et, ft) => {
                          mn(et, {
                            icon: "fa6-solid:reply"
                          });
                        },
                        $$slots: {
                          default: true
                        }
                      });
                    }), F(he, le);
                  };
                  be(ie, (he) => {
                    ce() && he(fe);
                  });
                }
                F(Ue, me);
              },
              $$slots: {
                default: true
              }
            });
          }), F(j, U);
        };
        be(de, (j) => {
          S(l) ? j(_) : j(W, false);
        });
      }
      var P = je(de, 2);
      {
        var q = (j) => {
          var U = se(), ke = J(U);
          Le(ke, () => jg, (Ee, xe) => {
            xe(Ee, {
              onCheckedChange: O,
              class: "absolute right-4 inset-y-0",
              get checked() {
                return S(h);
              },
              set checked(Ue) {
                te(h, Be(Ue));
              },
              children: (Ue, ge) => {
                let me = () => ge?.().checked;
                var Xe = wC(), He = Se(Xe);
                {
                  var $e = (Y) => {
                    mn(Y, {
                      icon: "material-symbols:check-rounded",
                      class: "bg-primary size-3.5"
                    });
                  };
                  be(He, (Y) => {
                    me() && Y($e);
                  });
                }
                we(Xe), F(Ue, Xe);
              },
              $$slots: {
                default: true
              }
            });
          }), F(j, U);
        };
        be(P, (j) => {
          d.value && !xi(e.message) && j(q);
        });
      }
      F(ne, Z);
    }, s = (ne, ce = pt) => {
      var Z = se(), de = J(Z);
      const _ = X(() => `
      btn
      ${sa.profile.data && e.message.reactions[ce()].includes(sa.profile.data.did) ? "bg-accent text-accent-content" : "bg-secondary text-secondary-content"}
    `), W = X(() => (u[ce()] || []).join(", "));
      Le(de, () => yn, (P, q) => {
        q(P, {
          onclick: () => D(e.id, ce()),
          get class() {
            return S(_);
          },
          get title() {
            return S(W);
          },
          children: (j, U) => {
            kn();
            var ke = Qn();
            qe(() => ir(ke, `${ce() ?? ""}
    ${e.message.reactions[ce()].length ?? ""}`)), F(j, ke);
          },
          $$slots: {
            default: true
          }
        });
      }), F(ne, Z);
    }, o = (ne) => {
      var ce = se();
      const Z = X(() => !xi(e.message) && e.message.replyTo && a.value.view.messages[e.message.replyTo]), de = X(() => S(Z) && ia(S(Z).author));
      var _ = J(ce);
      {
        var W = (P) => {
          var q = se(), j = J(q);
          Le(j, () => yn, (U, ke) => {
            ke(U, {
              onclick: E,
              class: "cursor-pointer flex gap-2 text-sm text-start w-full items-center text-secondary-content px-4 py-1 bg-secondary rounded-t",
              children: (Ee, xe) => {
                var ve = TC(), Ue = J(ve), ge = Se(Ue);
                mn(ge, {
                  icon: "prime:reply",
                  width: "12px",
                  height: "12px"
                });
                var me = je(ge, 2);
                Le(me, () => Tg, (ee, ie) => {
                  ie(ee, {
                    class: "w-4",
                    children: (fe, he) => {
                      var le = SC(), Ce = J(le);
                      Le(Ce, () => Eg, (Ve, et) => {
                        et(Ve, {
                          get src() {
                            return S(de).avatarUrl;
                          },
                          class: "rounded-full"
                        });
                      });
                      var We = je(Ce, 2);
                      Le(We, () => Cg, (Ve, et) => {
                        et(Ve, {
                          children: (ft, Qt) => {
                            Og(ft, {
                              get name() {
                                return S(de).handle;
                              }
                            });
                          },
                          $$slots: {
                            default: true
                          }
                        });
                      }), F(fe, le);
                    },
                    $$slots: {
                      default: true
                    }
                  });
                });
                var Xe = je(me, 2), He = Se(Xe, true);
                we(Xe), we(Ue);
                var $e = je(Ue, 2), Y = Se($e);
                cs(Y, () => cu(S(Z).content), false, false), we($e), qe(() => ir(He, S(de).handle)), F(Ee, ve);
              },
              $$slots: {
                default: true
              }
            });
          }), F(P, q);
        };
        be(_, (P) => {
          S(Z) && S(de) && P(W);
        });
      }
      F(ne, ce);
    };
    let a = sn("space"), u = Be(Object.fromEntries(Object.entries(e.message.reactions).map(([ne, ce]) => [
      ne,
      ce.map((Z) => ia(Z).handle)
    ]))), l = X(() => (mg.current ?? 0) < 640), c = Me(false), h = Me(false), d = sn("isThreading"), f = Me(void 0), p = Me(void 0), m = Me(void 0), b = Me(false), g = Me(false), w = Me(false);
    const v = sn("isAdmin");
    let y = X(() => !xi(e.message) && (v.value || sa.agent?.did == e.message.author));
    const x = sn("selectMessage"), k = sn("deleteMessage"), T = sn("removeSelectedMessage"), M = sn("setReplyTo"), D = sn("toggleReaction"), I = sn("scrollToMessage");
    function C(ne) {
      D(e.id, ne.detail.unicode), te(g, false), te(w, false);
    }
    function O() {
      S(h) ? x(e.id) : T(e.id);
    }
    function E() {
      xi(e.message) || !e.message.replyTo || I(e.message.replyTo);
    }
    at(() => {
      d.value || te(h, false);
    }), at(() => {
      S(p) && S(p).addEventListener("emoji-click", C), S(f) && S(f).addEventListener("emoji-click", (ne) => {
        C(ne), te(b, false), te(c, false);
      }), S(m) && S(m).addEventListener("emoji-click", C);
    });
    let N = Me(false);
    function A({ shiftKey: ne }) {
      te(N, Be(ne));
    }
    function R({ shiftKey: ne }) {
      te(N, Be(ne));
    }
    function B(ne) {
      const ce = {
        type: "doc",
        content: []
      };
      switch (ne.kind) {
        case "threadCreated": {
          const Z = a.value.view.threads[ne.relatedThreads[0]];
          ce.content.push({
            type: "paragraph",
            content: [
              {
                type: "text",
                text: "A new thread has been created: "
              },
              {
                type: "channelThreadMention",
                attrs: {
                  id: JSON.stringify({
                    ulid: ne.relatedThreads[0],
                    space: dc.params.space,
                    type: "thread"
                  }),
                  label: Z.title
                }
              }
            ]
          });
          break;
        }
        case "messageMoved": {
          const Z = a.value.view.threads[ne.relatedThreads[0]];
          ce.content.push({
            type: "paragraph",
            content: [
              {
                type: "text",
                text: "Moved to: "
              },
              {
                type: "channelThreadMention",
                attrs: {
                  id: JSON.stringify({
                    ulid: ne.relatedThreads[0],
                    space: dc.params.space,
                    type: "thread"
                  }),
                  label: Z.title
                }
              }
            ]
          });
          break;
        }
        case "messageDeleted": {
          ce.content.push({
            type: "paragraph",
            content: [
              {
                type: "text",
                text: "This message has been deleted"
              }
            ]
          });
          break;
        }
      }
      return cu(JSON.stringify(ce));
    }
    var z = MC();
    Oe("keydown", oc, A), Oe("keyup", oc, R);
    var L = Se(z), V = Se(L);
    {
      var K = (ne) => {
        t(ne);
      }, pe = (ne) => {
        var ce = EC(), Z = J(ce);
        o(Z);
        var de = je(Z, 2);
        r(de, () => e.id, () => e.message), F(ne, ce);
      };
      be(V, (ne) => {
        xi(e.message) ? ne(K) : ne(pe, false);
      });
    }
    var H = je(V, 2);
    {
      var ue = (ne) => {
        var ce = AC(), Z = Se(ce);
        ji(Z, 17, () => Object.keys(e.message.reactions), Cu, (_, W) => {
          s(_, () => S(W));
        });
        var de = je(Z, 2);
        Le(de, () => ua, (_, W) => {
          W(_, {
            get open() {
              return S(w);
            },
            set open(P) {
              te(w, Be(P));
            },
            children: (P, q) => {
              var j = OC(), U = J(j);
              Le(U, () => aa, (Ee, xe) => {
                xe(Ee, {
                  class: "p-2 hover:bg-white/5 hover:scale-105 active:scale-95 transition-all duration-150 rounded cursor-pointer",
                  children: (ve, Ue) => {
                    mn(ve, {
                      icon: "lucide:smile-plus",
                      color: "white"
                    });
                  },
                  $$slots: {
                    default: true
                  }
                });
              });
              var ke = je(U, 2);
              Le(ke, () => oa, (Ee, xe) => {
                xe(Ee, {
                  children: (ve, Ue) => {
                    var ge = CC();
                    ct(ge, (me) => te(m, me), () => S(m)), F(ve, ge);
                  },
                  $$slots: {
                    default: true
                  }
                });
              }), F(P, j);
            },
            $$slots: {
              default: true
            }
          });
        }), we(ce), F(ne, ce);
      };
      be(H, (ne) => {
        Object.keys(e.message.reactions).length > 0 && ne(ue);
      });
    }
    we(L), we(z), qe(() => {
      wi(z, "id", e.id), pg(z, 1, `flex flex-col ${S(l) && "max-w-screen"}`);
    }), F(n, z), _e();
  }
  const $m = (n) => Object.keys(n).reduce((e, t) => {
    const r = n[t];
    return r == null ? e : e + `${t}:${r};`;
  }, ""), PC = (n, e) => "_" + e;
  function* DC([n, e]) {
    for (let t = n; t <= e; t++) yield t;
  }
  const si = null, { min: Mr, max: xn, abs: Sh, floor: IC } = Math, Vm = (n, e, t) => Mr(t, xn(e, n)), RC = (n) => [
    ...n
  ].sort((e, t) => e - t), _C = typeof queueMicrotask == "function" ? queueMicrotask : (n) => {
    Promise.resolve().then(n);
  }, nc = (n) => {
    let e, t;
    return () => (e || (e = true, t = n()), t);
  }, Lr = -1, To = (n, e, t) => {
    const r = t ? "unshift" : "push";
    for (let i = 0; i < e; i++) n[r](Lr);
    return n;
  }, Eo = (n, e) => {
    const t = n.t[e];
    return t === Lr ? n.o : t;
  }, LC = (n, e, t) => {
    const r = n.t[e] === Lr;
    return n.t[e] = t, n.i = Mr(e, n.i), r;
  }, Ks = (n, e) => {
    if (!n.l) return 0;
    if (n.i >= e) return n.u[e];
    n.i < 0 && (n.u[0] = 0, n.i = 0);
    let t = n.i, r = n.u[t];
    for (; t < e; ) r += Eo(n, t), n.u[++t] = r;
    return n.i = e, r;
  }, wr = (n, e, t = 0, r = n.l - 1) => {
    for (; t <= r; ) {
      const i = IC((t + r) / 2), s = Ks(n, i);
      if (s <= e) {
        if (s + Eo(n, i) > e) return i;
        t = i + 1;
      } else r = i - 1;
    }
    return Vm(t, 0, n.l - 1);
  }, Th = (n, e, t) => {
    const r = e - n.l;
    return n.i = t ? -1 : Mr(e - 1, n.i), n.l = e, r > 0 ? (To(n.u, r), To(n.t, r, t), n.o * r) : (n.u.splice(r), (t ? n.t.splice(0, -r) : n.t.splice(r)).reduce((i, s) => i - (s === Lr ? n.o : s), 0));
  }, BC = typeof window < "u", Hm = () => document.documentElement, FC = (n) => n.ownerDocument, zC = (n) => n.defaultView, Wm = nc(() => !!BC && getComputedStyle(Hm()).direction === "rtl"), Um = nc(() => /iP(hone|od|ad)/.test(navigator.userAgent)), jC = nc(() => "scrollBehavior" in Hm().style), qC = 5, $C = 6, VC = 1, HC = 4, WC = 8, UC = (n) => xn(n.$getTotalSize(), n.$getViewportSize()), GC = (n) => !!n.$getViewportSize(), KC = (n, e = 40, t = 4, r = 0, i, s = false) => {
    let o = !!r, a = 1, u = 0, l = 0, c = 0, h = 0, d = 0, f = 0, p = 0, m = 0, b = o ? [
      0,
      xn(r - 1, 0)
    ] : si, g = [
      0,
      0
    ], w = 0;
    const v = ((O, E, N) => ({
      o: E,
      t: To([], O),
      l: O,
      i: -1,
      u: To([], O)
    }))(n, e), y = /* @__PURE__ */ new Set(), x = () => c - l, k = () => x() + d + h, T = (O) => ((E, N, A, R) => {
      if (R = Mr(R, E.l - 1), Ks(E, R) <= N) {
        const B = wr(E, N + A, R);
        return [
          wr(E, N, R, B),
          B
        ];
      }
      {
        const B = wr(E, N, void 0, R);
        return [
          B,
          wr(E, N + A, B)
        ];
      }
    })(v, O, u, g[0]), M = () => ((O) => O.l ? Ks(O, O.l - 1) + Eo(O, O.l - 1) : 0)(v), D = (O) => Ks(v, O) - d, I = (O) => Eo(v, O), C = (O) => {
      O && (Um() && p !== 0 ? d += O : h += O);
    };
    return {
      $getStateVersion: () => a,
      $getCacheSnapshot: () => ((O) => [
        O.t.slice(),
        O.o
      ])(v),
      $getRange: () => {
        let O, E;
        return f ? [O, E] = g : ([O, E] = g = T(xn(0, k())), b && (O = Mr(O, b[0]), E = xn(E, b[1]))), p !== 1 && (O -= xn(0, t)), p !== 2 && (E += xn(0, t)), [
          xn(O, 0),
          Mr(E, v.l - 1)
        ];
      },
      $findStartIndex: () => wr(v, k()),
      $findEndIndex: () => wr(v, k() + u),
      $isUnmeasuredItem: (O) => v.t[O] === Lr,
      $: () => !!b && v.t.slice(xn(0, b[0] - 1), Mr(v.l - 1, b[1] + 1) + 1).includes(Lr),
      $getItemOffset: D,
      $getItemSize: I,
      $getItemsLength: () => v.l,
      $getScrollOffset: () => c,
      $isScrolling: () => p !== 0,
      $getViewportSize: () => u,
      $getStartSpacerSize: () => l,
      $getTotalSize: M,
      h: () => (f = h, h = 0, [
        f,
        m === 2 || x() + u >= M()
      ]),
      $subscribe: (O, E) => {
        const N = [
          O,
          E
        ];
        return y.add(N), () => {
          y.delete(N);
        };
      },
      $update: (O, E) => {
        let N, A, R = 0;
        switch (O) {
          case 1: {
            const B = f;
            f = 0;
            const z = E - c, L = Sh(z);
            B && L < Sh(B) + 1 || m !== 0 || (p = z < 0 ? 2 : 1), o && (b = si, o = false), c = E, R = 4;
            const V = x();
            V >= -u && V <= M() && (R += 1, A = L > u);
            break;
          }
          case 2:
            R = 8, p !== 0 && (N = true, R += 1), p = 0, m = 0, b = si;
            break;
          case 3: {
            const B = E.filter(([z, L]) => v.t[z] !== L);
            if (!B.length) break;
            C(B.reduce((z, [L, V]) => ((m === 2 || (b ? !o && L < b[0] : D(L) + (p === 0 && m === 0 ? I(L) : 0) < x())) && (z += V - I(L)), z), 0));
            for (const [z, L] of B) {
              const V = I(z), K = LC(v, z, L);
              s && (w += K ? L : L - V);
            }
            s && u && w > u && (C(((z, L) => {
              let V = 0;
              const K = [];
              z.t.forEach((Z, de) => {
                Z !== Lr && (K.push(Z), de < L && V++);
              }), z.i = -1;
              const pe = RC(K), H = pe.length, ue = H / 2 | 0, ne = H % 2 == 0 ? (pe[ue - 1] + pe[ue]) / 2 : pe[ue], ce = z.o;
              return ((z.o = ne) - ce) * xn(L - V, 0);
            })(v, wr(v, k()))), s = false), R = 3, A = true;
            break;
          }
          case 4:
            u !== E && (u = E, R = 3);
            break;
          case 5:
            E[1] ? (C(Th(v, E[0], true)), m = 2, R = 1) : (Th(v, E[0]), R = 1);
            break;
          case 6:
            l = E;
            break;
          case 7:
            m = 1;
            break;
          case 8:
            b = T(E), R = 1;
        }
        R && (a = 1 + (2147483647 & a), N && d && (h += d, d = 0), y.forEach(([B, z]) => {
          R & B && z(A);
        }));
      }
    };
  }, rl = setTimeout, Js = (n, e) => e && Wm() ? -n : n, JC = (n, e, t, r, i, s) => {
    const o = Date.now;
    let a = 0, u = false, l = false, c = false, h = false;
    const d = (() => {
      let g;
      const w = () => {
        g != si && clearTimeout(g);
      }, v = () => {
        w(), g = rl(() => {
          g = si, (() => {
            if (u || l) return u = false, void d();
            c = false, n.$update(2);
          })();
        }, 150);
      };
      return v.p = w, v;
    })(), f = () => {
      a = o(), c && (h = true), n.$update(1, r()), d();
    }, p = (g) => {
      if (u || !n.$isScrolling() || g.ctrlKey) return;
      const w = o() - a;
      150 > w && 50 < w && (t ? g.deltaX : g.deltaY) && (u = true);
    }, m = () => {
      l = true, c = h = false;
    }, b = () => {
      l = false, Um() && (c = true);
    };
    return e.addEventListener("scroll", f), e.addEventListener("wheel", p, {
      passive: true
    }), e.addEventListener("touchstart", m, {
      passive: true
    }), e.addEventListener("touchend", b, {
      passive: true
    }), {
      m: () => {
        e.removeEventListener("scroll", f), e.removeEventListener("wheel", p), e.removeEventListener("touchstart", m), e.removeEventListener("touchend", b), d.p();
      },
      v: () => {
        const [g, w] = n.h();
        g && (i(Js(g, t), w, h), h = false, w && n.$getViewportSize() > n.$getTotalSize() && n.$update(1, r()));
      }
    };
  }, YC = (n, e) => {
    let t, r, i;
    const s = e ? "scrollLeft" : "scrollTop", o = e ? "overflowX" : "overflowY", a = async (u, l) => {
      if (!t) return void _C(() => a(u, l));
      i && i();
      const c = () => {
        let h;
        return [
          new Promise((d, f) => {
            h = d, i = f, GC(n) && rl(f, 150);
          }),
          n.$subscribe(2, () => {
            h && h();
          })
        ];
      };
      if (l && jC()) {
        for (; n.$update(8, u()), n.$(); ) {
          const [h, d] = c();
          try {
            await h;
          } catch {
            return;
          } finally {
            d();
          }
        }
        t.scrollTo({
          [e ? "left" : "top"]: Js(u(), e),
          behavior: "smooth"
        });
      } else for (; ; ) {
        const [h, d] = c();
        try {
          t[s] = Js(u(), e), n.$update(7), await h;
        } catch {
          return;
        } finally {
          d();
        }
      }
    };
    return {
      $observe(u) {
        t = u, r = JC(n, u, e, () => Js(u[s], e), (l, c, h) => {
          if (h) {
            const d = u.style, f = d[o];
            d[o] = "hidden", rl(() => {
              d[o] = f;
            });
          }
          c ? (u[s] = n.$getScrollOffset() + l, i && i()) : u[s] += l;
        });
      },
      $dispose() {
        r && r.m();
      },
      $scrollTo(u) {
        a(() => u);
      },
      $scrollBy(u) {
        u += n.$getScrollOffset(), a(() => u);
      },
      $scrollToIndex(u, { align: l, smooth: c, offset: h = 0 } = {}) {
        if (u = Vm(u, 0, n.$getItemsLength() - 1), l === "nearest") {
          const d = n.$getItemOffset(u), f = n.$getScrollOffset();
          if (d < f) l = "start";
          else {
            if (!(d + n.$getItemSize(u) > f + n.$getViewportSize())) return;
            l = "end";
          }
        }
        a(() => h + n.$getStartSpacerSize() + n.$getItemOffset(u) + (l === "end" ? n.$getItemSize(u) - n.$getViewportSize() : l === "center" ? (n.$getItemSize(u) - n.$getViewportSize()) / 2 : 0), c);
      },
      $fixScrollJump: () => {
        r && r.v();
      }
    };
  }, XC = (n) => {
    let e;
    return {
      S(t) {
        (e || (e = new (zC(FC(t))).ResizeObserver(n))).observe(t);
      },
      I(t) {
        e.unobserve(t);
      },
      m() {
        e && e.disconnect();
      }
    };
  }, QC = (n, e) => {
    let t;
    const r = e ? "width" : "height", i = /* @__PURE__ */ new WeakMap(), s = XC((o) => {
      const a = [];
      for (const { target: u, contentRect: l } of o) if (u.offsetParent) if (u === t) n.$update(4, l[r]);
      else {
        const c = i.get(u);
        c != si && a.push([
          c,
          l[r]
        ]);
      }
      a.length && n.$update(3, a);
    });
    return {
      $observeRoot(o) {
        s.S(t = o);
      },
      $observeItem: (o, a) => (i.set(o, a), s.S(o), () => {
        i.delete(o), s.I(o);
      }),
      $dispose: s.m
    };
  };
  function ZC(n, e) {
    Re(e, true);
    let t = $(e, "as", 3, "div"), r, i, s;
    at(() => {
      s !== e.index && (i && i(), i = e.resizer(r, s = e.index));
    }), Xi(() => {
      i && i();
    });
    let o = X(() => {
      const l = {
        position: "absolute",
        [e.horizontal ? "height" : "width"]: "100%",
        [e.horizontal ? "top" : "left"]: "0px",
        [e.horizontal ? Wm() ? "right" : "left" : "top"]: e.offset + "px",
        visibility: e.hide ? "hidden" : "visible"
      };
      return e.horizontal && (l.display = "flex"), $m(l);
    });
    var a = se(), u = J(a);
    ol(u, t, false, (l, c) => {
      ct(l, (p) => r = p, () => r);
      let h;
      qe(() => h = Ge(l, h, {
        style: S(o)
      }));
      var d = se(), f = J(d);
      rt(f, () => e.children, () => e.item, () => e.index), F(c, d);
    }), F(n, a), _e();
  }
  function e4(n, e) {
    Re(e, true);
    let t = $(e, "getKey", 3, PC), r = $(e, "as", 3, "div"), i = $(e, "shift", 3, false), s = $(e, "horizontal", 3, false), o = $(e, "startMargin", 3, 0);
    const a = KC(e.data.length, e.itemSize, e.overscan, void 0, void 0, !e.itemSize), u = QC(a, s()), l = YC(a, s()), c = a.$subscribe(VC, () => {
      te(p, Be(a.$getStateVersion()));
    }), h = a.$subscribe(HC, () => {
      e.onscroll && e.onscroll(a.$getScrollOffset());
    }), d = a.$subscribe(WC, () => {
      e.onscrollend && e.onscrollend();
    });
    let f = Me(void 0), p = Me(Be(a.$getStateVersion())), m = X(() => S(p) && a.$getRange()), b = X(() => S(p) && a.$isScrolling()), g = X(() => S(p) && a.$getTotalSize());
    Ao(() => {
      const R = (B) => {
        u.$observeRoot(B), l.$observe(B);
      };
      e.scrollRef ? R(e.scrollRef) : R(S(f).parentElement);
    }), Xi(() => {
      c(), h(), d(), u.$dispose(), l.$dispose();
    }), Eu(() => {
      e.data.length !== a.$getItemsLength() && a.$update(qC, [
        e.data.length,
        i()
      ]);
    }), Eu(() => {
      o() !== a.$getStartSpacerSize() && a.$update($C, o());
    });
    let w;
    at(() => {
      w !== S(p) && (w = S(p), l.$fixScrollJump());
    });
    const v = a.$getScrollOffset, y = () => UC(a), x = a.$getViewportSize, k = a.$findStartIndex, T = a.$findEndIndex, M = a.$getItemOffset, D = a.$getItemSize, I = l.$scrollToIndex, C = l.$scrollTo, O = l.$scrollBy;
    let E = X(() => $m({
      "overflow-anchor": "none",
      flex: "none",
      position: "relative",
      visibility: "hidden",
      width: s() ? S(g) + "px" : "100%",
      height: s() ? "100%" : S(g) + "px",
      "pointer-events": S(b) ? "none" : void 0
    }));
    var N = se(), A = J(N);
    return ol(A, r, false, (R, B) => {
      ct(R, (K) => te(f, Be(K)), () => S(f));
      let z;
      qe(() => z = Ge(R, z, {
        style: S(E)
      }));
      var L = se(), V = J(L);
      ji(V, 17, () => DC(S(m)), (K) => t()(e.data[K], K), (K, pe) => {
        const H = X(() => e.data[S(pe)]), ue = X(() => S(p) && a.$getItemOffset(S(pe))), ne = X(() => S(p) && a.$isUnmeasuredItem(S(pe)));
        ZC(K, {
          get children() {
            return e.children;
          },
          get item() {
            return S(H);
          },
          get index() {
            return S(pe);
          },
          get as() {
            return e.item;
          },
          get offset() {
            return S(ue);
          },
          get hide() {
            return S(ne);
          },
          get horizontal() {
            return s();
          },
          get resizer() {
            return u.$observeItem;
          }
        });
      }), F(B, L);
    }), F(n, N), _e({
      getScrollOffset: v,
      getScrollSize: y,
      getViewportSize: x,
      findStartIndex: k,
      findEndIndex: T,
      getItemOffset: M,
      getItemSize: D,
      scrollToIndex: I,
      scrollTo: C,
      scrollBy: O
    });
  }
  var t4 = ae('<p class="italic text-error text-sm">This message has been deleted</p>'), n4 = ae('<ol class="flex flex-col gap-4 max-w-full"><!></ol>'), r4 = ae("<!> <!> <!>", 1);
  N4 = function(n, e) {
    Re(e, true);
    let t = X(() => e.source.type == "dm" ? e.source.channel.view.messages : e.source.space.view.messages);
    il("scrollToMessage", (u) => {
      const l = e.timeline.indexOf(u);
      l !== -1 && S(i) && S(i).scrollToIndex(l, {
        smooth: true
      });
    });
    let r = Me(null), i = Me(void 0), s = Me(true);
    dg(() => {
      setTimeout(() => {
        S(i) && S(i).scrollToIndex(e.timeline.length - 1);
      }, 100);
    }), at(() => {
      te(s, true), S(r) && (S(t) || S(s)) && (S(r).scrollTop = S(r).scrollHeight, setTimeout(() => {
        S(i) && S(i).scrollToIndex(e.timeline.length - 1);
      }, 100), te(s, false));
    });
    var o = se(), a = J(o);
    Le(a, () => Ab, (u, l) => {
      l(u, {
        type: "scroll",
        class: "h-full overflow-hidden relative",
        children: (c, h) => {
          var d = r4(), f = J(d);
          Le(f, () => Nb, (b, g) => {
            g(b, {
              class: "w-full max-w-full h-full",
              get ref() {
                return S(r);
              },
              set ref(w) {
                te(r, Be(w));
              },
              children: (w, v) => {
                var y = n4(), x = Se(y);
                cg(x, () => S(r), (k) => {
                  const T = X(() => e.timeline || []);
                  ct(e4(k, {
                    get data() {
                      return S(T);
                    },
                    getKey: (D, I) => D,
                    get scrollRef() {
                      return S(r);
                    },
                    children: (D, I = pt, C = pt) => {
                      var O = se();
                      const E = X(() => S(t)[I()]);
                      var N = J(O);
                      {
                        var A = (B) => {
                          NC(B, {
                            get id() {
                              return I();
                            },
                            get message() {
                              return S(E);
                            }
                          });
                        }, R = (B) => {
                          var z = t4();
                          F(B, z);
                        };
                        be(N, (B) => {
                          S(E) && !S(E).softDeleted ? B(A) : B(R, false);
                        });
                      }
                      F(D, O);
                    },
                    $$slots: {
                      default: true
                    }
                  }), (D) => te(i, Be(D)), () => S(i));
                }), we(y), F(w, y);
              },
              $$slots: {
                default: true
              }
            });
          });
          var p = je(f, 2);
          Le(p, () => Bb, (b, g) => {
            g(b, {
              orientation: "vertical",
              class: "flex h-full w-2.5 touch-none select-none rounded-full border-l border-l-transparent p-px transition-all hover:w-3 hover:bg-dark-10 mr-1",
              children: (w, v) => {
                var y = se(), x = J(y);
                Le(x, () => jb, (k, T) => {
                  T(k, {
                    class: "relative flex-1 rounded-full bg-base-300 transition-opacity"
                  });
                }), F(w, y);
              },
              $$slots: {
                default: true
              }
            });
          });
          var m = je(p, 2);
          Le(m, () => Vb, (b, g) => {
            g(b, {});
          }), F(c, d);
        },
        $$slots: {
          default: true
        }
      });
    }), F(n, o), _e();
  };
  const i4 = At.create({
    name: "placeholder",
    addOptions() {
      return {
        emptyEditorClass: "is-editor-empty",
        emptyNodeClass: "is-empty",
        placeholder: "Write something \u2026",
        showOnlyWhenEditable: true,
        showOnlyCurrent: true,
        includeChildren: false
      };
    },
    addProseMirrorPlugins() {
      return [
        new Dt({
          key: new Vt("placeholder"),
          props: {
            decorations: ({ doc: n, selection: e }) => {
              const t = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: r } = e, i = [];
              if (!t) return null;
              const s = this.editor.isEmpty;
              return n.descendants((o, a) => {
                const u = r >= a && r <= a + o.nodeSize, l = !o.isLeaf && Go(o);
                if ((u || !this.options.showOnlyCurrent) && l) {
                  const c = [
                    this.options.emptyNodeClass
                  ];
                  s && c.push(this.options.emptyEditorClass);
                  const h = jt.node(a, a + o.nodeSize, {
                    class: c.join(" "),
                    "data-placeholder": typeof this.options.placeholder == "function" ? this.options.placeholder({
                      editor: this.editor,
                      node: o,
                      pos: a,
                      hasAnchor: u
                    }) : this.options.placeholder
                  });
                  i.push(h);
                }
                return this.options.includeChildren;
              }), ut.create(n, i);
            }
          }
        })
      ];
    }
  });
  var s4 = ae("<div></div>");
  P4 = function(n, e) {
    Re(e, true);
    let t = $(e, "content", 31, () => Be({})), r = Me(void 0), i = X(() => [
      N0.configure({
        heading: false
      }),
      i4.configure({
        placeholder: "Write something ..."
      }),
      aS({
        onEnter: e.onEnter
      }),
      uS({
        users: e.users
      }),
      lS({
        context: e.context
      })
    ]), s = Me(void 0);
    Ao(() => {
      te(s, Be(new wd({
        element: S(r),
        extensions: S(i),
        content: t(),
        editorProps: {
          attributes: {
            class: "w-full px-3 py-2 rounded bg-base-300 text-base-content outline-none"
          }
        },
        onUpdate: (a) => {
          t(a.editor.getJSON());
        }
      })));
    }), at(() => {
      Br(() => S(s)?.destroy()), te(s, Be(new wd({
        element: S(r),
        extensions: S(i),
        content: Br(() => t()),
        editorProps: {
          attributes: {
            class: "w-full px-3 py-2 rounded bg-base-300 text-base-content outline-none"
          }
        },
        onUpdate: (a) => {
          t(a.editor.getJSON());
        }
      })));
    }), Xi(() => {
      S(s)?.destroy();
    });
    var o = s4();
    ct(o, (a) => te(r, a), () => S(r)), F(n, o), _e();
  };
});
export {
  N4 as C,
  aa as P,
  __tla,
  oa as a,
  ua as b,
  P4 as c,
  Uf as f,
  cu as g,
  b3 as i
};
